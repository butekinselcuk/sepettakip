
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Courier
 * 
 */
export type Courier = $Result.DefaultSelection<Prisma.$CourierPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Business
 * 
 */
export type Business = $Result.DefaultSelection<Prisma.$BusinessPayload>
/**
 * Model Zone
 * 
 */
export type Zone = $Result.DefaultSelection<Prisma.$ZonePayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Delivery
 * 
 */
export type Delivery = $Result.DefaultSelection<Prisma.$DeliveryPayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model DeliveryLog
 * 
 */
export type DeliveryLog = $Result.DefaultSelection<Prisma.$DeliveryLogPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model ScheduledReport
 * 
 */
export type ScheduledReport = $Result.DefaultSelection<Prisma.$ScheduledReportPayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model MenuItem
 * 
 */
export type MenuItem = $Result.DefaultSelection<Prisma.$MenuItemPayload>
/**
 * Model CourierAvailability
 * 
 */
export type CourierAvailability = $Result.DefaultSelection<Prisma.$CourierAvailabilityPayload>
/**
 * Model DeliveryTimeWindow
 * 
 */
export type DeliveryTimeWindow = $Result.DefaultSelection<Prisma.$DeliveryTimeWindowPayload>
/**
 * Model DeliveryRoute
 * 
 */
export type DeliveryRoute = $Result.DefaultSelection<Prisma.$DeliveryRoutePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model SystemAction
 * 
 */
export type SystemAction = $Result.DefaultSelection<Prisma.$SystemActionPayload>
/**
 * Model SystemSettings
 * 
 */
export type SystemSettings = $Result.DefaultSelection<Prisma.$SystemSettingsPayload>
/**
 * Model AdminDashboardWidget
 * 
 */
export type AdminDashboardWidget = $Result.DefaultSelection<Prisma.$AdminDashboardWidgetPayload>
/**
 * Model AdminPermission
 * 
 */
export type AdminPermission = $Result.DefaultSelection<Prisma.$AdminPermissionPayload>
/**
 * Model AdminRole
 * 
 */
export type AdminRole = $Result.DefaultSelection<Prisma.$AdminRolePayload>
/**
 * Model AdminRoleMapping
 * 
 */
export type AdminRoleMapping = $Result.DefaultSelection<Prisma.$AdminRoleMappingPayload>
/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>
/**
 * Model SentEmail
 * 
 */
export type SentEmail = $Result.DefaultSelection<Prisma.$SentEmailPayload>
/**
 * Model CustomerAddress
 * 
 */
export type CustomerAddress = $Result.DefaultSelection<Prisma.$CustomerAddressPayload>
/**
 * Model RefundRequest
 * 
 */
export type RefundRequest = $Result.DefaultSelection<Prisma.$RefundRequestPayload>
/**
 * Model CancellationRequest
 * 
 */
export type CancellationRequest = $Result.DefaultSelection<Prisma.$CancellationRequestPayload>
/**
 * Model RefundPolicy
 * 
 */
export type RefundPolicy = $Result.DefaultSelection<Prisma.$RefundPolicyPayload>
/**
 * Model SavedPaymentMethod
 * 
 */
export type SavedPaymentMethod = $Result.DefaultSelection<Prisma.$SavedPaymentMethodPayload>
/**
 * Model SubscriptionPlan
 * 
 */
export type SubscriptionPlan = $Result.DefaultSelection<Prisma.$SubscriptionPlanPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model RecurringPayment
 * 
 */
export type RecurringPayment = $Result.DefaultSelection<Prisma.$RecurringPaymentPayload>
/**
 * Model DashboardMetric
 * 
 */
export type DashboardMetric = $Result.DefaultSelection<Prisma.$DashboardMetricPayload>
/**
 * Model EmailSettings
 * 
 */
export type EmailSettings = $Result.DefaultSelection<Prisma.$EmailSettingsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const NotificationType: {
  ORDER_PLACED: 'ORDER_PLACED',
  ORDER_ACCEPTED: 'ORDER_ACCEPTED',
  ORDER_READY: 'ORDER_READY',
  ORDER_DELIVERED: 'ORDER_DELIVERED',
  ORDER_CANCELLED: 'ORDER_CANCELLED',
  COURIER_ASSIGNED: 'COURIER_ASSIGNED',
  PAYMENT_PROCESSED: 'PAYMENT_PROCESSED',
  REVIEW_REQUESTED: 'REVIEW_REQUESTED',
  SYSTEM_NOTIFICATION: 'SYSTEM_NOTIFICATION'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationChannel: {
  EMAIL: 'EMAIL',
  PUSH: 'PUSH',
  SMS: 'SMS'
};

export type NotificationChannel = (typeof NotificationChannel)[keyof typeof NotificationChannel]


export const NotificationFrequency: {
  INSTANT: 'INSTANT',
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type NotificationFrequency = (typeof NotificationFrequency)[keyof typeof NotificationFrequency]


export const Role: {
  ADMIN: 'ADMIN',
  BUSINESS: 'BUSINESS',
  COURIER: 'COURIER',
  CUSTOMER: 'CUSTOMER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Status: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  PREPARING: 'PREPARING',
  READY: 'READY',
  IN_TRANSIT: 'IN_TRANSIT',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED',
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED',
  RETURNED: 'RETURNED',
  REFUNDED: 'REFUNDED',
  PARTIALLY_REFUNDED: 'PARTIALLY_REFUNDED',
  ACCEPTED: 'ACCEPTED',
  PICKED_UP: 'PICKED_UP',
  FAILED: 'FAILED'
};

export type Status = (typeof Status)[keyof typeof Status]


export const ReportType: {
  DAILY_PERFORMANCE: 'DAILY_PERFORMANCE',
  WEEKLY_SUMMARY: 'WEEKLY_SUMMARY',
  MONTHLY_ANALYTICS: 'MONTHLY_ANALYTICS',
  CUSTOM: 'CUSTOM',
  COURIER_PERFORMANCE: 'COURIER_PERFORMANCE',
  BUSINESS_PERFORMANCE: 'BUSINESS_PERFORMANCE'
};

export type ReportType = (typeof ReportType)[keyof typeof ReportType]


export const ReportFormat: {
  PDF: 'PDF',
  CSV: 'CSV',
  EXCEL: 'EXCEL',
  HTML: 'HTML'
};

export type ReportFormat = (typeof ReportFormat)[keyof typeof ReportFormat]


export const CourierAvailabilityStatus: {
  AVAILABLE: 'AVAILABLE',
  BUSY: 'BUSY',
  OFFLINE: 'OFFLINE',
  ON_BREAK: 'ON_BREAK'
};

export type CourierAvailabilityStatus = (typeof CourierAvailabilityStatus)[keyof typeof CourierAvailabilityStatus]


export const DeliveryPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type DeliveryPriority = (typeof DeliveryPriority)[keyof typeof DeliveryPriority]


export const PaymentMethod: {
  CREDIT_CARD: 'CREDIT_CARD',
  CASH: 'CASH',
  TRANSFER: 'TRANSFER',
  MOBILE_PAYMENT: 'MOBILE_PAYMENT'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const Platform: {
  WEB: 'WEB',
  YEMEKSEPETI: 'YEMEKSEPETI',
  GETIR: 'GETIR',
  TRENDYOL: 'TRENDYOL'
};

export type Platform = (typeof Platform)[keyof typeof Platform]


export const RefundRequestStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  PARTIAL_APPROVED: 'PARTIAL_APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type RefundRequestStatus = (typeof RefundRequestStatus)[keyof typeof RefundRequestStatus]


export const CancellationRequestStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  AUTO_APPROVED: 'AUTO_APPROVED'
};

export type CancellationRequestStatus = (typeof CancellationRequestStatus)[keyof typeof CancellationRequestStatus]


export const RefundReason: {
  DAMAGED_PRODUCT: 'DAMAGED_PRODUCT',
  WRONG_PRODUCT: 'WRONG_PRODUCT',
  PRODUCT_NOT_AS_DESCRIBED: 'PRODUCT_NOT_AS_DESCRIBED',
  MISSING_ITEMS: 'MISSING_ITEMS',
  LATE_DELIVERY: 'LATE_DELIVERY',
  QUALITY_ISSUES: 'QUALITY_ISSUES',
  OTHER: 'OTHER'
};

export type RefundReason = (typeof RefundReason)[keyof typeof RefundReason]


export const CancellationReason: {
  CUSTOMER_CHANGED_MIND: 'CUSTOMER_CHANGED_MIND',
  DUPLICATE_ORDER: 'DUPLICATE_ORDER',
  DELIVERY_TOO_LONG: 'DELIVERY_TOO_LONG',
  PRICE_ISSUES: 'PRICE_ISSUES',
  RESTAURANT_CLOSED: 'RESTAURANT_CLOSED',
  OUT_OF_STOCK: 'OUT_OF_STOCK',
  OTHER: 'OTHER'
};

export type CancellationReason = (typeof CancellationReason)[keyof typeof CancellationReason]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  PAST_DUE: 'PAST_DUE',
  CANCELED: 'CANCELED',
  PAUSED: 'PAUSED',
  TRIAL: 'TRIAL',
  EXPIRED: 'EXPIRED',
  PENDING: 'PENDING'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const SubscriptionInterval: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  QUARTERLY: 'QUARTERLY',
  YEARLY: 'YEARLY'
};

export type SubscriptionInterval = (typeof SubscriptionInterval)[keyof typeof SubscriptionInterval]


export const CardBrand: {
  VISA: 'VISA',
  MASTERCARD: 'MASTERCARD',
  AMEX: 'AMEX',
  DISCOVER: 'DISCOVER',
  TROY: 'TROY',
  OTHER: 'OTHER'
};

export type CardBrand = (typeof CardBrand)[keyof typeof CardBrand]


export const PaymentProvider: {
  STRIPE: 'STRIPE',
  IYZICO: 'IYZICO',
  PAYPAL: 'PAYPAL',
  MANUAL: 'MANUAL'
};

export type PaymentProvider = (typeof PaymentProvider)[keyof typeof PaymentProvider]

}

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationChannel = $Enums.NotificationChannel

export const NotificationChannel: typeof $Enums.NotificationChannel

export type NotificationFrequency = $Enums.NotificationFrequency

export const NotificationFrequency: typeof $Enums.NotificationFrequency

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type ReportType = $Enums.ReportType

export const ReportType: typeof $Enums.ReportType

export type ReportFormat = $Enums.ReportFormat

export const ReportFormat: typeof $Enums.ReportFormat

export type CourierAvailabilityStatus = $Enums.CourierAvailabilityStatus

export const CourierAvailabilityStatus: typeof $Enums.CourierAvailabilityStatus

export type DeliveryPriority = $Enums.DeliveryPriority

export const DeliveryPriority: typeof $Enums.DeliveryPriority

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type Platform = $Enums.Platform

export const Platform: typeof $Enums.Platform

export type RefundRequestStatus = $Enums.RefundRequestStatus

export const RefundRequestStatus: typeof $Enums.RefundRequestStatus

export type CancellationRequestStatus = $Enums.CancellationRequestStatus

export const CancellationRequestStatus: typeof $Enums.CancellationRequestStatus

export type RefundReason = $Enums.RefundReason

export const RefundReason: typeof $Enums.RefundReason

export type CancellationReason = $Enums.CancellationReason

export const CancellationReason: typeof $Enums.CancellationReason

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type SubscriptionInterval = $Enums.SubscriptionInterval

export const SubscriptionInterval: typeof $Enums.SubscriptionInterval

export type CardBrand = $Enums.CardBrand

export const CardBrand: typeof $Enums.CardBrand

export type PaymentProvider = $Enums.PaymentProvider

export const PaymentProvider: typeof $Enums.PaymentProvider

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courier`: Exposes CRUD operations for the **Courier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Couriers
    * const couriers = await prisma.courier.findMany()
    * ```
    */
  get courier(): Prisma.CourierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.business`: Exposes CRUD operations for the **Business** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Businesses
    * const businesses = await prisma.business.findMany()
    * ```
    */
  get business(): Prisma.BusinessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **Zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.ZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.delivery`: Exposes CRUD operations for the **Delivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliveries
    * const deliveries = await prisma.delivery.findMany()
    * ```
    */
  get delivery(): Prisma.DeliveryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryLog`: Exposes CRUD operations for the **DeliveryLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryLogs
    * const deliveryLogs = await prisma.deliveryLog.findMany()
    * ```
    */
  get deliveryLog(): Prisma.DeliveryLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduledReport`: Exposes CRUD operations for the **ScheduledReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledReports
    * const scheduledReports = await prisma.scheduledReport.findMany()
    * ```
    */
  get scheduledReport(): Prisma.ScheduledReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menuItem`: Exposes CRUD operations for the **MenuItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuItems
    * const menuItems = await prisma.menuItem.findMany()
    * ```
    */
  get menuItem(): Prisma.MenuItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courierAvailability`: Exposes CRUD operations for the **CourierAvailability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourierAvailabilities
    * const courierAvailabilities = await prisma.courierAvailability.findMany()
    * ```
    */
  get courierAvailability(): Prisma.CourierAvailabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryTimeWindow`: Exposes CRUD operations for the **DeliveryTimeWindow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryTimeWindows
    * const deliveryTimeWindows = await prisma.deliveryTimeWindow.findMany()
    * ```
    */
  get deliveryTimeWindow(): Prisma.DeliveryTimeWindowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryRoute`: Exposes CRUD operations for the **DeliveryRoute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryRoutes
    * const deliveryRoutes = await prisma.deliveryRoute.findMany()
    * ```
    */
  get deliveryRoute(): Prisma.DeliveryRouteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemAction`: Exposes CRUD operations for the **SystemAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemActions
    * const systemActions = await prisma.systemAction.findMany()
    * ```
    */
  get systemAction(): Prisma.SystemActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSettings`: Exposes CRUD operations for the **SystemSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSettings.findMany()
    * ```
    */
  get systemSettings(): Prisma.SystemSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminDashboardWidget`: Exposes CRUD operations for the **AdminDashboardWidget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminDashboardWidgets
    * const adminDashboardWidgets = await prisma.adminDashboardWidget.findMany()
    * ```
    */
  get adminDashboardWidget(): Prisma.AdminDashboardWidgetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminPermission`: Exposes CRUD operations for the **AdminPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminPermissions
    * const adminPermissions = await prisma.adminPermission.findMany()
    * ```
    */
  get adminPermission(): Prisma.AdminPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminRole`: Exposes CRUD operations for the **AdminRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminRoles
    * const adminRoles = await prisma.adminRole.findMany()
    * ```
    */
  get adminRole(): Prisma.AdminRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminRoleMapping`: Exposes CRUD operations for the **AdminRoleMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminRoleMappings
    * const adminRoleMappings = await prisma.adminRoleMapping.findMany()
    * ```
    */
  get adminRoleMapping(): Prisma.AdminRoleMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sentEmail`: Exposes CRUD operations for the **SentEmail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SentEmails
    * const sentEmails = await prisma.sentEmail.findMany()
    * ```
    */
  get sentEmail(): Prisma.SentEmailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerAddress`: Exposes CRUD operations for the **CustomerAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerAddresses
    * const customerAddresses = await prisma.customerAddress.findMany()
    * ```
    */
  get customerAddress(): Prisma.CustomerAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refundRequest`: Exposes CRUD operations for the **RefundRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefundRequests
    * const refundRequests = await prisma.refundRequest.findMany()
    * ```
    */
  get refundRequest(): Prisma.RefundRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cancellationRequest`: Exposes CRUD operations for the **CancellationRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CancellationRequests
    * const cancellationRequests = await prisma.cancellationRequest.findMany()
    * ```
    */
  get cancellationRequest(): Prisma.CancellationRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refundPolicy`: Exposes CRUD operations for the **RefundPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefundPolicies
    * const refundPolicies = await prisma.refundPolicy.findMany()
    * ```
    */
  get refundPolicy(): Prisma.RefundPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.savedPaymentMethod`: Exposes CRUD operations for the **SavedPaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedPaymentMethods
    * const savedPaymentMethods = await prisma.savedPaymentMethod.findMany()
    * ```
    */
  get savedPaymentMethod(): Prisma.SavedPaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionPlan`: Exposes CRUD operations for the **SubscriptionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPlans
    * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
    * ```
    */
  get subscriptionPlan(): Prisma.SubscriptionPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurringPayment`: Exposes CRUD operations for the **RecurringPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringPayments
    * const recurringPayments = await prisma.recurringPayment.findMany()
    * ```
    */
  get recurringPayment(): Prisma.RecurringPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dashboardMetric`: Exposes CRUD operations for the **DashboardMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardMetrics
    * const dashboardMetrics = await prisma.dashboardMetric.findMany()
    * ```
    */
  get dashboardMetric(): Prisma.DashboardMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailSettings`: Exposes CRUD operations for the **EmailSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailSettings
    * const emailSettings = await prisma.emailSettings.findMany()
    * ```
    */
  get emailSettings(): Prisma.EmailSettingsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Admin: 'Admin',
    Courier: 'Courier',
    Order: 'Order',
    Customer: 'Customer',
    Business: 'Business',
    Zone: 'Zone',
    NotificationPreference: 'NotificationPreference',
    Notification: 'Notification',
    Delivery: 'Delivery',
    Inventory: 'Inventory',
    DeliveryLog: 'DeliveryLog',
    Report: 'Report',
    Schedule: 'Schedule',
    ScheduledReport: 'ScheduledReport',
    UserSettings: 'UserSettings',
    MenuItem: 'MenuItem',
    CourierAvailability: 'CourierAvailability',
    DeliveryTimeWindow: 'DeliveryTimeWindow',
    DeliveryRoute: 'DeliveryRoute',
    Payment: 'Payment',
    ProductCategory: 'ProductCategory',
    ActivityLog: 'ActivityLog',
    SystemAction: 'SystemAction',
    SystemSettings: 'SystemSettings',
    AdminDashboardWidget: 'AdminDashboardWidget',
    AdminPermission: 'AdminPermission',
    AdminRole: 'AdminRole',
    AdminRoleMapping: 'AdminRoleMapping',
    EmailTemplate: 'EmailTemplate',
    SentEmail: 'SentEmail',
    CustomerAddress: 'CustomerAddress',
    RefundRequest: 'RefundRequest',
    CancellationRequest: 'CancellationRequest',
    RefundPolicy: 'RefundPolicy',
    SavedPaymentMethod: 'SavedPaymentMethod',
    SubscriptionPlan: 'SubscriptionPlan',
    Subscription: 'Subscription',
    RecurringPayment: 'RecurringPayment',
    DashboardMetric: 'DashboardMetric',
    EmailSettings: 'EmailSettings'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "admin" | "courier" | "order" | "customer" | "business" | "zone" | "notificationPreference" | "notification" | "delivery" | "inventory" | "deliveryLog" | "report" | "schedule" | "scheduledReport" | "userSettings" | "menuItem" | "courierAvailability" | "deliveryTimeWindow" | "deliveryRoute" | "payment" | "productCategory" | "activityLog" | "systemAction" | "systemSettings" | "adminDashboardWidget" | "adminPermission" | "adminRole" | "adminRoleMapping" | "emailTemplate" | "sentEmail" | "customerAddress" | "refundRequest" | "cancellationRequest" | "refundPolicy" | "savedPaymentMethod" | "subscriptionPlan" | "subscription" | "recurringPayment" | "dashboardMetric" | "emailSettings"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Courier: {
        payload: Prisma.$CourierPayload<ExtArgs>
        fields: Prisma.CourierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          findFirst: {
            args: Prisma.CourierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          findMany: {
            args: Prisma.CourierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>[]
          }
          create: {
            args: Prisma.CourierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          createMany: {
            args: Prisma.CourierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>[]
          }
          delete: {
            args: Prisma.CourierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          update: {
            args: Prisma.CourierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          deleteMany: {
            args: Prisma.CourierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>[]
          }
          upsert: {
            args: Prisma.CourierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          aggregate: {
            args: Prisma.CourierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourier>
          }
          groupBy: {
            args: Prisma.CourierGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourierGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourierCountArgs<ExtArgs>
            result: $Utils.Optional<CourierCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Business: {
        payload: Prisma.$BusinessPayload<ExtArgs>
        fields: Prisma.BusinessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findFirst: {
            args: Prisma.BusinessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findMany: {
            args: Prisma.BusinessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          create: {
            args: Prisma.BusinessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          createMany: {
            args: Prisma.BusinessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          delete: {
            args: Prisma.BusinessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          update: {
            args: Prisma.BusinessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          deleteMany: {
            args: Prisma.BusinessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          upsert: {
            args: Prisma.BusinessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          aggregate: {
            args: Prisma.BusinessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusiness>
          }
          groupBy: {
            args: Prisma.BusinessGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessCountAggregateOutputType> | number
          }
        }
      }
      Zone: {
        payload: Prisma.$ZonePayload<ExtArgs>
        fields: Prisma.ZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findFirst: {
            args: Prisma.ZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findMany: {
            args: Prisma.ZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          create: {
            args: Prisma.ZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          createMany: {
            args: Prisma.ZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          delete: {
            args: Prisma.ZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          update: {
            args: Prisma.ZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          deleteMany: {
            args: Prisma.ZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          upsert: {
            args: Prisma.ZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.ZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Delivery: {
        payload: Prisma.$DeliveryPayload<ExtArgs>
        fields: Prisma.DeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          findFirst: {
            args: Prisma.DeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          findMany: {
            args: Prisma.DeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          create: {
            args: Prisma.DeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          createMany: {
            args: Prisma.DeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          delete: {
            args: Prisma.DeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          update: {
            args: Prisma.DeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          aggregate: {
            args: Prisma.DeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelivery>
          }
          groupBy: {
            args: Prisma.DeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      DeliveryLog: {
        payload: Prisma.$DeliveryLogPayload<ExtArgs>
        fields: Prisma.DeliveryLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>
          }
          findFirst: {
            args: Prisma.DeliveryLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>
          }
          findMany: {
            args: Prisma.DeliveryLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>[]
          }
          create: {
            args: Prisma.DeliveryLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>
          }
          createMany: {
            args: Prisma.DeliveryLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>[]
          }
          delete: {
            args: Prisma.DeliveryLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>
          }
          update: {
            args: Prisma.DeliveryLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>
          }
          aggregate: {
            args: Prisma.DeliveryLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryLog>
          }
          groupBy: {
            args: Prisma.DeliveryLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryLogCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryLogCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      ScheduledReport: {
        payload: Prisma.$ScheduledReportPayload<ExtArgs>
        fields: Prisma.ScheduledReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          findFirst: {
            args: Prisma.ScheduledReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          findMany: {
            args: Prisma.ScheduledReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>[]
          }
          create: {
            args: Prisma.ScheduledReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          createMany: {
            args: Prisma.ScheduledReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduledReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>[]
          }
          delete: {
            args: Prisma.ScheduledReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          update: {
            args: Prisma.ScheduledReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduledReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>[]
          }
          upsert: {
            args: Prisma.ScheduledReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          aggregate: {
            args: Prisma.ScheduledReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledReport>
          }
          groupBy: {
            args: Prisma.ScheduledReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledReportCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledReportCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      MenuItem: {
        payload: Prisma.$MenuItemPayload<ExtArgs>
        fields: Prisma.MenuItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          findFirst: {
            args: Prisma.MenuItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          findMany: {
            args: Prisma.MenuItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          create: {
            args: Prisma.MenuItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          createMany: {
            args: Prisma.MenuItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          delete: {
            args: Prisma.MenuItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          update: {
            args: Prisma.MenuItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          deleteMany: {
            args: Prisma.MenuItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenuItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          upsert: {
            args: Prisma.MenuItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          aggregate: {
            args: Prisma.MenuItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenuItem>
          }
          groupBy: {
            args: Prisma.MenuItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuItemCountArgs<ExtArgs>
            result: $Utils.Optional<MenuItemCountAggregateOutputType> | number
          }
        }
      }
      CourierAvailability: {
        payload: Prisma.$CourierAvailabilityPayload<ExtArgs>
        fields: Prisma.CourierAvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourierAvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierAvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourierAvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierAvailabilityPayload>
          }
          findFirst: {
            args: Prisma.CourierAvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierAvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourierAvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierAvailabilityPayload>
          }
          findMany: {
            args: Prisma.CourierAvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierAvailabilityPayload>[]
          }
          create: {
            args: Prisma.CourierAvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierAvailabilityPayload>
          }
          createMany: {
            args: Prisma.CourierAvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourierAvailabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierAvailabilityPayload>[]
          }
          delete: {
            args: Prisma.CourierAvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierAvailabilityPayload>
          }
          update: {
            args: Prisma.CourierAvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierAvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.CourierAvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourierAvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourierAvailabilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierAvailabilityPayload>[]
          }
          upsert: {
            args: Prisma.CourierAvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierAvailabilityPayload>
          }
          aggregate: {
            args: Prisma.CourierAvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourierAvailability>
          }
          groupBy: {
            args: Prisma.CourierAvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourierAvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourierAvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<CourierAvailabilityCountAggregateOutputType> | number
          }
        }
      }
      DeliveryTimeWindow: {
        payload: Prisma.$DeliveryTimeWindowPayload<ExtArgs>
        fields: Prisma.DeliveryTimeWindowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryTimeWindowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTimeWindowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryTimeWindowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTimeWindowPayload>
          }
          findFirst: {
            args: Prisma.DeliveryTimeWindowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTimeWindowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryTimeWindowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTimeWindowPayload>
          }
          findMany: {
            args: Prisma.DeliveryTimeWindowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTimeWindowPayload>[]
          }
          create: {
            args: Prisma.DeliveryTimeWindowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTimeWindowPayload>
          }
          createMany: {
            args: Prisma.DeliveryTimeWindowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryTimeWindowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTimeWindowPayload>[]
          }
          delete: {
            args: Prisma.DeliveryTimeWindowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTimeWindowPayload>
          }
          update: {
            args: Prisma.DeliveryTimeWindowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTimeWindowPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryTimeWindowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryTimeWindowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryTimeWindowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTimeWindowPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryTimeWindowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTimeWindowPayload>
          }
          aggregate: {
            args: Prisma.DeliveryTimeWindowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryTimeWindow>
          }
          groupBy: {
            args: Prisma.DeliveryTimeWindowGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryTimeWindowGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryTimeWindowCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryTimeWindowCountAggregateOutputType> | number
          }
        }
      }
      DeliveryRoute: {
        payload: Prisma.$DeliveryRoutePayload<ExtArgs>
        fields: Prisma.DeliveryRouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryRouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryRoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryRouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryRoutePayload>
          }
          findFirst: {
            args: Prisma.DeliveryRouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryRoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryRouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryRoutePayload>
          }
          findMany: {
            args: Prisma.DeliveryRouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryRoutePayload>[]
          }
          create: {
            args: Prisma.DeliveryRouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryRoutePayload>
          }
          createMany: {
            args: Prisma.DeliveryRouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryRouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryRoutePayload>[]
          }
          delete: {
            args: Prisma.DeliveryRouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryRoutePayload>
          }
          update: {
            args: Prisma.DeliveryRouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryRoutePayload>
          }
          deleteMany: {
            args: Prisma.DeliveryRouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryRouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryRouteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryRoutePayload>[]
          }
          upsert: {
            args: Prisma.DeliveryRouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryRoutePayload>
          }
          aggregate: {
            args: Prisma.DeliveryRouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryRoute>
          }
          groupBy: {
            args: Prisma.DeliveryRouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryRouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryRouteCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryRouteCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      SystemAction: {
        payload: Prisma.$SystemActionPayload<ExtArgs>
        fields: Prisma.SystemActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemActionPayload>
          }
          findFirst: {
            args: Prisma.SystemActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemActionPayload>
          }
          findMany: {
            args: Prisma.SystemActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemActionPayload>[]
          }
          create: {
            args: Prisma.SystemActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemActionPayload>
          }
          createMany: {
            args: Prisma.SystemActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemActionPayload>[]
          }
          delete: {
            args: Prisma.SystemActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemActionPayload>
          }
          update: {
            args: Prisma.SystemActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemActionPayload>
          }
          deleteMany: {
            args: Prisma.SystemActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemActionPayload>[]
          }
          upsert: {
            args: Prisma.SystemActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemActionPayload>
          }
          aggregate: {
            args: Prisma.SystemActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemAction>
          }
          groupBy: {
            args: Prisma.SystemActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemActionCountArgs<ExtArgs>
            result: $Utils.Optional<SystemActionCountAggregateOutputType> | number
          }
        }
      }
      SystemSettings: {
        payload: Prisma.$SystemSettingsPayload<ExtArgs>
        fields: Prisma.SystemSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findMany: {
            args: Prisma.SystemSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          create: {
            args: Prisma.SystemSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          createMany: {
            args: Prisma.SystemSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          update: {
            args: Prisma.SystemSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSettings>
          }
          groupBy: {
            args: Prisma.SystemSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsCountAggregateOutputType> | number
          }
        }
      }
      AdminDashboardWidget: {
        payload: Prisma.$AdminDashboardWidgetPayload<ExtArgs>
        fields: Prisma.AdminDashboardWidgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminDashboardWidgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminDashboardWidgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminDashboardWidgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminDashboardWidgetPayload>
          }
          findFirst: {
            args: Prisma.AdminDashboardWidgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminDashboardWidgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminDashboardWidgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminDashboardWidgetPayload>
          }
          findMany: {
            args: Prisma.AdminDashboardWidgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminDashboardWidgetPayload>[]
          }
          create: {
            args: Prisma.AdminDashboardWidgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminDashboardWidgetPayload>
          }
          createMany: {
            args: Prisma.AdminDashboardWidgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminDashboardWidgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminDashboardWidgetPayload>[]
          }
          delete: {
            args: Prisma.AdminDashboardWidgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminDashboardWidgetPayload>
          }
          update: {
            args: Prisma.AdminDashboardWidgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminDashboardWidgetPayload>
          }
          deleteMany: {
            args: Prisma.AdminDashboardWidgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminDashboardWidgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminDashboardWidgetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminDashboardWidgetPayload>[]
          }
          upsert: {
            args: Prisma.AdminDashboardWidgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminDashboardWidgetPayload>
          }
          aggregate: {
            args: Prisma.AdminDashboardWidgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminDashboardWidget>
          }
          groupBy: {
            args: Prisma.AdminDashboardWidgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminDashboardWidgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminDashboardWidgetCountArgs<ExtArgs>
            result: $Utils.Optional<AdminDashboardWidgetCountAggregateOutputType> | number
          }
        }
      }
      AdminPermission: {
        payload: Prisma.$AdminPermissionPayload<ExtArgs>
        fields: Prisma.AdminPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          findFirst: {
            args: Prisma.AdminPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          findMany: {
            args: Prisma.AdminPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>[]
          }
          create: {
            args: Prisma.AdminPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          createMany: {
            args: Prisma.AdminPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>[]
          }
          delete: {
            args: Prisma.AdminPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          update: {
            args: Prisma.AdminPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          deleteMany: {
            args: Prisma.AdminPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>[]
          }
          upsert: {
            args: Prisma.AdminPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPermissionPayload>
          }
          aggregate: {
            args: Prisma.AdminPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminPermission>
          }
          groupBy: {
            args: Prisma.AdminPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<AdminPermissionCountAggregateOutputType> | number
          }
        }
      }
      AdminRole: {
        payload: Prisma.$AdminRolePayload<ExtArgs>
        fields: Prisma.AdminRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>
          }
          findFirst: {
            args: Prisma.AdminRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>
          }
          findMany: {
            args: Prisma.AdminRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>[]
          }
          create: {
            args: Prisma.AdminRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>
          }
          createMany: {
            args: Prisma.AdminRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>[]
          }
          delete: {
            args: Prisma.AdminRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>
          }
          update: {
            args: Prisma.AdminRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>
          }
          deleteMany: {
            args: Prisma.AdminRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>[]
          }
          upsert: {
            args: Prisma.AdminRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>
          }
          aggregate: {
            args: Prisma.AdminRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminRole>
          }
          groupBy: {
            args: Prisma.AdminRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminRoleCountArgs<ExtArgs>
            result: $Utils.Optional<AdminRoleCountAggregateOutputType> | number
          }
        }
      }
      AdminRoleMapping: {
        payload: Prisma.$AdminRoleMappingPayload<ExtArgs>
        fields: Prisma.AdminRoleMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminRoleMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRoleMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminRoleMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRoleMappingPayload>
          }
          findFirst: {
            args: Prisma.AdminRoleMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRoleMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminRoleMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRoleMappingPayload>
          }
          findMany: {
            args: Prisma.AdminRoleMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRoleMappingPayload>[]
          }
          create: {
            args: Prisma.AdminRoleMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRoleMappingPayload>
          }
          createMany: {
            args: Prisma.AdminRoleMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminRoleMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRoleMappingPayload>[]
          }
          delete: {
            args: Prisma.AdminRoleMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRoleMappingPayload>
          }
          update: {
            args: Prisma.AdminRoleMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRoleMappingPayload>
          }
          deleteMany: {
            args: Prisma.AdminRoleMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminRoleMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminRoleMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRoleMappingPayload>[]
          }
          upsert: {
            args: Prisma.AdminRoleMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRoleMappingPayload>
          }
          aggregate: {
            args: Prisma.AdminRoleMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminRoleMapping>
          }
          groupBy: {
            args: Prisma.AdminRoleMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminRoleMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminRoleMappingCountArgs<ExtArgs>
            result: $Utils.Optional<AdminRoleMappingCountAggregateOutputType> | number
          }
        }
      }
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
      SentEmail: {
        payload: Prisma.$SentEmailPayload<ExtArgs>
        fields: Prisma.SentEmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SentEmailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SentEmailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>
          }
          findFirst: {
            args: Prisma.SentEmailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SentEmailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>
          }
          findMany: {
            args: Prisma.SentEmailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>[]
          }
          create: {
            args: Prisma.SentEmailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>
          }
          createMany: {
            args: Prisma.SentEmailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SentEmailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>[]
          }
          delete: {
            args: Prisma.SentEmailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>
          }
          update: {
            args: Prisma.SentEmailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>
          }
          deleteMany: {
            args: Prisma.SentEmailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SentEmailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SentEmailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>[]
          }
          upsert: {
            args: Prisma.SentEmailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SentEmailPayload>
          }
          aggregate: {
            args: Prisma.SentEmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSentEmail>
          }
          groupBy: {
            args: Prisma.SentEmailGroupByArgs<ExtArgs>
            result: $Utils.Optional<SentEmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.SentEmailCountArgs<ExtArgs>
            result: $Utils.Optional<SentEmailCountAggregateOutputType> | number
          }
        }
      }
      CustomerAddress: {
        payload: Prisma.$CustomerAddressPayload<ExtArgs>
        fields: Prisma.CustomerAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          findFirst: {
            args: Prisma.CustomerAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          findMany: {
            args: Prisma.CustomerAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          create: {
            args: Prisma.CustomerAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          createMany: {
            args: Prisma.CustomerAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          delete: {
            args: Prisma.CustomerAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          update: {
            args: Prisma.CustomerAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          deleteMany: {
            args: Prisma.CustomerAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          upsert: {
            args: Prisma.CustomerAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          aggregate: {
            args: Prisma.CustomerAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerAddress>
          }
          groupBy: {
            args: Prisma.CustomerAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerAddressCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerAddressCountAggregateOutputType> | number
          }
        }
      }
      RefundRequest: {
        payload: Prisma.$RefundRequestPayload<ExtArgs>
        fields: Prisma.RefundRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefundRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefundRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>
          }
          findFirst: {
            args: Prisma.RefundRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefundRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>
          }
          findMany: {
            args: Prisma.RefundRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>[]
          }
          create: {
            args: Prisma.RefundRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>
          }
          createMany: {
            args: Prisma.RefundRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefundRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>[]
          }
          delete: {
            args: Prisma.RefundRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>
          }
          update: {
            args: Prisma.RefundRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>
          }
          deleteMany: {
            args: Prisma.RefundRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefundRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefundRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>[]
          }
          upsert: {
            args: Prisma.RefundRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>
          }
          aggregate: {
            args: Prisma.RefundRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefundRequest>
          }
          groupBy: {
            args: Prisma.RefundRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefundRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefundRequestCountArgs<ExtArgs>
            result: $Utils.Optional<RefundRequestCountAggregateOutputType> | number
          }
        }
      }
      CancellationRequest: {
        payload: Prisma.$CancellationRequestPayload<ExtArgs>
        fields: Prisma.CancellationRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CancellationRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CancellationRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationRequestPayload>
          }
          findFirst: {
            args: Prisma.CancellationRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CancellationRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationRequestPayload>
          }
          findMany: {
            args: Prisma.CancellationRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationRequestPayload>[]
          }
          create: {
            args: Prisma.CancellationRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationRequestPayload>
          }
          createMany: {
            args: Prisma.CancellationRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CancellationRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationRequestPayload>[]
          }
          delete: {
            args: Prisma.CancellationRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationRequestPayload>
          }
          update: {
            args: Prisma.CancellationRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationRequestPayload>
          }
          deleteMany: {
            args: Prisma.CancellationRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CancellationRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CancellationRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationRequestPayload>[]
          }
          upsert: {
            args: Prisma.CancellationRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationRequestPayload>
          }
          aggregate: {
            args: Prisma.CancellationRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCancellationRequest>
          }
          groupBy: {
            args: Prisma.CancellationRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CancellationRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CancellationRequestCountArgs<ExtArgs>
            result: $Utils.Optional<CancellationRequestCountAggregateOutputType> | number
          }
        }
      }
      RefundPolicy: {
        payload: Prisma.$RefundPolicyPayload<ExtArgs>
        fields: Prisma.RefundPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefundPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefundPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPolicyPayload>
          }
          findFirst: {
            args: Prisma.RefundPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefundPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPolicyPayload>
          }
          findMany: {
            args: Prisma.RefundPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPolicyPayload>[]
          }
          create: {
            args: Prisma.RefundPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPolicyPayload>
          }
          createMany: {
            args: Prisma.RefundPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefundPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPolicyPayload>[]
          }
          delete: {
            args: Prisma.RefundPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPolicyPayload>
          }
          update: {
            args: Prisma.RefundPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPolicyPayload>
          }
          deleteMany: {
            args: Prisma.RefundPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefundPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefundPolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPolicyPayload>[]
          }
          upsert: {
            args: Prisma.RefundPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPolicyPayload>
          }
          aggregate: {
            args: Prisma.RefundPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefundPolicy>
          }
          groupBy: {
            args: Prisma.RefundPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefundPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefundPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<RefundPolicyCountAggregateOutputType> | number
          }
        }
      }
      SavedPaymentMethod: {
        payload: Prisma.$SavedPaymentMethodPayload<ExtArgs>
        fields: Prisma.SavedPaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedPaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedPaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.SavedPaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedPaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPaymentMethodPayload>
          }
          findMany: {
            args: Prisma.SavedPaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPaymentMethodPayload>[]
          }
          create: {
            args: Prisma.SavedPaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPaymentMethodPayload>
          }
          createMany: {
            args: Prisma.SavedPaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedPaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.SavedPaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPaymentMethodPayload>
          }
          update: {
            args: Prisma.SavedPaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.SavedPaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedPaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SavedPaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.SavedPaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.SavedPaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedPaymentMethod>
          }
          groupBy: {
            args: Prisma.SavedPaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedPaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedPaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<SavedPaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPlan: {
        payload: Prisma.$SubscriptionPlanPayload<ExtArgs>
        fields: Prisma.SubscriptionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          update: {
            args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPlan>
          }
          groupBy: {
            args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      RecurringPayment: {
        payload: Prisma.$RecurringPaymentPayload<ExtArgs>
        fields: Prisma.RecurringPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPaymentPayload>
          }
          findFirst: {
            args: Prisma.RecurringPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPaymentPayload>
          }
          findMany: {
            args: Prisma.RecurringPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPaymentPayload>[]
          }
          create: {
            args: Prisma.RecurringPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPaymentPayload>
          }
          createMany: {
            args: Prisma.RecurringPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecurringPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPaymentPayload>[]
          }
          delete: {
            args: Prisma.RecurringPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPaymentPayload>
          }
          update: {
            args: Prisma.RecurringPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPaymentPayload>
          }
          deleteMany: {
            args: Prisma.RecurringPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecurringPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPaymentPayload>[]
          }
          upsert: {
            args: Prisma.RecurringPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPaymentPayload>
          }
          aggregate: {
            args: Prisma.RecurringPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringPayment>
          }
          groupBy: {
            args: Prisma.RecurringPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecurringPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringPaymentCountAggregateOutputType> | number
          }
        }
      }
      DashboardMetric: {
        payload: Prisma.$DashboardMetricPayload<ExtArgs>
        fields: Prisma.DashboardMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricPayload>
          }
          findFirst: {
            args: Prisma.DashboardMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricPayload>
          }
          findMany: {
            args: Prisma.DashboardMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricPayload>[]
          }
          create: {
            args: Prisma.DashboardMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricPayload>
          }
          createMany: {
            args: Prisma.DashboardMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricPayload>[]
          }
          delete: {
            args: Prisma.DashboardMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricPayload>
          }
          update: {
            args: Prisma.DashboardMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricPayload>
          }
          deleteMany: {
            args: Prisma.DashboardMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DashboardMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricPayload>[]
          }
          upsert: {
            args: Prisma.DashboardMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricPayload>
          }
          aggregate: {
            args: Prisma.DashboardMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboardMetric>
          }
          groupBy: {
            args: Prisma.DashboardMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardMetricCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardMetricCountAggregateOutputType> | number
          }
        }
      }
      EmailSettings: {
        payload: Prisma.$EmailSettingsPayload<ExtArgs>
        fields: Prisma.EmailSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingsPayload>
          }
          findFirst: {
            args: Prisma.EmailSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingsPayload>
          }
          findMany: {
            args: Prisma.EmailSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingsPayload>[]
          }
          create: {
            args: Prisma.EmailSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingsPayload>
          }
          createMany: {
            args: Prisma.EmailSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingsPayload>[]
          }
          delete: {
            args: Prisma.EmailSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingsPayload>
          }
          update: {
            args: Prisma.EmailSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingsPayload>
          }
          deleteMany: {
            args: Prisma.EmailSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingsPayload>[]
          }
          upsert: {
            args: Prisma.EmailSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailSettingsPayload>
          }
          aggregate: {
            args: Prisma.EmailSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailSettings>
          }
          groupBy: {
            args: Prisma.EmailSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<EmailSettingsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    admin?: AdminOmit
    courier?: CourierOmit
    order?: OrderOmit
    customer?: CustomerOmit
    business?: BusinessOmit
    zone?: ZoneOmit
    notificationPreference?: NotificationPreferenceOmit
    notification?: NotificationOmit
    delivery?: DeliveryOmit
    inventory?: InventoryOmit
    deliveryLog?: DeliveryLogOmit
    report?: ReportOmit
    schedule?: ScheduleOmit
    scheduledReport?: ScheduledReportOmit
    userSettings?: UserSettingsOmit
    menuItem?: MenuItemOmit
    courierAvailability?: CourierAvailabilityOmit
    deliveryTimeWindow?: DeliveryTimeWindowOmit
    deliveryRoute?: DeliveryRouteOmit
    payment?: PaymentOmit
    productCategory?: ProductCategoryOmit
    activityLog?: ActivityLogOmit
    systemAction?: SystemActionOmit
    systemSettings?: SystemSettingsOmit
    adminDashboardWidget?: AdminDashboardWidgetOmit
    adminPermission?: AdminPermissionOmit
    adminRole?: AdminRoleOmit
    adminRoleMapping?: AdminRoleMappingOmit
    emailTemplate?: EmailTemplateOmit
    sentEmail?: SentEmailOmit
    customerAddress?: CustomerAddressOmit
    refundRequest?: RefundRequestOmit
    cancellationRequest?: CancellationRequestOmit
    refundPolicy?: RefundPolicyOmit
    savedPaymentMethod?: SavedPaymentMethodOmit
    subscriptionPlan?: SubscriptionPlanOmit
    subscription?: SubscriptionOmit
    recurringPayment?: RecurringPaymentOmit
    dashboardMetric?: DashboardMetricOmit
    emailSettings?: EmailSettingsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notifications: number
    notificationPreferences: number
    reports: number
    scheduledReports: number
    activityLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    notificationPreferences?: boolean | UserCountOutputTypeCountNotificationPreferencesArgs
    reports?: boolean | UserCountOutputTypeCountReportsArgs
    scheduledReports?: boolean | UserCountOutputTypeCountScheduledReportsArgs
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScheduledReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    activityLogs: number
    systemActions: number
    dashboardWidgets: number
    roleMappings: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityLogs?: boolean | AdminCountOutputTypeCountActivityLogsArgs
    systemActions?: boolean | AdminCountOutputTypeCountSystemActionsArgs
    dashboardWidgets?: boolean | AdminCountOutputTypeCountDashboardWidgetsArgs
    roleMappings?: boolean | AdminCountOutputTypeCountRoleMappingsArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountSystemActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemActionWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountDashboardWidgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminDashboardWidgetWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountRoleMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminRoleMappingWhereInput
  }


  /**
   * Count Type CourierCountOutputType
   */

  export type CourierCountOutputType = {
    orders: number
    notifications: number
    notificationPreferences: number
    deliveryLogs: number
    deliveries: number
    payments: number
    availability: number
    deliveryRoutes: number
  }

  export type CourierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CourierCountOutputTypeCountOrdersArgs
    notifications?: boolean | CourierCountOutputTypeCountNotificationsArgs
    notificationPreferences?: boolean | CourierCountOutputTypeCountNotificationPreferencesArgs
    deliveryLogs?: boolean | CourierCountOutputTypeCountDeliveryLogsArgs
    deliveries?: boolean | CourierCountOutputTypeCountDeliveriesArgs
    payments?: boolean | CourierCountOutputTypeCountPaymentsArgs
    availability?: boolean | CourierCountOutputTypeCountAvailabilityArgs
    deliveryRoutes?: boolean | CourierCountOutputTypeCountDeliveryRoutesArgs
  }

  // Custom InputTypes
  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierCountOutputType
     */
    select?: CourierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountNotificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
  }

  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountDeliveryLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryLogWhereInput
  }

  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }

  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourierAvailabilityWhereInput
  }

  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountDeliveryRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryRouteWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    notifications: number
    payments: number
    refundRequests: number
    cancellationRequests: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | OrderCountOutputTypeCountNotificationsArgs
    payments?: boolean | OrderCountOutputTypeCountPaymentsArgs
    refundRequests?: boolean | OrderCountOutputTypeCountRefundRequestsArgs
    cancellationRequests?: boolean | OrderCountOutputTypeCountCancellationRequestsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountRefundRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundRequestWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountCancellationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CancellationRequestWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    orders: number
    deliveries: number
    addresses: number
    refundRequests: number
    cancellationRequests: number
    savedPaymentMethods: number
    subscriptions: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    deliveries?: boolean | CustomerCountOutputTypeCountDeliveriesArgs
    addresses?: boolean | CustomerCountOutputTypeCountAddressesArgs
    refundRequests?: boolean | CustomerCountOutputTypeCountRefundRequestsArgs
    cancellationRequests?: boolean | CustomerCountOutputTypeCountCancellationRequestsArgs
    savedPaymentMethods?: boolean | CustomerCountOutputTypeCountSavedPaymentMethodsArgs
    subscriptions?: boolean | CustomerCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAddressWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountRefundRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundRequestWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCancellationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CancellationRequestWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSavedPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedPaymentMethodWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type BusinessCountOutputType
   */

  export type BusinessCountOutputType = {
    inventory: number
    orders: number
    menuItems: number
    productCategories: number
    payments: number
    refundPolicies: number
    refundRequests: number
    cancellationRequests: number
    subscriptionPlans: number
    subscriptions: number
  }

  export type BusinessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | BusinessCountOutputTypeCountInventoryArgs
    orders?: boolean | BusinessCountOutputTypeCountOrdersArgs
    menuItems?: boolean | BusinessCountOutputTypeCountMenuItemsArgs
    productCategories?: boolean | BusinessCountOutputTypeCountProductCategoriesArgs
    payments?: boolean | BusinessCountOutputTypeCountPaymentsArgs
    refundPolicies?: boolean | BusinessCountOutputTypeCountRefundPoliciesArgs
    refundRequests?: boolean | BusinessCountOutputTypeCountRefundRequestsArgs
    cancellationRequests?: boolean | BusinessCountOutputTypeCountCancellationRequestsArgs
    subscriptionPlans?: boolean | BusinessCountOutputTypeCountSubscriptionPlansArgs
    subscriptions?: boolean | BusinessCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCountOutputType
     */
    select?: BusinessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountMenuItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountProductCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountRefundPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundPolicyWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountRefundRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundRequestWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountCancellationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CancellationRequestWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountSubscriptionPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlanWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type ZoneCountOutputType
   */

  export type ZoneCountOutputType = {
    businesses: number
    couriers: number
    deliveries: number
  }

  export type ZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businesses?: boolean | ZoneCountOutputTypeCountBusinessesArgs
    couriers?: boolean | ZoneCountOutputTypeCountCouriersArgs
    deliveries?: boolean | ZoneCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneCountOutputType
     */
    select?: ZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountBusinessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountCouriersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourierWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }


  /**
   * Count Type ScheduleCountOutputType
   */

  export type ScheduleCountOutputType = {
    reports: number
  }

  export type ScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | ScheduleCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleCountOutputType
     */
    select?: ScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledReportWhereInput
  }


  /**
   * Count Type DeliveryTimeWindowCountOutputType
   */

  export type DeliveryTimeWindowCountOutputType = {
    orders: number
  }

  export type DeliveryTimeWindowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | DeliveryTimeWindowCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * DeliveryTimeWindowCountOutputType without action
   */
  export type DeliveryTimeWindowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTimeWindowCountOutputType
     */
    select?: DeliveryTimeWindowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliveryTimeWindowCountOutputType without action
   */
  export type DeliveryTimeWindowCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type DeliveryRouteCountOutputType
   */

  export type DeliveryRouteCountOutputType = {
    deliveries: number
  }

  export type DeliveryRouteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | DeliveryRouteCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * DeliveryRouteCountOutputType without action
   */
  export type DeliveryRouteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRouteCountOutputType
     */
    select?: DeliveryRouteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliveryRouteCountOutputType without action
   */
  export type DeliveryRouteCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    children: number
    products: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ProductCategoryCountOutputTypeCountChildrenArgs
    products?: boolean | ProductCategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }


  /**
   * Count Type AdminPermissionCountOutputType
   */

  export type AdminPermissionCountOutputType = {
    adminRoles: number
  }

  export type AdminPermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminRoles?: boolean | AdminPermissionCountOutputTypeCountAdminRolesArgs
  }

  // Custom InputTypes
  /**
   * AdminPermissionCountOutputType without action
   */
  export type AdminPermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermissionCountOutputType
     */
    select?: AdminPermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminPermissionCountOutputType without action
   */
  export type AdminPermissionCountOutputTypeCountAdminRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminRoleWhereInput
  }


  /**
   * Count Type AdminRoleCountOutputType
   */

  export type AdminRoleCountOutputType = {
    permissions: number
    admins: number
  }

  export type AdminRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | AdminRoleCountOutputTypeCountPermissionsArgs
    admins?: boolean | AdminRoleCountOutputTypeCountAdminsArgs
  }

  // Custom InputTypes
  /**
   * AdminRoleCountOutputType without action
   */
  export type AdminRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleCountOutputType
     */
    select?: AdminRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminRoleCountOutputType without action
   */
  export type AdminRoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminPermissionWhereInput
  }

  /**
   * AdminRoleCountOutputType without action
   */
  export type AdminRoleCountOutputTypeCountAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminRoleMappingWhereInput
  }


  /**
   * Count Type EmailTemplateCountOutputType
   */

  export type EmailTemplateCountOutputType = {
    sentEmails: number
  }

  export type EmailTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentEmails?: boolean | EmailTemplateCountOutputTypeCountSentEmailsArgs
  }

  // Custom InputTypes
  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplateCountOutputType
     */
    select?: EmailTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailTemplateCountOutputType without action
   */
  export type EmailTemplateCountOutputTypeCountSentEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SentEmailWhereInput
  }


  /**
   * Count Type SavedPaymentMethodCountOutputType
   */

  export type SavedPaymentMethodCountOutputType = {
    subscriptions: number
  }

  export type SavedPaymentMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SavedPaymentMethodCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * SavedPaymentMethodCountOutputType without action
   */
  export type SavedPaymentMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethodCountOutputType
     */
    select?: SavedPaymentMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SavedPaymentMethodCountOutputType without action
   */
  export type SavedPaymentMethodCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type SubscriptionPlanCountOutputType
   */

  export type SubscriptionPlanCountOutputType = {
    subscriptions: number
  }

  export type SubscriptionPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlanCountOutputType
     */
    select?: SubscriptionPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    recurringPayments: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recurringPayments?: boolean | SubscriptionCountOutputTypeCountRecurringPaymentsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountRecurringPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringPaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | User$adminArgs<ExtArgs>
    business?: boolean | User$businessArgs<ExtArgs>
    courier?: boolean | User$courierArgs<ExtArgs>
    customer?: boolean | User$customerArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    notificationPreferences?: boolean | User$notificationPreferencesArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    scheduledReports?: boolean | User$scheduledReportsArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | User$adminArgs<ExtArgs>
    business?: boolean | User$businessArgs<ExtArgs>
    courier?: boolean | User$courierArgs<ExtArgs>
    customer?: boolean | User$customerArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    notificationPreferences?: boolean | User$notificationPreferencesArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    scheduledReports?: boolean | User$scheduledReportsArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
      business: Prisma.$BusinessPayload<ExtArgs> | null
      courier: Prisma.$CourierPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      notificationPreferences: Prisma.$NotificationPreferencePayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      scheduledReports: Prisma.$ScheduledReportPayload<ExtArgs>[]
      settings: Prisma.$UserSettingsPayload<ExtArgs> | null
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    business<T extends User$businessArgs<ExtArgs> = {}>(args?: Subset<T, User$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    courier<T extends User$courierArgs<ExtArgs> = {}>(args?: Subset<T, User$courierArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends User$customerArgs<ExtArgs> = {}>(args?: Subset<T, User$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationPreferences<T extends User$notificationPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationPreferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends User$reportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduledReports<T extends User$scheduledReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$scheduledReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settings<T extends User$settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$settingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.business
   */
  export type User$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * User.courier
   */
  export type User$courierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    where?: CourierWhereInput
  }

  /**
   * User.customer
   */
  export type User$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.notificationPreferences
   */
  export type User$notificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    cursor?: NotificationPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * User.reports
   */
  export type User$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.scheduledReports
   */
  export type User$scheduledReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    where?: ScheduledReportWhereInput
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    cursor?: ScheduledReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * User.settings
   */
  export type User$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    level: number | null
    loginAttempts: number | null
  }

  export type AdminSumAggregateOutputType = {
    level: number | null
    loginAttempts: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    department: string | null
    level: number | null
    title: string | null
    phone: string | null
    profileImage: string | null
    lastLogin: Date | null
    loginAttempts: number | null
    isSuperAdmin: boolean | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    department: string | null
    level: number | null
    title: string | null
    phone: string | null
    profileImage: string | null
    lastLogin: Date | null
    loginAttempts: number | null
    isSuperAdmin: boolean | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    department: number
    level: number
    permissions: number
    title: number
    phone: number
    profileImage: number
    lastLogin: number
    loginAttempts: number
    isSuperAdmin: number
    ipRestrictions: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    level?: true
    loginAttempts?: true
  }

  export type AdminSumAggregateInputType = {
    level?: true
    loginAttempts?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
    department?: true
    level?: true
    title?: true
    phone?: true
    profileImage?: true
    lastLogin?: true
    loginAttempts?: true
    isSuperAdmin?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
    department?: true
    level?: true
    title?: true
    phone?: true
    profileImage?: true
    lastLogin?: true
    loginAttempts?: true
    isSuperAdmin?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    department?: true
    level?: true
    permissions?: true
    title?: true
    phone?: true
    profileImage?: true
    lastLogin?: true
    loginAttempts?: true
    isSuperAdmin?: true
    ipRestrictions?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    userId: string
    department: string | null
    level: number
    permissions: string[]
    title: string | null
    phone: string | null
    profileImage: string | null
    lastLogin: Date | null
    loginAttempts: number
    isSuperAdmin: boolean
    ipRestrictions: string[]
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    department?: boolean
    level?: boolean
    permissions?: boolean
    title?: boolean
    phone?: boolean
    profileImage?: boolean
    lastLogin?: boolean
    loginAttempts?: boolean
    isSuperAdmin?: boolean
    ipRestrictions?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    activityLogs?: boolean | Admin$activityLogsArgs<ExtArgs>
    systemActions?: boolean | Admin$systemActionsArgs<ExtArgs>
    dashboardWidgets?: boolean | Admin$dashboardWidgetsArgs<ExtArgs>
    roleMappings?: boolean | Admin$roleMappingsArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    department?: boolean
    level?: boolean
    permissions?: boolean
    title?: boolean
    phone?: boolean
    profileImage?: boolean
    lastLogin?: boolean
    loginAttempts?: boolean
    isSuperAdmin?: boolean
    ipRestrictions?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    department?: boolean
    level?: boolean
    permissions?: boolean
    title?: boolean
    phone?: boolean
    profileImage?: boolean
    lastLogin?: boolean
    loginAttempts?: boolean
    isSuperAdmin?: boolean
    ipRestrictions?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
    department?: boolean
    level?: boolean
    permissions?: boolean
    title?: boolean
    phone?: boolean
    profileImage?: boolean
    lastLogin?: boolean
    loginAttempts?: boolean
    isSuperAdmin?: boolean
    ipRestrictions?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "department" | "level" | "permissions" | "title" | "phone" | "profileImage" | "lastLogin" | "loginAttempts" | "isSuperAdmin" | "ipRestrictions", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    activityLogs?: boolean | Admin$activityLogsArgs<ExtArgs>
    systemActions?: boolean | Admin$systemActionsArgs<ExtArgs>
    dashboardWidgets?: boolean | Admin$dashboardWidgetsArgs<ExtArgs>
    roleMappings?: boolean | Admin$roleMappingsArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      systemActions: Prisma.$SystemActionPayload<ExtArgs>[]
      dashboardWidgets: Prisma.$AdminDashboardWidgetPayload<ExtArgs>[]
      roleMappings: Prisma.$AdminRoleMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      department: string | null
      level: number
      permissions: string[]
      title: string | null
      phone: string | null
      profileImage: string | null
      lastLogin: Date | null
      loginAttempts: number
      isSuperAdmin: boolean
      ipRestrictions: string[]
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    activityLogs<T extends Admin$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    systemActions<T extends Admin$systemActionsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$systemActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dashboardWidgets<T extends Admin$dashboardWidgetsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$dashboardWidgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminDashboardWidgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roleMappings<T extends Admin$roleMappingsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$roleMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRoleMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'String'>
    readonly department: FieldRef<"Admin", 'String'>
    readonly level: FieldRef<"Admin", 'Int'>
    readonly permissions: FieldRef<"Admin", 'String[]'>
    readonly title: FieldRef<"Admin", 'String'>
    readonly phone: FieldRef<"Admin", 'String'>
    readonly profileImage: FieldRef<"Admin", 'String'>
    readonly lastLogin: FieldRef<"Admin", 'DateTime'>
    readonly loginAttempts: FieldRef<"Admin", 'Int'>
    readonly isSuperAdmin: FieldRef<"Admin", 'Boolean'>
    readonly ipRestrictions: FieldRef<"Admin", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.activityLogs
   */
  export type Admin$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Admin.systemActions
   */
  export type Admin$systemActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAction
     */
    select?: SystemActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAction
     */
    omit?: SystemActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemActionInclude<ExtArgs> | null
    where?: SystemActionWhereInput
    orderBy?: SystemActionOrderByWithRelationInput | SystemActionOrderByWithRelationInput[]
    cursor?: SystemActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemActionScalarFieldEnum | SystemActionScalarFieldEnum[]
  }

  /**
   * Admin.dashboardWidgets
   */
  export type Admin$dashboardWidgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminDashboardWidget
     */
    select?: AdminDashboardWidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminDashboardWidget
     */
    omit?: AdminDashboardWidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminDashboardWidgetInclude<ExtArgs> | null
    where?: AdminDashboardWidgetWhereInput
    orderBy?: AdminDashboardWidgetOrderByWithRelationInput | AdminDashboardWidgetOrderByWithRelationInput[]
    cursor?: AdminDashboardWidgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminDashboardWidgetScalarFieldEnum | AdminDashboardWidgetScalarFieldEnum[]
  }

  /**
   * Admin.roleMappings
   */
  export type Admin$roleMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleMapping
     */
    select?: AdminRoleMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRoleMapping
     */
    omit?: AdminRoleMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleMappingInclude<ExtArgs> | null
    where?: AdminRoleMappingWhereInput
    orderBy?: AdminRoleMappingOrderByWithRelationInput | AdminRoleMappingOrderByWithRelationInput[]
    cursor?: AdminRoleMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminRoleMappingScalarFieldEnum | AdminRoleMappingScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Courier
   */

  export type AggregateCourier = {
    _count: CourierCountAggregateOutputType | null
    _avg: CourierAvgAggregateOutputType | null
    _sum: CourierSumAggregateOutputType | null
    _min: CourierMinAggregateOutputType | null
    _max: CourierMaxAggregateOutputType | null
  }

  export type CourierAvgAggregateOutputType = {
    ratings: number | null
    currentLatitude: number | null
    currentLongitude: number | null
    maxDeliveriesPerDay: number | null
    maxDistance: number | null
    averageSpeed: number | null
    courierFee: number | null
  }

  export type CourierSumAggregateOutputType = {
    ratings: number | null
    currentLatitude: number | null
    currentLongitude: number | null
    maxDeliveriesPerDay: number | null
    maxDistance: number | null
    averageSpeed: number | null
    courierFee: number | null
  }

  export type CourierMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.Status | null
    vehicleType: string | null
    phone: string | null
    zoneId: string | null
    ratings: number | null
    currentLatitude: number | null
    currentLongitude: number | null
    lastLocationUpdate: Date | null
    availableFrom: Date | null
    availableTo: Date | null
    documentsVerified: boolean | null
    backgroundChecked: boolean | null
    maxDeliveriesPerDay: number | null
    maxDistance: number | null
    averageSpeed: number | null
    courierFee: number | null
    lastSeen: Date | null
    availabilityStatus: $Enums.CourierAvailabilityStatus | null
  }

  export type CourierMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.Status | null
    vehicleType: string | null
    phone: string | null
    zoneId: string | null
    ratings: number | null
    currentLatitude: number | null
    currentLongitude: number | null
    lastLocationUpdate: Date | null
    availableFrom: Date | null
    availableTo: Date | null
    documentsVerified: boolean | null
    backgroundChecked: boolean | null
    maxDeliveriesPerDay: number | null
    maxDistance: number | null
    averageSpeed: number | null
    courierFee: number | null
    lastSeen: Date | null
    availabilityStatus: $Enums.CourierAvailabilityStatus | null
  }

  export type CourierCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    vehicleType: number
    phone: number
    zoneId: number
    ratings: number
    currentLatitude: number
    currentLongitude: number
    lastLocationUpdate: number
    availableFrom: number
    availableTo: number
    documentsVerified: number
    backgroundChecked: number
    maxDeliveriesPerDay: number
    maxDistance: number
    averageSpeed: number
    courierFee: number
    lastSeen: number
    availabilityStatus: number
    _all: number
  }


  export type CourierAvgAggregateInputType = {
    ratings?: true
    currentLatitude?: true
    currentLongitude?: true
    maxDeliveriesPerDay?: true
    maxDistance?: true
    averageSpeed?: true
    courierFee?: true
  }

  export type CourierSumAggregateInputType = {
    ratings?: true
    currentLatitude?: true
    currentLongitude?: true
    maxDeliveriesPerDay?: true
    maxDistance?: true
    averageSpeed?: true
    courierFee?: true
  }

  export type CourierMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    vehicleType?: true
    phone?: true
    zoneId?: true
    ratings?: true
    currentLatitude?: true
    currentLongitude?: true
    lastLocationUpdate?: true
    availableFrom?: true
    availableTo?: true
    documentsVerified?: true
    backgroundChecked?: true
    maxDeliveriesPerDay?: true
    maxDistance?: true
    averageSpeed?: true
    courierFee?: true
    lastSeen?: true
    availabilityStatus?: true
  }

  export type CourierMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    vehicleType?: true
    phone?: true
    zoneId?: true
    ratings?: true
    currentLatitude?: true
    currentLongitude?: true
    lastLocationUpdate?: true
    availableFrom?: true
    availableTo?: true
    documentsVerified?: true
    backgroundChecked?: true
    maxDeliveriesPerDay?: true
    maxDistance?: true
    averageSpeed?: true
    courierFee?: true
    lastSeen?: true
    availabilityStatus?: true
  }

  export type CourierCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    vehicleType?: true
    phone?: true
    zoneId?: true
    ratings?: true
    currentLatitude?: true
    currentLongitude?: true
    lastLocationUpdate?: true
    availableFrom?: true
    availableTo?: true
    documentsVerified?: true
    backgroundChecked?: true
    maxDeliveriesPerDay?: true
    maxDistance?: true
    averageSpeed?: true
    courierFee?: true
    lastSeen?: true
    availabilityStatus?: true
    _all?: true
  }

  export type CourierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courier to aggregate.
     */
    where?: CourierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CourierOrderByWithRelationInput | CourierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Couriers
    **/
    _count?: true | CourierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourierMaxAggregateInputType
  }

  export type GetCourierAggregateType<T extends CourierAggregateArgs> = {
        [P in keyof T & keyof AggregateCourier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourier[P]>
      : GetScalarType<T[P], AggregateCourier[P]>
  }




  export type CourierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourierWhereInput
    orderBy?: CourierOrderByWithAggregationInput | CourierOrderByWithAggregationInput[]
    by: CourierScalarFieldEnum[] | CourierScalarFieldEnum
    having?: CourierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourierCountAggregateInputType | true
    _avg?: CourierAvgAggregateInputType
    _sum?: CourierSumAggregateInputType
    _min?: CourierMinAggregateInputType
    _max?: CourierMaxAggregateInputType
  }

  export type CourierGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.Status
    vehicleType: string | null
    phone: string | null
    zoneId: string | null
    ratings: number | null
    currentLatitude: number | null
    currentLongitude: number | null
    lastLocationUpdate: Date | null
    availableFrom: Date | null
    availableTo: Date | null
    documentsVerified: boolean
    backgroundChecked: boolean
    maxDeliveriesPerDay: number
    maxDistance: number | null
    averageSpeed: number | null
    courierFee: number | null
    lastSeen: Date | null
    availabilityStatus: $Enums.CourierAvailabilityStatus | null
    _count: CourierCountAggregateOutputType | null
    _avg: CourierAvgAggregateOutputType | null
    _sum: CourierSumAggregateOutputType | null
    _min: CourierMinAggregateOutputType | null
    _max: CourierMaxAggregateOutputType | null
  }

  type GetCourierGroupByPayload<T extends CourierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourierGroupByOutputType[P]>
            : GetScalarType<T[P], CourierGroupByOutputType[P]>
        }
      >
    >


  export type CourierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    vehicleType?: boolean
    phone?: boolean
    zoneId?: boolean
    ratings?: boolean
    currentLatitude?: boolean
    currentLongitude?: boolean
    lastLocationUpdate?: boolean
    availableFrom?: boolean
    availableTo?: boolean
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: boolean
    maxDistance?: boolean
    averageSpeed?: boolean
    courierFee?: boolean
    lastSeen?: boolean
    availabilityStatus?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | Courier$zoneArgs<ExtArgs>
    orders?: boolean | Courier$ordersArgs<ExtArgs>
    notifications?: boolean | Courier$notificationsArgs<ExtArgs>
    notificationPreferences?: boolean | Courier$notificationPreferencesArgs<ExtArgs>
    deliveryLogs?: boolean | Courier$deliveryLogsArgs<ExtArgs>
    deliveries?: boolean | Courier$deliveriesArgs<ExtArgs>
    payments?: boolean | Courier$paymentsArgs<ExtArgs>
    availability?: boolean | Courier$availabilityArgs<ExtArgs>
    deliveryRoutes?: boolean | Courier$deliveryRoutesArgs<ExtArgs>
    _count?: boolean | CourierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courier"]>

  export type CourierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    vehicleType?: boolean
    phone?: boolean
    zoneId?: boolean
    ratings?: boolean
    currentLatitude?: boolean
    currentLongitude?: boolean
    lastLocationUpdate?: boolean
    availableFrom?: boolean
    availableTo?: boolean
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: boolean
    maxDistance?: boolean
    averageSpeed?: boolean
    courierFee?: boolean
    lastSeen?: boolean
    availabilityStatus?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | Courier$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["courier"]>

  export type CourierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    vehicleType?: boolean
    phone?: boolean
    zoneId?: boolean
    ratings?: boolean
    currentLatitude?: boolean
    currentLongitude?: boolean
    lastLocationUpdate?: boolean
    availableFrom?: boolean
    availableTo?: boolean
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: boolean
    maxDistance?: boolean
    averageSpeed?: boolean
    courierFee?: boolean
    lastSeen?: boolean
    availabilityStatus?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | Courier$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["courier"]>

  export type CourierSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    vehicleType?: boolean
    phone?: boolean
    zoneId?: boolean
    ratings?: boolean
    currentLatitude?: boolean
    currentLongitude?: boolean
    lastLocationUpdate?: boolean
    availableFrom?: boolean
    availableTo?: boolean
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: boolean
    maxDistance?: boolean
    averageSpeed?: boolean
    courierFee?: boolean
    lastSeen?: boolean
    availabilityStatus?: boolean
  }

  export type CourierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "vehicleType" | "phone" | "zoneId" | "ratings" | "currentLatitude" | "currentLongitude" | "lastLocationUpdate" | "availableFrom" | "availableTo" | "documentsVerified" | "backgroundChecked" | "maxDeliveriesPerDay" | "maxDistance" | "averageSpeed" | "courierFee" | "lastSeen" | "availabilityStatus", ExtArgs["result"]["courier"]>
  export type CourierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | Courier$zoneArgs<ExtArgs>
    orders?: boolean | Courier$ordersArgs<ExtArgs>
    notifications?: boolean | Courier$notificationsArgs<ExtArgs>
    notificationPreferences?: boolean | Courier$notificationPreferencesArgs<ExtArgs>
    deliveryLogs?: boolean | Courier$deliveryLogsArgs<ExtArgs>
    deliveries?: boolean | Courier$deliveriesArgs<ExtArgs>
    payments?: boolean | Courier$paymentsArgs<ExtArgs>
    availability?: boolean | Courier$availabilityArgs<ExtArgs>
    deliveryRoutes?: boolean | Courier$deliveryRoutesArgs<ExtArgs>
    _count?: boolean | CourierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | Courier$zoneArgs<ExtArgs>
  }
  export type CourierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | Courier$zoneArgs<ExtArgs>
  }

  export type $CourierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Courier"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs> | null
      orders: Prisma.$OrderPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      notificationPreferences: Prisma.$NotificationPreferencePayload<ExtArgs>[]
      deliveryLogs: Prisma.$DeliveryLogPayload<ExtArgs>[]
      deliveries: Prisma.$DeliveryPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      availability: Prisma.$CourierAvailabilityPayload<ExtArgs>[]
      deliveryRoutes: Prisma.$DeliveryRoutePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.Status
      vehicleType: string | null
      phone: string | null
      zoneId: string | null
      ratings: number | null
      currentLatitude: number | null
      currentLongitude: number | null
      lastLocationUpdate: Date | null
      availableFrom: Date | null
      availableTo: Date | null
      documentsVerified: boolean
      backgroundChecked: boolean
      maxDeliveriesPerDay: number
      maxDistance: number | null
      averageSpeed: number | null
      courierFee: number | null
      lastSeen: Date | null
      availabilityStatus: $Enums.CourierAvailabilityStatus | null
    }, ExtArgs["result"]["courier"]>
    composites: {}
  }

  type CourierGetPayload<S extends boolean | null | undefined | CourierDefaultArgs> = $Result.GetResult<Prisma.$CourierPayload, S>

  type CourierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourierCountAggregateInputType | true
    }

  export interface CourierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Courier'], meta: { name: 'Courier' } }
    /**
     * Find zero or one Courier that matches the filter.
     * @param {CourierFindUniqueArgs} args - Arguments to find a Courier
     * @example
     * // Get one Courier
     * const courier = await prisma.courier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourierFindUniqueArgs>(args: SelectSubset<T, CourierFindUniqueArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Courier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourierFindUniqueOrThrowArgs} args - Arguments to find a Courier
     * @example
     * // Get one Courier
     * const courier = await prisma.courier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourierFindUniqueOrThrowArgs>(args: SelectSubset<T, CourierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Courier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierFindFirstArgs} args - Arguments to find a Courier
     * @example
     * // Get one Courier
     * const courier = await prisma.courier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourierFindFirstArgs>(args?: SelectSubset<T, CourierFindFirstArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Courier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierFindFirstOrThrowArgs} args - Arguments to find a Courier
     * @example
     * // Get one Courier
     * const courier = await prisma.courier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourierFindFirstOrThrowArgs>(args?: SelectSubset<T, CourierFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Couriers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Couriers
     * const couriers = await prisma.courier.findMany()
     * 
     * // Get first 10 Couriers
     * const couriers = await prisma.courier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courierWithIdOnly = await prisma.courier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourierFindManyArgs>(args?: SelectSubset<T, CourierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Courier.
     * @param {CourierCreateArgs} args - Arguments to create a Courier.
     * @example
     * // Create one Courier
     * const Courier = await prisma.courier.create({
     *   data: {
     *     // ... data to create a Courier
     *   }
     * })
     * 
     */
    create<T extends CourierCreateArgs>(args: SelectSubset<T, CourierCreateArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Couriers.
     * @param {CourierCreateManyArgs} args - Arguments to create many Couriers.
     * @example
     * // Create many Couriers
     * const courier = await prisma.courier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourierCreateManyArgs>(args?: SelectSubset<T, CourierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Couriers and returns the data saved in the database.
     * @param {CourierCreateManyAndReturnArgs} args - Arguments to create many Couriers.
     * @example
     * // Create many Couriers
     * const courier = await prisma.courier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Couriers and only return the `id`
     * const courierWithIdOnly = await prisma.courier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourierCreateManyAndReturnArgs>(args?: SelectSubset<T, CourierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Courier.
     * @param {CourierDeleteArgs} args - Arguments to delete one Courier.
     * @example
     * // Delete one Courier
     * const Courier = await prisma.courier.delete({
     *   where: {
     *     // ... filter to delete one Courier
     *   }
     * })
     * 
     */
    delete<T extends CourierDeleteArgs>(args: SelectSubset<T, CourierDeleteArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Courier.
     * @param {CourierUpdateArgs} args - Arguments to update one Courier.
     * @example
     * // Update one Courier
     * const courier = await prisma.courier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourierUpdateArgs>(args: SelectSubset<T, CourierUpdateArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Couriers.
     * @param {CourierDeleteManyArgs} args - Arguments to filter Couriers to delete.
     * @example
     * // Delete a few Couriers
     * const { count } = await prisma.courier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourierDeleteManyArgs>(args?: SelectSubset<T, CourierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Couriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Couriers
     * const courier = await prisma.courier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourierUpdateManyArgs>(args: SelectSubset<T, CourierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Couriers and returns the data updated in the database.
     * @param {CourierUpdateManyAndReturnArgs} args - Arguments to update many Couriers.
     * @example
     * // Update many Couriers
     * const courier = await prisma.courier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Couriers and only return the `id`
     * const courierWithIdOnly = await prisma.courier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourierUpdateManyAndReturnArgs>(args: SelectSubset<T, CourierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Courier.
     * @param {CourierUpsertArgs} args - Arguments to update or create a Courier.
     * @example
     * // Update or create a Courier
     * const courier = await prisma.courier.upsert({
     *   create: {
     *     // ... data to create a Courier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Courier we want to update
     *   }
     * })
     */
    upsert<T extends CourierUpsertArgs>(args: SelectSubset<T, CourierUpsertArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Couriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierCountArgs} args - Arguments to filter Couriers to count.
     * @example
     * // Count the number of Couriers
     * const count = await prisma.courier.count({
     *   where: {
     *     // ... the filter for the Couriers we want to count
     *   }
     * })
    **/
    count<T extends CourierCountArgs>(
      args?: Subset<T, CourierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Courier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourierAggregateArgs>(args: Subset<T, CourierAggregateArgs>): Prisma.PrismaPromise<GetCourierAggregateType<T>>

    /**
     * Group by Courier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourierGroupByArgs['orderBy'] }
        : { orderBy?: CourierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Courier model
   */
  readonly fields: CourierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Courier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    zone<T extends Courier$zoneArgs<ExtArgs> = {}>(args?: Subset<T, Courier$zoneArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orders<T extends Courier$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Courier$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Courier$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Courier$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationPreferences<T extends Courier$notificationPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, Courier$notificationPreferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryLogs<T extends Courier$deliveryLogsArgs<ExtArgs> = {}>(args?: Subset<T, Courier$deliveryLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveries<T extends Courier$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Courier$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Courier$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Courier$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    availability<T extends Courier$availabilityArgs<ExtArgs> = {}>(args?: Subset<T, Courier$availabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierAvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryRoutes<T extends Courier$deliveryRoutesArgs<ExtArgs> = {}>(args?: Subset<T, Courier$deliveryRoutesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryRoutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Courier model
   */
  interface CourierFieldRefs {
    readonly id: FieldRef<"Courier", 'String'>
    readonly userId: FieldRef<"Courier", 'String'>
    readonly status: FieldRef<"Courier", 'Status'>
    readonly vehicleType: FieldRef<"Courier", 'String'>
    readonly phone: FieldRef<"Courier", 'String'>
    readonly zoneId: FieldRef<"Courier", 'String'>
    readonly ratings: FieldRef<"Courier", 'Float'>
    readonly currentLatitude: FieldRef<"Courier", 'Float'>
    readonly currentLongitude: FieldRef<"Courier", 'Float'>
    readonly lastLocationUpdate: FieldRef<"Courier", 'DateTime'>
    readonly availableFrom: FieldRef<"Courier", 'DateTime'>
    readonly availableTo: FieldRef<"Courier", 'DateTime'>
    readonly documentsVerified: FieldRef<"Courier", 'Boolean'>
    readonly backgroundChecked: FieldRef<"Courier", 'Boolean'>
    readonly maxDeliveriesPerDay: FieldRef<"Courier", 'Int'>
    readonly maxDistance: FieldRef<"Courier", 'Float'>
    readonly averageSpeed: FieldRef<"Courier", 'Float'>
    readonly courierFee: FieldRef<"Courier", 'Float'>
    readonly lastSeen: FieldRef<"Courier", 'DateTime'>
    readonly availabilityStatus: FieldRef<"Courier", 'CourierAvailabilityStatus'>
  }
    

  // Custom InputTypes
  /**
   * Courier findUnique
   */
  export type CourierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * Filter, which Courier to fetch.
     */
    where: CourierWhereUniqueInput
  }

  /**
   * Courier findUniqueOrThrow
   */
  export type CourierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * Filter, which Courier to fetch.
     */
    where: CourierWhereUniqueInput
  }

  /**
   * Courier findFirst
   */
  export type CourierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * Filter, which Courier to fetch.
     */
    where?: CourierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CourierOrderByWithRelationInput | CourierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Couriers.
     */
    cursor?: CourierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Couriers.
     */
    distinct?: CourierScalarFieldEnum | CourierScalarFieldEnum[]
  }

  /**
   * Courier findFirstOrThrow
   */
  export type CourierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * Filter, which Courier to fetch.
     */
    where?: CourierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CourierOrderByWithRelationInput | CourierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Couriers.
     */
    cursor?: CourierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Couriers.
     */
    distinct?: CourierScalarFieldEnum | CourierScalarFieldEnum[]
  }

  /**
   * Courier findMany
   */
  export type CourierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * Filter, which Couriers to fetch.
     */
    where?: CourierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CourierOrderByWithRelationInput | CourierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Couriers.
     */
    cursor?: CourierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    distinct?: CourierScalarFieldEnum | CourierScalarFieldEnum[]
  }

  /**
   * Courier create
   */
  export type CourierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * The data needed to create a Courier.
     */
    data: XOR<CourierCreateInput, CourierUncheckedCreateInput>
  }

  /**
   * Courier createMany
   */
  export type CourierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Couriers.
     */
    data: CourierCreateManyInput | CourierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Courier createManyAndReturn
   */
  export type CourierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * The data used to create many Couriers.
     */
    data: CourierCreateManyInput | CourierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Courier update
   */
  export type CourierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * The data needed to update a Courier.
     */
    data: XOR<CourierUpdateInput, CourierUncheckedUpdateInput>
    /**
     * Choose, which Courier to update.
     */
    where: CourierWhereUniqueInput
  }

  /**
   * Courier updateMany
   */
  export type CourierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Couriers.
     */
    data: XOR<CourierUpdateManyMutationInput, CourierUncheckedUpdateManyInput>
    /**
     * Filter which Couriers to update
     */
    where?: CourierWhereInput
    /**
     * Limit how many Couriers to update.
     */
    limit?: number
  }

  /**
   * Courier updateManyAndReturn
   */
  export type CourierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * The data used to update Couriers.
     */
    data: XOR<CourierUpdateManyMutationInput, CourierUncheckedUpdateManyInput>
    /**
     * Filter which Couriers to update
     */
    where?: CourierWhereInput
    /**
     * Limit how many Couriers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Courier upsert
   */
  export type CourierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * The filter to search for the Courier to update in case it exists.
     */
    where: CourierWhereUniqueInput
    /**
     * In case the Courier found by the `where` argument doesn't exist, create a new Courier with this data.
     */
    create: XOR<CourierCreateInput, CourierUncheckedCreateInput>
    /**
     * In case the Courier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourierUpdateInput, CourierUncheckedUpdateInput>
  }

  /**
   * Courier delete
   */
  export type CourierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * Filter which Courier to delete.
     */
    where: CourierWhereUniqueInput
  }

  /**
   * Courier deleteMany
   */
  export type CourierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Couriers to delete
     */
    where?: CourierWhereInput
    /**
     * Limit how many Couriers to delete.
     */
    limit?: number
  }

  /**
   * Courier.zone
   */
  export type Courier$zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
  }

  /**
   * Courier.orders
   */
  export type Courier$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Courier.notifications
   */
  export type Courier$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Courier.notificationPreferences
   */
  export type Courier$notificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    cursor?: NotificationPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * Courier.deliveryLogs
   */
  export type Courier$deliveryLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    where?: DeliveryLogWhereInput
    orderBy?: DeliveryLogOrderByWithRelationInput | DeliveryLogOrderByWithRelationInput[]
    cursor?: DeliveryLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryLogScalarFieldEnum | DeliveryLogScalarFieldEnum[]
  }

  /**
   * Courier.deliveries
   */
  export type Courier$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Courier.payments
   */
  export type Courier$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Courier.availability
   */
  export type Courier$availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierAvailability
     */
    select?: CourierAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierAvailability
     */
    omit?: CourierAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierAvailabilityInclude<ExtArgs> | null
    where?: CourierAvailabilityWhereInput
    orderBy?: CourierAvailabilityOrderByWithRelationInput | CourierAvailabilityOrderByWithRelationInput[]
    cursor?: CourierAvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourierAvailabilityScalarFieldEnum | CourierAvailabilityScalarFieldEnum[]
  }

  /**
   * Courier.deliveryRoutes
   */
  export type Courier$deliveryRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRoute
     */
    select?: DeliveryRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryRoute
     */
    omit?: DeliveryRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryRouteInclude<ExtArgs> | null
    where?: DeliveryRouteWhereInput
    orderBy?: DeliveryRouteOrderByWithRelationInput | DeliveryRouteOrderByWithRelationInput[]
    cursor?: DeliveryRouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryRouteScalarFieldEnum | DeliveryRouteScalarFieldEnum[]
  }

  /**
   * Courier without action
   */
  export type CourierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    totalPrice: number | null
    latitude: number | null
    longitude: number | null
    estimatedDuration: number | null
    estimatedDistance: number | null
    sequenceNumber: number | null
  }

  export type OrderSumAggregateOutputType = {
    totalPrice: number | null
    latitude: number | null
    longitude: number | null
    estimatedDuration: number | null
    estimatedDistance: number | null
    sequenceNumber: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.Status | null
    totalPrice: number | null
    address: string | null
    notes: string | null
    estimatedDelivery: Date | null
    actualDelivery: Date | null
    latitude: number | null
    longitude: number | null
    customerId: string | null
    businessId: string | null
    courierId: string | null
    priority: $Enums.DeliveryPriority | null
    timeWindowId: string | null
    estimatedDuration: number | null
    estimatedDistance: number | null
    sequenceNumber: number | null
    refundStatus: string | null
    cancellationStatus: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.Status | null
    totalPrice: number | null
    address: string | null
    notes: string | null
    estimatedDelivery: Date | null
    actualDelivery: Date | null
    latitude: number | null
    longitude: number | null
    customerId: string | null
    businessId: string | null
    courierId: string | null
    priority: $Enums.DeliveryPriority | null
    timeWindowId: string | null
    estimatedDuration: number | null
    estimatedDistance: number | null
    sequenceNumber: number | null
    refundStatus: string | null
    cancellationStatus: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    totalPrice: number
    items: number
    address: number
    notes: number
    estimatedDelivery: number
    actualDelivery: number
    latitude: number
    longitude: number
    customerId: number
    businessId: number
    courierId: number
    priority: number
    timeWindowId: number
    estimatedDuration: number
    estimatedDistance: number
    sequenceNumber: number
    refundStatus: number
    cancellationStatus: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    totalPrice?: true
    latitude?: true
    longitude?: true
    estimatedDuration?: true
    estimatedDistance?: true
    sequenceNumber?: true
  }

  export type OrderSumAggregateInputType = {
    totalPrice?: true
    latitude?: true
    longitude?: true
    estimatedDuration?: true
    estimatedDistance?: true
    sequenceNumber?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    totalPrice?: true
    address?: true
    notes?: true
    estimatedDelivery?: true
    actualDelivery?: true
    latitude?: true
    longitude?: true
    customerId?: true
    businessId?: true
    courierId?: true
    priority?: true
    timeWindowId?: true
    estimatedDuration?: true
    estimatedDistance?: true
    sequenceNumber?: true
    refundStatus?: true
    cancellationStatus?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    totalPrice?: true
    address?: true
    notes?: true
    estimatedDelivery?: true
    actualDelivery?: true
    latitude?: true
    longitude?: true
    customerId?: true
    businessId?: true
    courierId?: true
    priority?: true
    timeWindowId?: true
    estimatedDuration?: true
    estimatedDistance?: true
    sequenceNumber?: true
    refundStatus?: true
    cancellationStatus?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    totalPrice?: true
    items?: true
    address?: true
    notes?: true
    estimatedDelivery?: true
    actualDelivery?: true
    latitude?: true
    longitude?: true
    customerId?: true
    businessId?: true
    courierId?: true
    priority?: true
    timeWindowId?: true
    estimatedDuration?: true
    estimatedDistance?: true
    sequenceNumber?: true
    refundStatus?: true
    cancellationStatus?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    status: $Enums.Status
    totalPrice: number
    items: JsonValue
    address: string
    notes: string | null
    estimatedDelivery: Date | null
    actualDelivery: Date | null
    latitude: number | null
    longitude: number | null
    customerId: string
    businessId: string
    courierId: string | null
    priority: $Enums.DeliveryPriority
    timeWindowId: string | null
    estimatedDuration: number | null
    estimatedDistance: number | null
    sequenceNumber: number | null
    refundStatus: string | null
    cancellationStatus: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    totalPrice?: boolean
    items?: boolean
    address?: boolean
    notes?: boolean
    estimatedDelivery?: boolean
    actualDelivery?: boolean
    latitude?: boolean
    longitude?: boolean
    customerId?: boolean
    businessId?: boolean
    courierId?: boolean
    priority?: boolean
    timeWindowId?: boolean
    estimatedDuration?: boolean
    estimatedDistance?: boolean
    sequenceNumber?: boolean
    refundStatus?: boolean
    cancellationStatus?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    courier?: boolean | Order$courierArgs<ExtArgs>
    notifications?: boolean | Order$notificationsArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    requestedTimeWindow?: boolean | Order$requestedTimeWindowArgs<ExtArgs>
    delivery?: boolean | Order$deliveryArgs<ExtArgs>
    refundRequests?: boolean | Order$refundRequestsArgs<ExtArgs>
    cancellationRequests?: boolean | Order$cancellationRequestsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    totalPrice?: boolean
    items?: boolean
    address?: boolean
    notes?: boolean
    estimatedDelivery?: boolean
    actualDelivery?: boolean
    latitude?: boolean
    longitude?: boolean
    customerId?: boolean
    businessId?: boolean
    courierId?: boolean
    priority?: boolean
    timeWindowId?: boolean
    estimatedDuration?: boolean
    estimatedDistance?: boolean
    sequenceNumber?: boolean
    refundStatus?: boolean
    cancellationStatus?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    courier?: boolean | Order$courierArgs<ExtArgs>
    requestedTimeWindow?: boolean | Order$requestedTimeWindowArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    totalPrice?: boolean
    items?: boolean
    address?: boolean
    notes?: boolean
    estimatedDelivery?: boolean
    actualDelivery?: boolean
    latitude?: boolean
    longitude?: boolean
    customerId?: boolean
    businessId?: boolean
    courierId?: boolean
    priority?: boolean
    timeWindowId?: boolean
    estimatedDuration?: boolean
    estimatedDistance?: boolean
    sequenceNumber?: boolean
    refundStatus?: boolean
    cancellationStatus?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    courier?: boolean | Order$courierArgs<ExtArgs>
    requestedTimeWindow?: boolean | Order$requestedTimeWindowArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    totalPrice?: boolean
    items?: boolean
    address?: boolean
    notes?: boolean
    estimatedDelivery?: boolean
    actualDelivery?: boolean
    latitude?: boolean
    longitude?: boolean
    customerId?: boolean
    businessId?: boolean
    courierId?: boolean
    priority?: boolean
    timeWindowId?: boolean
    estimatedDuration?: boolean
    estimatedDistance?: boolean
    sequenceNumber?: boolean
    refundStatus?: boolean
    cancellationStatus?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status" | "totalPrice" | "items" | "address" | "notes" | "estimatedDelivery" | "actualDelivery" | "latitude" | "longitude" | "customerId" | "businessId" | "courierId" | "priority" | "timeWindowId" | "estimatedDuration" | "estimatedDistance" | "sequenceNumber" | "refundStatus" | "cancellationStatus", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    courier?: boolean | Order$courierArgs<ExtArgs>
    notifications?: boolean | Order$notificationsArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    requestedTimeWindow?: boolean | Order$requestedTimeWindowArgs<ExtArgs>
    delivery?: boolean | Order$deliveryArgs<ExtArgs>
    refundRequests?: boolean | Order$refundRequestsArgs<ExtArgs>
    cancellationRequests?: boolean | Order$cancellationRequestsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    courier?: boolean | Order$courierArgs<ExtArgs>
    requestedTimeWindow?: boolean | Order$requestedTimeWindowArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    courier?: boolean | Order$courierArgs<ExtArgs>
    requestedTimeWindow?: boolean | Order$requestedTimeWindowArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      business: Prisma.$BusinessPayload<ExtArgs>
      courier: Prisma.$CourierPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      requestedTimeWindow: Prisma.$DeliveryTimeWindowPayload<ExtArgs> | null
      delivery: Prisma.$DeliveryPayload<ExtArgs> | null
      refundRequests: Prisma.$RefundRequestPayload<ExtArgs>[]
      cancellationRequests: Prisma.$CancellationRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      status: $Enums.Status
      totalPrice: number
      items: Prisma.JsonValue
      address: string
      notes: string | null
      estimatedDelivery: Date | null
      actualDelivery: Date | null
      latitude: number | null
      longitude: number | null
      customerId: string
      businessId: string
      courierId: string | null
      priority: $Enums.DeliveryPriority
      timeWindowId: string | null
      estimatedDuration: number | null
      estimatedDistance: number | null
      sequenceNumber: number | null
      refundStatus: string | null
      cancellationStatus: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    courier<T extends Order$courierArgs<ExtArgs> = {}>(args?: Subset<T, Order$courierArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends Order$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Order$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Order$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requestedTimeWindow<T extends Order$requestedTimeWindowArgs<ExtArgs> = {}>(args?: Subset<T, Order$requestedTimeWindowArgs<ExtArgs>>): Prisma__DeliveryTimeWindowClient<$Result.GetResult<Prisma.$DeliveryTimeWindowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    delivery<T extends Order$deliveryArgs<ExtArgs> = {}>(args?: Subset<T, Order$deliveryArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    refundRequests<T extends Order$refundRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Order$refundRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cancellationRequests<T extends Order$cancellationRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Order$cancellationRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly status: FieldRef<"Order", 'Status'>
    readonly totalPrice: FieldRef<"Order", 'Float'>
    readonly items: FieldRef<"Order", 'Json'>
    readonly address: FieldRef<"Order", 'String'>
    readonly notes: FieldRef<"Order", 'String'>
    readonly estimatedDelivery: FieldRef<"Order", 'DateTime'>
    readonly actualDelivery: FieldRef<"Order", 'DateTime'>
    readonly latitude: FieldRef<"Order", 'Float'>
    readonly longitude: FieldRef<"Order", 'Float'>
    readonly customerId: FieldRef<"Order", 'String'>
    readonly businessId: FieldRef<"Order", 'String'>
    readonly courierId: FieldRef<"Order", 'String'>
    readonly priority: FieldRef<"Order", 'DeliveryPriority'>
    readonly timeWindowId: FieldRef<"Order", 'String'>
    readonly estimatedDuration: FieldRef<"Order", 'Int'>
    readonly estimatedDistance: FieldRef<"Order", 'Float'>
    readonly sequenceNumber: FieldRef<"Order", 'Int'>
    readonly refundStatus: FieldRef<"Order", 'String'>
    readonly cancellationStatus: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.courier
   */
  export type Order$courierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    where?: CourierWhereInput
  }

  /**
   * Order.notifications
   */
  export type Order$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Order.payments
   */
  export type Order$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Order.requestedTimeWindow
   */
  export type Order$requestedTimeWindowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTimeWindow
     */
    select?: DeliveryTimeWindowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTimeWindow
     */
    omit?: DeliveryTimeWindowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTimeWindowInclude<ExtArgs> | null
    where?: DeliveryTimeWindowWhereInput
  }

  /**
   * Order.delivery
   */
  export type Order$deliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
  }

  /**
   * Order.refundRequests
   */
  export type Order$refundRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    where?: RefundRequestWhereInput
    orderBy?: RefundRequestOrderByWithRelationInput | RefundRequestOrderByWithRelationInput[]
    cursor?: RefundRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundRequestScalarFieldEnum | RefundRequestScalarFieldEnum[]
  }

  /**
   * Order.cancellationRequests
   */
  export type Order$cancellationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestInclude<ExtArgs> | null
    where?: CancellationRequestWhereInput
    orderBy?: CancellationRequestOrderByWithRelationInput | CancellationRequestOrderByWithRelationInput[]
    cursor?: CancellationRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CancellationRequestScalarFieldEnum | CancellationRequestScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type CustomerSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    phone: string | null
    address: string | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    phone: string | null
    address: string | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    userId: number
    phone: number
    address: number
    latitude: number
    longitude: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type CustomerSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    userId?: true
    phone?: true
    address?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    userId?: true
    phone?: true
    address?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    userId?: true
    phone?: true
    address?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    userId: string
    phone: string | null
    address: string | null
    latitude: number | null
    longitude: number | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phone?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    deliveries?: boolean | Customer$deliveriesArgs<ExtArgs>
    addresses?: boolean | Customer$addressesArgs<ExtArgs>
    refundRequests?: boolean | Customer$refundRequestsArgs<ExtArgs>
    cancellationRequests?: boolean | Customer$cancellationRequestsArgs<ExtArgs>
    savedPaymentMethods?: boolean | Customer$savedPaymentMethodsArgs<ExtArgs>
    subscriptions?: boolean | Customer$subscriptionsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phone?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phone?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    userId?: boolean
    phone?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "phone" | "address" | "latitude" | "longitude" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    deliveries?: boolean | Customer$deliveriesArgs<ExtArgs>
    addresses?: boolean | Customer$addressesArgs<ExtArgs>
    refundRequests?: boolean | Customer$refundRequestsArgs<ExtArgs>
    cancellationRequests?: boolean | Customer$cancellationRequestsArgs<ExtArgs>
    savedPaymentMethods?: boolean | Customer$savedPaymentMethodsArgs<ExtArgs>
    subscriptions?: boolean | Customer$subscriptionsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs>[]
      deliveries: Prisma.$DeliveryPayload<ExtArgs>[]
      addresses: Prisma.$CustomerAddressPayload<ExtArgs>[]
      refundRequests: Prisma.$RefundRequestPayload<ExtArgs>[]
      cancellationRequests: Prisma.$CancellationRequestPayload<ExtArgs>[]
      savedPaymentMethods: Prisma.$SavedPaymentMethodPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      phone: string | null
      address: string | null
      latitude: number | null
      longitude: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveries<T extends Customer$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addresses<T extends Customer$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refundRequests<T extends Customer$refundRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$refundRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cancellationRequests<T extends Customer$cancellationRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$cancellationRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedPaymentMethods<T extends Customer$savedPaymentMethodsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$savedPaymentMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedPaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Customer$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly userId: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly latitude: FieldRef<"Customer", 'Float'>
    readonly longitude: FieldRef<"Customer", 'Float'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer.deliveries
   */
  export type Customer$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Customer.addresses
   */
  export type Customer$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    where?: CustomerAddressWhereInput
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    cursor?: CustomerAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * Customer.refundRequests
   */
  export type Customer$refundRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    where?: RefundRequestWhereInput
    orderBy?: RefundRequestOrderByWithRelationInput | RefundRequestOrderByWithRelationInput[]
    cursor?: RefundRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundRequestScalarFieldEnum | RefundRequestScalarFieldEnum[]
  }

  /**
   * Customer.cancellationRequests
   */
  export type Customer$cancellationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestInclude<ExtArgs> | null
    where?: CancellationRequestWhereInput
    orderBy?: CancellationRequestOrderByWithRelationInput | CancellationRequestOrderByWithRelationInput[]
    cursor?: CancellationRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CancellationRequestScalarFieldEnum | CancellationRequestScalarFieldEnum[]
  }

  /**
   * Customer.savedPaymentMethods
   */
  export type Customer$savedPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethod
     */
    select?: SavedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedPaymentMethod
     */
    omit?: SavedPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPaymentMethodInclude<ExtArgs> | null
    where?: SavedPaymentMethodWhereInput
    orderBy?: SavedPaymentMethodOrderByWithRelationInput | SavedPaymentMethodOrderByWithRelationInput[]
    cursor?: SavedPaymentMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedPaymentMethodScalarFieldEnum | SavedPaymentMethodScalarFieldEnum[]
  }

  /**
   * Customer.subscriptions
   */
  export type Customer$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Business
   */

  export type AggregateBusiness = {
    _count: BusinessCountAggregateOutputType | null
    _avg: BusinessAvgAggregateOutputType | null
    _sum: BusinessSumAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  export type BusinessAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    rating: number | null
    deliveryRadius: number | null
    deliveryFee: number | null
  }

  export type BusinessSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    rating: number | null
    deliveryRadius: number | null
    deliveryFee: number | null
  }

  export type BusinessMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    address: string | null
    phone: string | null
    website: string | null
    email: string | null
    logoUrl: string | null
    coverUrl: string | null
    latitude: number | null
    longitude: number | null
    zoneId: string | null
    status: $Enums.Status | null
    rating: number | null
    tax_id: string | null
    bank_iban: string | null
    createdAt: Date | null
    updatedAt: Date | null
    openingTime: string | null
    closingTime: string | null
    deliveryRadius: number | null
    deliveryFee: number | null
    facebook: string | null
    instagram: string | null
    twitter: string | null
    type: string | null
  }

  export type BusinessMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    address: string | null
    phone: string | null
    website: string | null
    email: string | null
    logoUrl: string | null
    coverUrl: string | null
    latitude: number | null
    longitude: number | null
    zoneId: string | null
    status: $Enums.Status | null
    rating: number | null
    tax_id: string | null
    bank_iban: string | null
    createdAt: Date | null
    updatedAt: Date | null
    openingTime: string | null
    closingTime: string | null
    deliveryRadius: number | null
    deliveryFee: number | null
    facebook: string | null
    instagram: string | null
    twitter: string | null
    type: string | null
  }

  export type BusinessCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    address: number
    phone: number
    website: number
    email: number
    logoUrl: number
    coverUrl: number
    latitude: number
    longitude: number
    zoneId: number
    status: number
    rating: number
    tax_id: number
    bank_iban: number
    createdAt: number
    updatedAt: number
    openingTime: number
    closingTime: number
    deliveryRadius: number
    deliveryFee: number
    facebook: number
    instagram: number
    twitter: number
    type: number
    tags: number
    features: number
    _all: number
  }


  export type BusinessAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    rating?: true
    deliveryRadius?: true
    deliveryFee?: true
  }

  export type BusinessSumAggregateInputType = {
    latitude?: true
    longitude?: true
    rating?: true
    deliveryRadius?: true
    deliveryFee?: true
  }

  export type BusinessMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    address?: true
    phone?: true
    website?: true
    email?: true
    logoUrl?: true
    coverUrl?: true
    latitude?: true
    longitude?: true
    zoneId?: true
    status?: true
    rating?: true
    tax_id?: true
    bank_iban?: true
    createdAt?: true
    updatedAt?: true
    openingTime?: true
    closingTime?: true
    deliveryRadius?: true
    deliveryFee?: true
    facebook?: true
    instagram?: true
    twitter?: true
    type?: true
  }

  export type BusinessMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    address?: true
    phone?: true
    website?: true
    email?: true
    logoUrl?: true
    coverUrl?: true
    latitude?: true
    longitude?: true
    zoneId?: true
    status?: true
    rating?: true
    tax_id?: true
    bank_iban?: true
    createdAt?: true
    updatedAt?: true
    openingTime?: true
    closingTime?: true
    deliveryRadius?: true
    deliveryFee?: true
    facebook?: true
    instagram?: true
    twitter?: true
    type?: true
  }

  export type BusinessCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    address?: true
    phone?: true
    website?: true
    email?: true
    logoUrl?: true
    coverUrl?: true
    latitude?: true
    longitude?: true
    zoneId?: true
    status?: true
    rating?: true
    tax_id?: true
    bank_iban?: true
    createdAt?: true
    updatedAt?: true
    openingTime?: true
    closingTime?: true
    deliveryRadius?: true
    deliveryFee?: true
    facebook?: true
    instagram?: true
    twitter?: true
    type?: true
    tags?: true
    features?: true
    _all?: true
  }

  export type BusinessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Business to aggregate.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Businesses
    **/
    _count?: true | BusinessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessMaxAggregateInputType
  }

  export type GetBusinessAggregateType<T extends BusinessAggregateArgs> = {
        [P in keyof T & keyof AggregateBusiness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusiness[P]>
      : GetScalarType<T[P], AggregateBusiness[P]>
  }




  export type BusinessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithAggregationInput | BusinessOrderByWithAggregationInput[]
    by: BusinessScalarFieldEnum[] | BusinessScalarFieldEnum
    having?: BusinessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessCountAggregateInputType | true
    _avg?: BusinessAvgAggregateInputType
    _sum?: BusinessSumAggregateInputType
    _min?: BusinessMinAggregateInputType
    _max?: BusinessMaxAggregateInputType
  }

  export type BusinessGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    address: string | null
    phone: string | null
    website: string | null
    email: string | null
    logoUrl: string | null
    coverUrl: string | null
    latitude: number | null
    longitude: number | null
    zoneId: string | null
    status: $Enums.Status
    rating: number | null
    tax_id: string | null
    bank_iban: string | null
    createdAt: Date
    updatedAt: Date
    openingTime: string | null
    closingTime: string | null
    deliveryRadius: number | null
    deliveryFee: number | null
    facebook: string | null
    instagram: string | null
    twitter: string | null
    type: string | null
    tags: string[]
    features: string[]
    _count: BusinessCountAggregateOutputType | null
    _avg: BusinessAvgAggregateOutputType | null
    _sum: BusinessSumAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  type GetBusinessGroupByPayload<T extends BusinessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessGroupByOutputType[P]>
        }
      >
    >


  export type BusinessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    address?: boolean
    phone?: boolean
    website?: boolean
    email?: boolean
    logoUrl?: boolean
    coverUrl?: boolean
    latitude?: boolean
    longitude?: boolean
    zoneId?: boolean
    status?: boolean
    rating?: boolean
    tax_id?: boolean
    bank_iban?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    openingTime?: boolean
    closingTime?: boolean
    deliveryRadius?: boolean
    deliveryFee?: boolean
    facebook?: boolean
    instagram?: boolean
    twitter?: boolean
    type?: boolean
    tags?: boolean
    features?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | Business$zoneArgs<ExtArgs>
    inventory?: boolean | Business$inventoryArgs<ExtArgs>
    orders?: boolean | Business$ordersArgs<ExtArgs>
    menuItems?: boolean | Business$menuItemsArgs<ExtArgs>
    productCategories?: boolean | Business$productCategoriesArgs<ExtArgs>
    payments?: boolean | Business$paymentsArgs<ExtArgs>
    refundPolicies?: boolean | Business$refundPoliciesArgs<ExtArgs>
    refundRequests?: boolean | Business$refundRequestsArgs<ExtArgs>
    cancellationRequests?: boolean | Business$cancellationRequestsArgs<ExtArgs>
    subscriptionPlans?: boolean | Business$subscriptionPlansArgs<ExtArgs>
    subscriptions?: boolean | Business$subscriptionsArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    address?: boolean
    phone?: boolean
    website?: boolean
    email?: boolean
    logoUrl?: boolean
    coverUrl?: boolean
    latitude?: boolean
    longitude?: boolean
    zoneId?: boolean
    status?: boolean
    rating?: boolean
    tax_id?: boolean
    bank_iban?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    openingTime?: boolean
    closingTime?: boolean
    deliveryRadius?: boolean
    deliveryFee?: boolean
    facebook?: boolean
    instagram?: boolean
    twitter?: boolean
    type?: boolean
    tags?: boolean
    features?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | Business$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    address?: boolean
    phone?: boolean
    website?: boolean
    email?: boolean
    logoUrl?: boolean
    coverUrl?: boolean
    latitude?: boolean
    longitude?: boolean
    zoneId?: boolean
    status?: boolean
    rating?: boolean
    tax_id?: boolean
    bank_iban?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    openingTime?: boolean
    closingTime?: boolean
    deliveryRadius?: boolean
    deliveryFee?: boolean
    facebook?: boolean
    instagram?: boolean
    twitter?: boolean
    type?: boolean
    tags?: boolean
    features?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | Business$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    address?: boolean
    phone?: boolean
    website?: boolean
    email?: boolean
    logoUrl?: boolean
    coverUrl?: boolean
    latitude?: boolean
    longitude?: boolean
    zoneId?: boolean
    status?: boolean
    rating?: boolean
    tax_id?: boolean
    bank_iban?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    openingTime?: boolean
    closingTime?: boolean
    deliveryRadius?: boolean
    deliveryFee?: boolean
    facebook?: boolean
    instagram?: boolean
    twitter?: boolean
    type?: boolean
    tags?: boolean
    features?: boolean
  }

  export type BusinessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "description" | "address" | "phone" | "website" | "email" | "logoUrl" | "coverUrl" | "latitude" | "longitude" | "zoneId" | "status" | "rating" | "tax_id" | "bank_iban" | "createdAt" | "updatedAt" | "openingTime" | "closingTime" | "deliveryRadius" | "deliveryFee" | "facebook" | "instagram" | "twitter" | "type" | "tags" | "features", ExtArgs["result"]["business"]>
  export type BusinessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | Business$zoneArgs<ExtArgs>
    inventory?: boolean | Business$inventoryArgs<ExtArgs>
    orders?: boolean | Business$ordersArgs<ExtArgs>
    menuItems?: boolean | Business$menuItemsArgs<ExtArgs>
    productCategories?: boolean | Business$productCategoriesArgs<ExtArgs>
    payments?: boolean | Business$paymentsArgs<ExtArgs>
    refundPolicies?: boolean | Business$refundPoliciesArgs<ExtArgs>
    refundRequests?: boolean | Business$refundRequestsArgs<ExtArgs>
    cancellationRequests?: boolean | Business$cancellationRequestsArgs<ExtArgs>
    subscriptionPlans?: boolean | Business$subscriptionPlansArgs<ExtArgs>
    subscriptions?: boolean | Business$subscriptionsArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | Business$zoneArgs<ExtArgs>
  }
  export type BusinessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | Business$zoneArgs<ExtArgs>
  }

  export type $BusinessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Business"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs> | null
      inventory: Prisma.$InventoryPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      menuItems: Prisma.$MenuItemPayload<ExtArgs>[]
      productCategories: Prisma.$ProductCategoryPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      refundPolicies: Prisma.$RefundPolicyPayload<ExtArgs>[]
      refundRequests: Prisma.$RefundRequestPayload<ExtArgs>[]
      cancellationRequests: Prisma.$CancellationRequestPayload<ExtArgs>[]
      subscriptionPlans: Prisma.$SubscriptionPlanPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      address: string | null
      phone: string | null
      website: string | null
      email: string | null
      logoUrl: string | null
      coverUrl: string | null
      latitude: number | null
      longitude: number | null
      zoneId: string | null
      status: $Enums.Status
      rating: number | null
      tax_id: string | null
      bank_iban: string | null
      createdAt: Date
      updatedAt: Date
      openingTime: string | null
      closingTime: string | null
      deliveryRadius: number | null
      deliveryFee: number | null
      facebook: string | null
      instagram: string | null
      twitter: string | null
      type: string | null
      tags: string[]
      features: string[]
    }, ExtArgs["result"]["business"]>
    composites: {}
  }

  type BusinessGetPayload<S extends boolean | null | undefined | BusinessDefaultArgs> = $Result.GetResult<Prisma.$BusinessPayload, S>

  type BusinessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessCountAggregateInputType | true
    }

  export interface BusinessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Business'], meta: { name: 'Business' } }
    /**
     * Find zero or one Business that matches the filter.
     * @param {BusinessFindUniqueArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessFindUniqueArgs>(args: SelectSubset<T, BusinessFindUniqueArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Business that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessFindUniqueOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Business that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessFindFirstArgs>(args?: SelectSubset<T, BusinessFindFirstArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Business that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Businesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Businesses
     * const businesses = await prisma.business.findMany()
     * 
     * // Get first 10 Businesses
     * const businesses = await prisma.business.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessWithIdOnly = await prisma.business.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessFindManyArgs>(args?: SelectSubset<T, BusinessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Business.
     * @param {BusinessCreateArgs} args - Arguments to create a Business.
     * @example
     * // Create one Business
     * const Business = await prisma.business.create({
     *   data: {
     *     // ... data to create a Business
     *   }
     * })
     * 
     */
    create<T extends BusinessCreateArgs>(args: SelectSubset<T, BusinessCreateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Businesses.
     * @param {BusinessCreateManyArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessCreateManyArgs>(args?: SelectSubset<T, BusinessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Businesses and returns the data saved in the database.
     * @param {BusinessCreateManyAndReturnArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Businesses and only return the `id`
     * const businessWithIdOnly = await prisma.business.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Business.
     * @param {BusinessDeleteArgs} args - Arguments to delete one Business.
     * @example
     * // Delete one Business
     * const Business = await prisma.business.delete({
     *   where: {
     *     // ... filter to delete one Business
     *   }
     * })
     * 
     */
    delete<T extends BusinessDeleteArgs>(args: SelectSubset<T, BusinessDeleteArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Business.
     * @param {BusinessUpdateArgs} args - Arguments to update one Business.
     * @example
     * // Update one Business
     * const business = await prisma.business.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessUpdateArgs>(args: SelectSubset<T, BusinessUpdateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Businesses.
     * @param {BusinessDeleteManyArgs} args - Arguments to filter Businesses to delete.
     * @example
     * // Delete a few Businesses
     * const { count } = await prisma.business.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessDeleteManyArgs>(args?: SelectSubset<T, BusinessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Businesses
     * const business = await prisma.business.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessUpdateManyArgs>(args: SelectSubset<T, BusinessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Businesses and returns the data updated in the database.
     * @param {BusinessUpdateManyAndReturnArgs} args - Arguments to update many Businesses.
     * @example
     * // Update many Businesses
     * const business = await prisma.business.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Businesses and only return the `id`
     * const businessWithIdOnly = await prisma.business.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Business.
     * @param {BusinessUpsertArgs} args - Arguments to update or create a Business.
     * @example
     * // Update or create a Business
     * const business = await prisma.business.upsert({
     *   create: {
     *     // ... data to create a Business
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Business we want to update
     *   }
     * })
     */
    upsert<T extends BusinessUpsertArgs>(args: SelectSubset<T, BusinessUpsertArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCountArgs} args - Arguments to filter Businesses to count.
     * @example
     * // Count the number of Businesses
     * const count = await prisma.business.count({
     *   where: {
     *     // ... the filter for the Businesses we want to count
     *   }
     * })
    **/
    count<T extends BusinessCountArgs>(
      args?: Subset<T, BusinessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessAggregateArgs>(args: Subset<T, BusinessAggregateArgs>): Prisma.PrismaPromise<GetBusinessAggregateType<T>>

    /**
     * Group by Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessGroupByArgs['orderBy'] }
        : { orderBy?: BusinessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Business model
   */
  readonly fields: BusinessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Business.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    zone<T extends Business$zoneArgs<ExtArgs> = {}>(args?: Subset<T, Business$zoneArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inventory<T extends Business$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Business$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Business$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Business$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    menuItems<T extends Business$menuItemsArgs<ExtArgs> = {}>(args?: Subset<T, Business$menuItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productCategories<T extends Business$productCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Business$productCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Business$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Business$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refundPolicies<T extends Business$refundPoliciesArgs<ExtArgs> = {}>(args?: Subset<T, Business$refundPoliciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refundRequests<T extends Business$refundRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Business$refundRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cancellationRequests<T extends Business$cancellationRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Business$cancellationRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptionPlans<T extends Business$subscriptionPlansArgs<ExtArgs> = {}>(args?: Subset<T, Business$subscriptionPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Business$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Business$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Business model
   */
  interface BusinessFieldRefs {
    readonly id: FieldRef<"Business", 'String'>
    readonly userId: FieldRef<"Business", 'String'>
    readonly name: FieldRef<"Business", 'String'>
    readonly description: FieldRef<"Business", 'String'>
    readonly address: FieldRef<"Business", 'String'>
    readonly phone: FieldRef<"Business", 'String'>
    readonly website: FieldRef<"Business", 'String'>
    readonly email: FieldRef<"Business", 'String'>
    readonly logoUrl: FieldRef<"Business", 'String'>
    readonly coverUrl: FieldRef<"Business", 'String'>
    readonly latitude: FieldRef<"Business", 'Float'>
    readonly longitude: FieldRef<"Business", 'Float'>
    readonly zoneId: FieldRef<"Business", 'String'>
    readonly status: FieldRef<"Business", 'Status'>
    readonly rating: FieldRef<"Business", 'Float'>
    readonly tax_id: FieldRef<"Business", 'String'>
    readonly bank_iban: FieldRef<"Business", 'String'>
    readonly createdAt: FieldRef<"Business", 'DateTime'>
    readonly updatedAt: FieldRef<"Business", 'DateTime'>
    readonly openingTime: FieldRef<"Business", 'String'>
    readonly closingTime: FieldRef<"Business", 'String'>
    readonly deliveryRadius: FieldRef<"Business", 'Float'>
    readonly deliveryFee: FieldRef<"Business", 'Float'>
    readonly facebook: FieldRef<"Business", 'String'>
    readonly instagram: FieldRef<"Business", 'String'>
    readonly twitter: FieldRef<"Business", 'String'>
    readonly type: FieldRef<"Business", 'String'>
    readonly tags: FieldRef<"Business", 'String[]'>
    readonly features: FieldRef<"Business", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Business findUnique
   */
  export type BusinessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findUniqueOrThrow
   */
  export type BusinessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findFirst
   */
  export type BusinessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findFirstOrThrow
   */
  export type BusinessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findMany
   */
  export type BusinessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Businesses to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business create
   */
  export type BusinessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to create a Business.
     */
    data: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
  }

  /**
   * Business createMany
   */
  export type BusinessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Business createManyAndReturn
   */
  export type BusinessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Business update
   */
  export type BusinessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to update a Business.
     */
    data: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
    /**
     * Choose, which Business to update.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business updateMany
   */
  export type BusinessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Businesses.
     */
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Businesses to update
     */
    where?: BusinessWhereInput
    /**
     * Limit how many Businesses to update.
     */
    limit?: number
  }

  /**
   * Business updateManyAndReturn
   */
  export type BusinessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * The data used to update Businesses.
     */
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Businesses to update
     */
    where?: BusinessWhereInput
    /**
     * Limit how many Businesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Business upsert
   */
  export type BusinessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The filter to search for the Business to update in case it exists.
     */
    where: BusinessWhereUniqueInput
    /**
     * In case the Business found by the `where` argument doesn't exist, create a new Business with this data.
     */
    create: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
    /**
     * In case the Business was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
  }

  /**
   * Business delete
   */
  export type BusinessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter which Business to delete.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business deleteMany
   */
  export type BusinessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Businesses to delete
     */
    where?: BusinessWhereInput
    /**
     * Limit how many Businesses to delete.
     */
    limit?: number
  }

  /**
   * Business.zone
   */
  export type Business$zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
  }

  /**
   * Business.inventory
   */
  export type Business$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Business.orders
   */
  export type Business$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Business.menuItems
   */
  export type Business$menuItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    cursor?: MenuItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * Business.productCategories
   */
  export type Business$productCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Business.payments
   */
  export type Business$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Business.refundPolicies
   */
  export type Business$refundPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundPolicy
     */
    select?: RefundPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundPolicy
     */
    omit?: RefundPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundPolicyInclude<ExtArgs> | null
    where?: RefundPolicyWhereInput
    orderBy?: RefundPolicyOrderByWithRelationInput | RefundPolicyOrderByWithRelationInput[]
    cursor?: RefundPolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundPolicyScalarFieldEnum | RefundPolicyScalarFieldEnum[]
  }

  /**
   * Business.refundRequests
   */
  export type Business$refundRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    where?: RefundRequestWhereInput
    orderBy?: RefundRequestOrderByWithRelationInput | RefundRequestOrderByWithRelationInput[]
    cursor?: RefundRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundRequestScalarFieldEnum | RefundRequestScalarFieldEnum[]
  }

  /**
   * Business.cancellationRequests
   */
  export type Business$cancellationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestInclude<ExtArgs> | null
    where?: CancellationRequestWhereInput
    orderBy?: CancellationRequestOrderByWithRelationInput | CancellationRequestOrderByWithRelationInput[]
    cursor?: CancellationRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CancellationRequestScalarFieldEnum | CancellationRequestScalarFieldEnum[]
  }

  /**
   * Business.subscriptionPlans
   */
  export type Business$subscriptionPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    where?: SubscriptionPlanWhereInput
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    cursor?: SubscriptionPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * Business.subscriptions
   */
  export type Business$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Business without action
   */
  export type BusinessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
  }


  /**
   * Model Zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneAvgAggregateOutputType = {
    averageDeliveryTime: number | null
    orderVolume: number | null
    activeBusinesses: number | null
  }

  export type ZoneSumAggregateOutputType = {
    averageDeliveryTime: number | null
    orderVolume: number | null
    activeBusinesses: number | null
  }

  export type ZoneMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    averageDeliveryTime: number | null
    orderVolume: number | null
    activeBusinesses: number | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    averageDeliveryTime: number | null
    orderVolume: number | null
    activeBusinesses: number | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    name: number
    description: number
    coordinates: number
    createdAt: number
    updatedAt: number
    averageDeliveryTime: number
    orderVolume: number
    activeBusinesses: number
    _all: number
  }


  export type ZoneAvgAggregateInputType = {
    averageDeliveryTime?: true
    orderVolume?: true
    activeBusinesses?: true
  }

  export type ZoneSumAggregateInputType = {
    averageDeliveryTime?: true
    orderVolume?: true
    activeBusinesses?: true
  }

  export type ZoneMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    averageDeliveryTime?: true
    orderVolume?: true
    activeBusinesses?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    averageDeliveryTime?: true
    orderVolume?: true
    activeBusinesses?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    coordinates?: true
    createdAt?: true
    updatedAt?: true
    averageDeliveryTime?: true
    orderVolume?: true
    activeBusinesses?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zone to aggregate.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type ZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithAggregationInput | ZoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: ZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _avg?: ZoneAvgAggregateInputType
    _sum?: ZoneSumAggregateInputType
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: string
    name: string
    description: string | null
    coordinates: JsonValue
    createdAt: Date
    updatedAt: Date
    averageDeliveryTime: number | null
    orderVolume: number | null
    activeBusinesses: number | null
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends ZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type ZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    coordinates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    averageDeliveryTime?: boolean
    orderVolume?: boolean
    activeBusinesses?: boolean
    businesses?: boolean | Zone$businessesArgs<ExtArgs>
    couriers?: boolean | Zone$couriersArgs<ExtArgs>
    deliveries?: boolean | Zone$deliveriesArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    coordinates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    averageDeliveryTime?: boolean
    orderVolume?: boolean
    activeBusinesses?: boolean
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    coordinates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    averageDeliveryTime?: boolean
    orderVolume?: boolean
    activeBusinesses?: boolean
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    coordinates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    averageDeliveryTime?: boolean
    orderVolume?: boolean
    activeBusinesses?: boolean
  }

  export type ZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "coordinates" | "createdAt" | "updatedAt" | "averageDeliveryTime" | "orderVolume" | "activeBusinesses", ExtArgs["result"]["zone"]>
  export type ZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businesses?: boolean | Zone$businessesArgs<ExtArgs>
    couriers?: boolean | Zone$couriersArgs<ExtArgs>
    deliveries?: boolean | Zone$deliveriesArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ZoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Zone"
    objects: {
      businesses: Prisma.$BusinessPayload<ExtArgs>[]
      couriers: Prisma.$CourierPayload<ExtArgs>[]
      deliveries: Prisma.$DeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      coordinates: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      averageDeliveryTime: number | null
      orderVolume: number | null
      activeBusinesses: number | null
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type ZoneGetPayload<S extends boolean | null | undefined | ZoneDefaultArgs> = $Result.GetResult<Prisma.$ZonePayload, S>

  type ZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface ZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Zone'], meta: { name: 'Zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {ZoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneFindUniqueArgs>(args: SelectSubset<T, ZoneFindUniqueArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneFindFirstArgs>(args?: SelectSubset<T, ZoneFindFirstArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZoneFindManyArgs>(args?: SelectSubset<T, ZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zone.
     * @param {ZoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends ZoneCreateArgs>(args: SelectSubset<T, ZoneCreateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zones.
     * @param {ZoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneCreateManyArgs>(args?: SelectSubset<T, ZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {ZoneCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Zone.
     * @param {ZoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends ZoneDeleteArgs>(args: SelectSubset<T, ZoneDeleteArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zone.
     * @param {ZoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneUpdateArgs>(args: SelectSubset<T, ZoneUpdateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zones.
     * @param {ZoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneDeleteManyArgs>(args?: SelectSubset<T, ZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneUpdateManyArgs>(args: SelectSubset<T, ZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones and returns the data updated in the database.
     * @param {ZoneUpdateManyAndReturnArgs} args - Arguments to update many Zones.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZoneUpdateManyAndReturnArgs>(args: SelectSubset<T, ZoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Zone.
     * @param {ZoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends ZoneUpsertArgs>(args: SelectSubset<T, ZoneUpsertArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends ZoneCountArgs>(
      args?: Subset<T, ZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneGroupByArgs['orderBy'] }
        : { orderBy?: ZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Zone model
   */
  readonly fields: ZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businesses<T extends Zone$businessesArgs<ExtArgs> = {}>(args?: Subset<T, Zone$businessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    couriers<T extends Zone$couriersArgs<ExtArgs> = {}>(args?: Subset<T, Zone$couriersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveries<T extends Zone$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Zone$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Zone model
   */
  interface ZoneFieldRefs {
    readonly id: FieldRef<"Zone", 'String'>
    readonly name: FieldRef<"Zone", 'String'>
    readonly description: FieldRef<"Zone", 'String'>
    readonly coordinates: FieldRef<"Zone", 'Json'>
    readonly createdAt: FieldRef<"Zone", 'DateTime'>
    readonly updatedAt: FieldRef<"Zone", 'DateTime'>
    readonly averageDeliveryTime: FieldRef<"Zone", 'Int'>
    readonly orderVolume: FieldRef<"Zone", 'Int'>
    readonly activeBusinesses: FieldRef<"Zone", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Zone findUnique
   */
  export type ZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findUniqueOrThrow
   */
  export type ZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findFirst
   */
  export type ZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findFirstOrThrow
   */
  export type ZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findMany
   */
  export type ZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zones to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone create
   */
  export type ZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Zone.
     */
    data: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
  }

  /**
   * Zone createMany
   */
  export type ZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone createManyAndReturn
   */
  export type ZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone update
   */
  export type ZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Zone.
     */
    data: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
    /**
     * Choose, which Zone to update.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone updateMany
   */
  export type ZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to update.
     */
    limit?: number
  }

  /**
   * Zone updateManyAndReturn
   */
  export type ZoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to update.
     */
    limit?: number
  }

  /**
   * Zone upsert
   */
  export type ZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Zone to update in case it exists.
     */
    where: ZoneWhereUniqueInput
    /**
     * In case the Zone found by the `where` argument doesn't exist, create a new Zone with this data.
     */
    create: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
    /**
     * In case the Zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
  }

  /**
   * Zone delete
   */
  export type ZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter which Zone to delete.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone deleteMany
   */
  export type ZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zones to delete
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to delete.
     */
    limit?: number
  }

  /**
   * Zone.businesses
   */
  export type Zone$businessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    cursor?: BusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Zone.couriers
   */
  export type Zone$couriersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    where?: CourierWhereInput
    orderBy?: CourierOrderByWithRelationInput | CourierOrderByWithRelationInput[]
    cursor?: CourierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourierScalarFieldEnum | CourierScalarFieldEnum[]
  }

  /**
   * Zone.deliveries
   */
  export type Zone$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Zone without action
   */
  export type ZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courierId: string | null
    type: $Enums.NotificationType | null
    channel: $Enums.NotificationChannel | null
    frequency: $Enums.NotificationFrequency | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courierId: string | null
    type: $Enums.NotificationType | null
    channel: $Enums.NotificationChannel | null
    frequency: $Enums.NotificationFrequency | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    courierId: number
    type: number
    channel: number
    frequency: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    courierId?: true
    type?: true
    channel?: true
    frequency?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    courierId?: true
    type?: true
    channel?: true
    frequency?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    courierId?: true
    type?: true
    channel?: true
    frequency?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: string
    userId: string
    courierId: string | null
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
    frequency: $Enums.NotificationFrequency
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courierId?: boolean
    type?: boolean
    channel?: boolean
    frequency?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    courier?: boolean | NotificationPreference$courierArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courierId?: boolean
    type?: boolean
    channel?: boolean
    frequency?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    courier?: boolean | NotificationPreference$courierArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courierId?: boolean
    type?: boolean
    channel?: boolean
    frequency?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    courier?: boolean | NotificationPreference$courierArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    courierId?: boolean
    type?: boolean
    channel?: boolean
    frequency?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courierId" | "type" | "channel" | "frequency" | "enabled" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPreference"]>
  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    courier?: boolean | NotificationPreference$courierArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    courier?: boolean | NotificationPreference$courierArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    courier?: boolean | NotificationPreference$courierArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      courier: Prisma.$CourierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courierId: string | null
      type: $Enums.NotificationType
      channel: $Enums.NotificationChannel
      frequency: $Enums.NotificationFrequency
      enabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences and returns the data updated in the database.
     * @param {NotificationPreferenceUpdateManyAndReturnArgs} args - Arguments to update many NotificationPreferences.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    courier<T extends NotificationPreference$courierArgs<ExtArgs> = {}>(args?: Subset<T, NotificationPreference$courierArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'String'>
    readonly userId: FieldRef<"NotificationPreference", 'String'>
    readonly courierId: FieldRef<"NotificationPreference", 'String'>
    readonly type: FieldRef<"NotificationPreference", 'NotificationType'>
    readonly channel: FieldRef<"NotificationPreference", 'NotificationChannel'>
    readonly frequency: FieldRef<"NotificationPreference", 'NotificationFrequency'>
    readonly enabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
  }

  /**
   * NotificationPreference updateManyAndReturn
   */
  export type NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to delete.
     */
    limit?: number
  }

  /**
   * NotificationPreference.courier
   */
  export type NotificationPreference$courierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    where?: CourierWhereInput
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    createdAt: Date | null
    userId: string | null
    courierId: string | null
    orderId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    createdAt: Date | null
    userId: string | null
    courierId: string | null
    orderId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    content: number
    type: number
    isRead: number
    createdAt: number
    userId: number
    courierId: number
    orderId: number
    metadata: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    isRead?: true
    createdAt?: true
    userId?: true
    courierId?: true
    orderId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    isRead?: true
    createdAt?: true
    userId?: true
    courierId?: true
    orderId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    isRead?: true
    createdAt?: true
    userId?: true
    courierId?: true
    orderId?: true
    metadata?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    content: string
    type: $Enums.NotificationType
    isRead: boolean
    createdAt: Date
    userId: string
    courierId: string | null
    orderId: string | null
    metadata: JsonValue | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    courierId?: boolean
    orderId?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    courier?: boolean | Notification$courierArgs<ExtArgs>
    order?: boolean | Notification$orderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    courierId?: boolean
    orderId?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    courier?: boolean | Notification$courierArgs<ExtArgs>
    order?: boolean | Notification$orderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    courierId?: boolean
    orderId?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    courier?: boolean | Notification$courierArgs<ExtArgs>
    order?: boolean | Notification$orderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    courierId?: boolean
    orderId?: boolean
    metadata?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "type" | "isRead" | "createdAt" | "userId" | "courierId" | "orderId" | "metadata", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    courier?: boolean | Notification$courierArgs<ExtArgs>
    order?: boolean | Notification$orderArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    courier?: boolean | Notification$courierArgs<ExtArgs>
    order?: boolean | Notification$orderArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    courier?: boolean | Notification$courierArgs<ExtArgs>
    order?: boolean | Notification$orderArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      courier: Prisma.$CourierPayload<ExtArgs> | null
      order: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      type: $Enums.NotificationType
      isRead: boolean
      createdAt: Date
      userId: string
      courierId: string | null
      orderId: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    courier<T extends Notification$courierArgs<ExtArgs> = {}>(args?: Subset<T, Notification$courierArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends Notification$orderArgs<ExtArgs> = {}>(args?: Subset<T, Notification$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly courierId: FieldRef<"Notification", 'String'>
    readonly orderId: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.courier
   */
  export type Notification$courierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    where?: CourierWhereInput
  }

  /**
   * Notification.order
   */
  export type Notification$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Delivery
   */

  export type AggregateDelivery = {
    _count: DeliveryCountAggregateOutputType | null
    _avg: DeliveryAvgAggregateOutputType | null
    _sum: DeliverySumAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  export type DeliveryAvgAggregateOutputType = {
    duration: number | null
    actualDuration: number | null
    distance: number | null
    actualDistance: number | null
    pickupLatitude: number | null
    pickupLongitude: number | null
    dropoffLatitude: number | null
    dropoffLongitude: number | null
    sequenceNumber: number | null
  }

  export type DeliverySumAggregateOutputType = {
    duration: number | null
    actualDuration: number | null
    distance: number | null
    actualDistance: number | null
    pickupLatitude: number | null
    pickupLongitude: number | null
    dropoffLatitude: number | null
    dropoffLongitude: number | null
    sequenceNumber: number | null
  }

  export type DeliveryMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    courierId: string | null
    customerId: string | null
    zoneId: string | null
    orderId: string | null
    assignedAt: Date | null
    pickedUpAt: Date | null
    deliveredAt: Date | null
    estimatedPickupTime: Date | null
    estimatedDeliveryTime: Date | null
    duration: number | null
    actualDuration: number | null
    distance: number | null
    actualDistance: number | null
    pickupLatitude: number | null
    pickupLongitude: number | null
    dropoffLatitude: number | null
    dropoffLongitude: number | null
    routeId: string | null
    sequenceNumber: number | null
    priority: $Enums.DeliveryPriority | null
  }

  export type DeliveryMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    courierId: string | null
    customerId: string | null
    zoneId: string | null
    orderId: string | null
    assignedAt: Date | null
    pickedUpAt: Date | null
    deliveredAt: Date | null
    estimatedPickupTime: Date | null
    estimatedDeliveryTime: Date | null
    duration: number | null
    actualDuration: number | null
    distance: number | null
    actualDistance: number | null
    pickupLatitude: number | null
    pickupLongitude: number | null
    dropoffLatitude: number | null
    dropoffLongitude: number | null
    routeId: string | null
    sequenceNumber: number | null
    priority: $Enums.DeliveryPriority | null
  }

  export type DeliveryCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    courierId: number
    customerId: number
    zoneId: number
    orderId: number
    assignedAt: number
    pickedUpAt: number
    deliveredAt: number
    estimatedPickupTime: number
    estimatedDeliveryTime: number
    duration: number
    actualDuration: number
    distance: number
    actualDistance: number
    pickupLatitude: number
    pickupLongitude: number
    dropoffLatitude: number
    dropoffLongitude: number
    routeId: number
    sequenceNumber: number
    priority: number
    _all: number
  }


  export type DeliveryAvgAggregateInputType = {
    duration?: true
    actualDuration?: true
    distance?: true
    actualDistance?: true
    pickupLatitude?: true
    pickupLongitude?: true
    dropoffLatitude?: true
    dropoffLongitude?: true
    sequenceNumber?: true
  }

  export type DeliverySumAggregateInputType = {
    duration?: true
    actualDuration?: true
    distance?: true
    actualDistance?: true
    pickupLatitude?: true
    pickupLongitude?: true
    dropoffLatitude?: true
    dropoffLongitude?: true
    sequenceNumber?: true
  }

  export type DeliveryMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    courierId?: true
    customerId?: true
    zoneId?: true
    orderId?: true
    assignedAt?: true
    pickedUpAt?: true
    deliveredAt?: true
    estimatedPickupTime?: true
    estimatedDeliveryTime?: true
    duration?: true
    actualDuration?: true
    distance?: true
    actualDistance?: true
    pickupLatitude?: true
    pickupLongitude?: true
    dropoffLatitude?: true
    dropoffLongitude?: true
    routeId?: true
    sequenceNumber?: true
    priority?: true
  }

  export type DeliveryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    courierId?: true
    customerId?: true
    zoneId?: true
    orderId?: true
    assignedAt?: true
    pickedUpAt?: true
    deliveredAt?: true
    estimatedPickupTime?: true
    estimatedDeliveryTime?: true
    duration?: true
    actualDuration?: true
    distance?: true
    actualDistance?: true
    pickupLatitude?: true
    pickupLongitude?: true
    dropoffLatitude?: true
    dropoffLongitude?: true
    routeId?: true
    sequenceNumber?: true
    priority?: true
  }

  export type DeliveryCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    courierId?: true
    customerId?: true
    zoneId?: true
    orderId?: true
    assignedAt?: true
    pickedUpAt?: true
    deliveredAt?: true
    estimatedPickupTime?: true
    estimatedDeliveryTime?: true
    duration?: true
    actualDuration?: true
    distance?: true
    actualDistance?: true
    pickupLatitude?: true
    pickupLongitude?: true
    dropoffLatitude?: true
    dropoffLongitude?: true
    routeId?: true
    sequenceNumber?: true
    priority?: true
    _all?: true
  }

  export type DeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delivery to aggregate.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deliveries
    **/
    _count?: true | DeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryMaxAggregateInputType
  }

  export type GetDeliveryAggregateType<T extends DeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelivery[P]>
      : GetScalarType<T[P], AggregateDelivery[P]>
  }




  export type DeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithAggregationInput | DeliveryOrderByWithAggregationInput[]
    by: DeliveryScalarFieldEnum[] | DeliveryScalarFieldEnum
    having?: DeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryCountAggregateInputType | true
    _avg?: DeliveryAvgAggregateInputType
    _sum?: DeliverySumAggregateInputType
    _min?: DeliveryMinAggregateInputType
    _max?: DeliveryMaxAggregateInputType
  }

  export type DeliveryGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    status: string
    courierId: string
    customerId: string
    zoneId: string
    orderId: string | null
    assignedAt: Date | null
    pickedUpAt: Date | null
    deliveredAt: Date | null
    estimatedPickupTime: Date | null
    estimatedDeliveryTime: Date | null
    duration: number | null
    actualDuration: number | null
    distance: number | null
    actualDistance: number | null
    pickupLatitude: number | null
    pickupLongitude: number | null
    dropoffLatitude: number | null
    dropoffLongitude: number | null
    routeId: string | null
    sequenceNumber: number | null
    priority: $Enums.DeliveryPriority
    _count: DeliveryCountAggregateOutputType | null
    _avg: DeliveryAvgAggregateOutputType | null
    _sum: DeliverySumAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  type GetDeliveryGroupByPayload<T extends DeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
        }
      >
    >


  export type DeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    courierId?: boolean
    customerId?: boolean
    zoneId?: boolean
    orderId?: boolean
    assignedAt?: boolean
    pickedUpAt?: boolean
    deliveredAt?: boolean
    estimatedPickupTime?: boolean
    estimatedDeliveryTime?: boolean
    duration?: boolean
    actualDuration?: boolean
    distance?: boolean
    actualDistance?: boolean
    pickupLatitude?: boolean
    pickupLongitude?: boolean
    dropoffLatitude?: boolean
    dropoffLongitude?: boolean
    routeId?: boolean
    sequenceNumber?: boolean
    priority?: boolean
    courier?: boolean | CourierDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    order?: boolean | Delivery$orderArgs<ExtArgs>
    route?: boolean | Delivery$routeArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    courierId?: boolean
    customerId?: boolean
    zoneId?: boolean
    orderId?: boolean
    assignedAt?: boolean
    pickedUpAt?: boolean
    deliveredAt?: boolean
    estimatedPickupTime?: boolean
    estimatedDeliveryTime?: boolean
    duration?: boolean
    actualDuration?: boolean
    distance?: boolean
    actualDistance?: boolean
    pickupLatitude?: boolean
    pickupLongitude?: boolean
    dropoffLatitude?: boolean
    dropoffLongitude?: boolean
    routeId?: boolean
    sequenceNumber?: boolean
    priority?: boolean
    courier?: boolean | CourierDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    order?: boolean | Delivery$orderArgs<ExtArgs>
    route?: boolean | Delivery$routeArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    courierId?: boolean
    customerId?: boolean
    zoneId?: boolean
    orderId?: boolean
    assignedAt?: boolean
    pickedUpAt?: boolean
    deliveredAt?: boolean
    estimatedPickupTime?: boolean
    estimatedDeliveryTime?: boolean
    duration?: boolean
    actualDuration?: boolean
    distance?: boolean
    actualDistance?: boolean
    pickupLatitude?: boolean
    pickupLongitude?: boolean
    dropoffLatitude?: boolean
    dropoffLongitude?: boolean
    routeId?: boolean
    sequenceNumber?: boolean
    priority?: boolean
    courier?: boolean | CourierDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    order?: boolean | Delivery$orderArgs<ExtArgs>
    route?: boolean | Delivery$routeArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    courierId?: boolean
    customerId?: boolean
    zoneId?: boolean
    orderId?: boolean
    assignedAt?: boolean
    pickedUpAt?: boolean
    deliveredAt?: boolean
    estimatedPickupTime?: boolean
    estimatedDeliveryTime?: boolean
    duration?: boolean
    actualDuration?: boolean
    distance?: boolean
    actualDistance?: boolean
    pickupLatitude?: boolean
    pickupLongitude?: boolean
    dropoffLatitude?: boolean
    dropoffLongitude?: boolean
    routeId?: boolean
    sequenceNumber?: boolean
    priority?: boolean
  }

  export type DeliveryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "status" | "courierId" | "customerId" | "zoneId" | "orderId" | "assignedAt" | "pickedUpAt" | "deliveredAt" | "estimatedPickupTime" | "estimatedDeliveryTime" | "duration" | "actualDuration" | "distance" | "actualDistance" | "pickupLatitude" | "pickupLongitude" | "dropoffLatitude" | "dropoffLongitude" | "routeId" | "sequenceNumber" | "priority", ExtArgs["result"]["delivery"]>
  export type DeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courier?: boolean | CourierDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    order?: boolean | Delivery$orderArgs<ExtArgs>
    route?: boolean | Delivery$routeArgs<ExtArgs>
  }
  export type DeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courier?: boolean | CourierDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    order?: boolean | Delivery$orderArgs<ExtArgs>
    route?: boolean | Delivery$routeArgs<ExtArgs>
  }
  export type DeliveryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courier?: boolean | CourierDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    order?: boolean | Delivery$orderArgs<ExtArgs>
    route?: boolean | Delivery$routeArgs<ExtArgs>
  }

  export type $DeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Delivery"
    objects: {
      courier: Prisma.$CourierPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
      route: Prisma.$DeliveryRoutePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      status: string
      courierId: string
      customerId: string
      zoneId: string
      orderId: string | null
      assignedAt: Date | null
      pickedUpAt: Date | null
      deliveredAt: Date | null
      estimatedPickupTime: Date | null
      estimatedDeliveryTime: Date | null
      duration: number | null
      actualDuration: number | null
      distance: number | null
      actualDistance: number | null
      pickupLatitude: number | null
      pickupLongitude: number | null
      dropoffLatitude: number | null
      dropoffLongitude: number | null
      routeId: string | null
      sequenceNumber: number | null
      priority: $Enums.DeliveryPriority
    }, ExtArgs["result"]["delivery"]>
    composites: {}
  }

  type DeliveryGetPayload<S extends boolean | null | undefined | DeliveryDefaultArgs> = $Result.GetResult<Prisma.$DeliveryPayload, S>

  type DeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryCountAggregateInputType | true
    }

  export interface DeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Delivery'], meta: { name: 'Delivery' } }
    /**
     * Find zero or one Delivery that matches the filter.
     * @param {DeliveryFindUniqueArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryFindUniqueArgs>(args: SelectSubset<T, DeliveryFindUniqueArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Delivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryFindUniqueOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryFindFirstArgs>(args?: SelectSubset<T, DeliveryFindFirstArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deliveries
     * const deliveries = await prisma.delivery.findMany()
     * 
     * // Get first 10 Deliveries
     * const deliveries = await prisma.delivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryWithIdOnly = await prisma.delivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryFindManyArgs>(args?: SelectSubset<T, DeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Delivery.
     * @param {DeliveryCreateArgs} args - Arguments to create a Delivery.
     * @example
     * // Create one Delivery
     * const Delivery = await prisma.delivery.create({
     *   data: {
     *     // ... data to create a Delivery
     *   }
     * })
     * 
     */
    create<T extends DeliveryCreateArgs>(args: SelectSubset<T, DeliveryCreateArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deliveries.
     * @param {DeliveryCreateManyArgs} args - Arguments to create many Deliveries.
     * @example
     * // Create many Deliveries
     * const delivery = await prisma.delivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryCreateManyArgs>(args?: SelectSubset<T, DeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deliveries and returns the data saved in the database.
     * @param {DeliveryCreateManyAndReturnArgs} args - Arguments to create many Deliveries.
     * @example
     * // Create many Deliveries
     * const delivery = await prisma.delivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deliveries and only return the `id`
     * const deliveryWithIdOnly = await prisma.delivery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Delivery.
     * @param {DeliveryDeleteArgs} args - Arguments to delete one Delivery.
     * @example
     * // Delete one Delivery
     * const Delivery = await prisma.delivery.delete({
     *   where: {
     *     // ... filter to delete one Delivery
     *   }
     * })
     * 
     */
    delete<T extends DeliveryDeleteArgs>(args: SelectSubset<T, DeliveryDeleteArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Delivery.
     * @param {DeliveryUpdateArgs} args - Arguments to update one Delivery.
     * @example
     * // Update one Delivery
     * const delivery = await prisma.delivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryUpdateArgs>(args: SelectSubset<T, DeliveryUpdateArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deliveries.
     * @param {DeliveryDeleteManyArgs} args - Arguments to filter Deliveries to delete.
     * @example
     * // Delete a few Deliveries
     * const { count } = await prisma.delivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryDeleteManyArgs>(args?: SelectSubset<T, DeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deliveries
     * const delivery = await prisma.delivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryUpdateManyArgs>(args: SelectSubset<T, DeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveries and returns the data updated in the database.
     * @param {DeliveryUpdateManyAndReturnArgs} args - Arguments to update many Deliveries.
     * @example
     * // Update many Deliveries
     * const delivery = await prisma.delivery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deliveries and only return the `id`
     * const deliveryWithIdOnly = await prisma.delivery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Delivery.
     * @param {DeliveryUpsertArgs} args - Arguments to update or create a Delivery.
     * @example
     * // Update or create a Delivery
     * const delivery = await prisma.delivery.upsert({
     *   create: {
     *     // ... data to create a Delivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delivery we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryUpsertArgs>(args: SelectSubset<T, DeliveryUpsertArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryCountArgs} args - Arguments to filter Deliveries to count.
     * @example
     * // Count the number of Deliveries
     * const count = await prisma.delivery.count({
     *   where: {
     *     // ... the filter for the Deliveries we want to count
     *   }
     * })
    **/
    count<T extends DeliveryCountArgs>(
      args?: Subset<T, DeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryAggregateArgs>(args: Subset<T, DeliveryAggregateArgs>): Prisma.PrismaPromise<GetDeliveryAggregateType<T>>

    /**
     * Group by Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Delivery model
   */
  readonly fields: DeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Delivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courier<T extends CourierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourierDefaultArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends Delivery$orderArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    route<T extends Delivery$routeArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$routeArgs<ExtArgs>>): Prisma__DeliveryRouteClient<$Result.GetResult<Prisma.$DeliveryRoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Delivery model
   */
  interface DeliveryFieldRefs {
    readonly id: FieldRef<"Delivery", 'String'>
    readonly createdAt: FieldRef<"Delivery", 'DateTime'>
    readonly updatedAt: FieldRef<"Delivery", 'DateTime'>
    readonly status: FieldRef<"Delivery", 'String'>
    readonly courierId: FieldRef<"Delivery", 'String'>
    readonly customerId: FieldRef<"Delivery", 'String'>
    readonly zoneId: FieldRef<"Delivery", 'String'>
    readonly orderId: FieldRef<"Delivery", 'String'>
    readonly assignedAt: FieldRef<"Delivery", 'DateTime'>
    readonly pickedUpAt: FieldRef<"Delivery", 'DateTime'>
    readonly deliveredAt: FieldRef<"Delivery", 'DateTime'>
    readonly estimatedPickupTime: FieldRef<"Delivery", 'DateTime'>
    readonly estimatedDeliveryTime: FieldRef<"Delivery", 'DateTime'>
    readonly duration: FieldRef<"Delivery", 'Int'>
    readonly actualDuration: FieldRef<"Delivery", 'Int'>
    readonly distance: FieldRef<"Delivery", 'Float'>
    readonly actualDistance: FieldRef<"Delivery", 'Float'>
    readonly pickupLatitude: FieldRef<"Delivery", 'Float'>
    readonly pickupLongitude: FieldRef<"Delivery", 'Float'>
    readonly dropoffLatitude: FieldRef<"Delivery", 'Float'>
    readonly dropoffLongitude: FieldRef<"Delivery", 'Float'>
    readonly routeId: FieldRef<"Delivery", 'String'>
    readonly sequenceNumber: FieldRef<"Delivery", 'Int'>
    readonly priority: FieldRef<"Delivery", 'DeliveryPriority'>
  }
    

  // Custom InputTypes
  /**
   * Delivery findUnique
   */
  export type DeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery findUniqueOrThrow
   */
  export type DeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery findFirst
   */
  export type DeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery findFirstOrThrow
   */
  export type DeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery findMany
   */
  export type DeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Deliveries to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery create
   */
  export type DeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a Delivery.
     */
    data: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
  }

  /**
   * Delivery createMany
   */
  export type DeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deliveries.
     */
    data: DeliveryCreateManyInput | DeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Delivery createManyAndReturn
   */
  export type DeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * The data used to create many Deliveries.
     */
    data: DeliveryCreateManyInput | DeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Delivery update
   */
  export type DeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a Delivery.
     */
    data: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
    /**
     * Choose, which Delivery to update.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery updateMany
   */
  export type DeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deliveries.
     */
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyInput>
    /**
     * Filter which Deliveries to update
     */
    where?: DeliveryWhereInput
    /**
     * Limit how many Deliveries to update.
     */
    limit?: number
  }

  /**
   * Delivery updateManyAndReturn
   */
  export type DeliveryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * The data used to update Deliveries.
     */
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyInput>
    /**
     * Filter which Deliveries to update
     */
    where?: DeliveryWhereInput
    /**
     * Limit how many Deliveries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Delivery upsert
   */
  export type DeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the Delivery to update in case it exists.
     */
    where: DeliveryWhereUniqueInput
    /**
     * In case the Delivery found by the `where` argument doesn't exist, create a new Delivery with this data.
     */
    create: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
    /**
     * In case the Delivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
  }

  /**
   * Delivery delete
   */
  export type DeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter which Delivery to delete.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery deleteMany
   */
  export type DeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deliveries to delete
     */
    where?: DeliveryWhereInput
    /**
     * Limit how many Deliveries to delete.
     */
    limit?: number
  }

  /**
   * Delivery.order
   */
  export type Delivery$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Delivery.route
   */
  export type Delivery$routeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRoute
     */
    select?: DeliveryRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryRoute
     */
    omit?: DeliveryRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryRouteInclude<ExtArgs> | null
    where?: DeliveryRouteWhereInput
  }

  /**
   * Delivery without action
   */
  export type DeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type InventorySumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    description: string | null
    quantity: number | null
    price: number | null
    sku: string | null
    imageUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: string | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    description: string | null
    quantity: number | null
    price: number | null
    sku: string | null
    imageUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: string | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    businessId: number
    name: number
    description: number
    quantity: number
    price: number
    sku: number
    imageUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    categoryId: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type InventorySumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    quantity?: true
    price?: true
    sku?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    quantity?: true
    price?: true
    sku?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    quantity?: true
    price?: true
    sku?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: string
    businessId: string
    name: string
    description: string | null
    quantity: number
    price: number
    sku: string | null
    imageUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    categoryId: string | null
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    price?: boolean
    sku?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    category?: boolean | Inventory$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    price?: boolean
    sku?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    category?: boolean | Inventory$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    price?: boolean
    sku?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    category?: boolean | Inventory$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    price?: boolean
    sku?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessId" | "name" | "description" | "quantity" | "price" | "sku" | "imageUrl" | "isActive" | "createdAt" | "updatedAt" | "categoryId", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    category?: boolean | Inventory$categoryArgs<ExtArgs>
  }
  export type InventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    category?: boolean | Inventory$categoryArgs<ExtArgs>
  }
  export type InventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    category?: boolean | Inventory$categoryArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
      category: Prisma.$ProductCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      name: string
      description: string | null
      quantity: number
      price: number
      sku: string | null
      imageUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      categoryId: string | null
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {InventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories and returns the data updated in the database.
     * @param {InventoryUpdateManyAndReturnArgs} args - Arguments to update many Inventories.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends Inventory$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$categoryArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'String'>
    readonly businessId: FieldRef<"Inventory", 'String'>
    readonly name: FieldRef<"Inventory", 'String'>
    readonly description: FieldRef<"Inventory", 'String'>
    readonly quantity: FieldRef<"Inventory", 'Int'>
    readonly price: FieldRef<"Inventory", 'Float'>
    readonly sku: FieldRef<"Inventory", 'String'>
    readonly imageUrl: FieldRef<"Inventory", 'String'>
    readonly isActive: FieldRef<"Inventory", 'Boolean'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
    readonly categoryId: FieldRef<"Inventory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory createManyAndReturn
   */
  export type InventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory updateManyAndReturn
   */
  export type InventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number
  }

  /**
   * Inventory.category
   */
  export type Inventory$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryLog
   */

  export type AggregateDeliveryLog = {
    _count: DeliveryLogCountAggregateOutputType | null
    _avg: DeliveryLogAvgAggregateOutputType | null
    _sum: DeliveryLogSumAggregateOutputType | null
    _min: DeliveryLogMinAggregateOutputType | null
    _max: DeliveryLogMaxAggregateOutputType | null
  }

  export type DeliveryLogAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type DeliveryLogSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type DeliveryLogMinAggregateOutputType = {
    id: string | null
    courierId: string | null
    action: string | null
    timestamp: Date | null
    latitude: number | null
    longitude: number | null
    note: string | null
  }

  export type DeliveryLogMaxAggregateOutputType = {
    id: string | null
    courierId: string | null
    action: string | null
    timestamp: Date | null
    latitude: number | null
    longitude: number | null
    note: string | null
  }

  export type DeliveryLogCountAggregateOutputType = {
    id: number
    courierId: number
    action: number
    timestamp: number
    latitude: number
    longitude: number
    note: number
    metadata: number
    _all: number
  }


  export type DeliveryLogAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type DeliveryLogSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type DeliveryLogMinAggregateInputType = {
    id?: true
    courierId?: true
    action?: true
    timestamp?: true
    latitude?: true
    longitude?: true
    note?: true
  }

  export type DeliveryLogMaxAggregateInputType = {
    id?: true
    courierId?: true
    action?: true
    timestamp?: true
    latitude?: true
    longitude?: true
    note?: true
  }

  export type DeliveryLogCountAggregateInputType = {
    id?: true
    courierId?: true
    action?: true
    timestamp?: true
    latitude?: true
    longitude?: true
    note?: true
    metadata?: true
    _all?: true
  }

  export type DeliveryLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryLog to aggregate.
     */
    where?: DeliveryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLogs to fetch.
     */
    orderBy?: DeliveryLogOrderByWithRelationInput | DeliveryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryLogs
    **/
    _count?: true | DeliveryLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryLogMaxAggregateInputType
  }

  export type GetDeliveryLogAggregateType<T extends DeliveryLogAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryLog[P]>
      : GetScalarType<T[P], AggregateDeliveryLog[P]>
  }




  export type DeliveryLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryLogWhereInput
    orderBy?: DeliveryLogOrderByWithAggregationInput | DeliveryLogOrderByWithAggregationInput[]
    by: DeliveryLogScalarFieldEnum[] | DeliveryLogScalarFieldEnum
    having?: DeliveryLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryLogCountAggregateInputType | true
    _avg?: DeliveryLogAvgAggregateInputType
    _sum?: DeliveryLogSumAggregateInputType
    _min?: DeliveryLogMinAggregateInputType
    _max?: DeliveryLogMaxAggregateInputType
  }

  export type DeliveryLogGroupByOutputType = {
    id: string
    courierId: string
    action: string
    timestamp: Date
    latitude: number | null
    longitude: number | null
    note: string | null
    metadata: JsonValue | null
    _count: DeliveryLogCountAggregateOutputType | null
    _avg: DeliveryLogAvgAggregateOutputType | null
    _sum: DeliveryLogSumAggregateOutputType | null
    _min: DeliveryLogMinAggregateOutputType | null
    _max: DeliveryLogMaxAggregateOutputType | null
  }

  type GetDeliveryLogGroupByPayload<T extends DeliveryLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryLogGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryLogGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courierId?: boolean
    action?: boolean
    timestamp?: boolean
    latitude?: boolean
    longitude?: boolean
    note?: boolean
    metadata?: boolean
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryLog"]>

  export type DeliveryLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courierId?: boolean
    action?: boolean
    timestamp?: boolean
    latitude?: boolean
    longitude?: boolean
    note?: boolean
    metadata?: boolean
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryLog"]>

  export type DeliveryLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courierId?: boolean
    action?: boolean
    timestamp?: boolean
    latitude?: boolean
    longitude?: boolean
    note?: boolean
    metadata?: boolean
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryLog"]>

  export type DeliveryLogSelectScalar = {
    id?: boolean
    courierId?: boolean
    action?: boolean
    timestamp?: boolean
    latitude?: boolean
    longitude?: boolean
    note?: boolean
    metadata?: boolean
  }

  export type DeliveryLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courierId" | "action" | "timestamp" | "latitude" | "longitude" | "note" | "metadata", ExtArgs["result"]["deliveryLog"]>
  export type DeliveryLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }
  export type DeliveryLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }
  export type DeliveryLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }

  export type $DeliveryLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryLog"
    objects: {
      courier: Prisma.$CourierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courierId: string
      action: string
      timestamp: Date
      latitude: number | null
      longitude: number | null
      note: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["deliveryLog"]>
    composites: {}
  }

  type DeliveryLogGetPayload<S extends boolean | null | undefined | DeliveryLogDefaultArgs> = $Result.GetResult<Prisma.$DeliveryLogPayload, S>

  type DeliveryLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryLogCountAggregateInputType | true
    }

  export interface DeliveryLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryLog'], meta: { name: 'DeliveryLog' } }
    /**
     * Find zero or one DeliveryLog that matches the filter.
     * @param {DeliveryLogFindUniqueArgs} args - Arguments to find a DeliveryLog
     * @example
     * // Get one DeliveryLog
     * const deliveryLog = await prisma.deliveryLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryLogFindUniqueArgs>(args: SelectSubset<T, DeliveryLogFindUniqueArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryLogFindUniqueOrThrowArgs} args - Arguments to find a DeliveryLog
     * @example
     * // Get one DeliveryLog
     * const deliveryLog = await prisma.deliveryLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryLogFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLogFindFirstArgs} args - Arguments to find a DeliveryLog
     * @example
     * // Get one DeliveryLog
     * const deliveryLog = await prisma.deliveryLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryLogFindFirstArgs>(args?: SelectSubset<T, DeliveryLogFindFirstArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLogFindFirstOrThrowArgs} args - Arguments to find a DeliveryLog
     * @example
     * // Get one DeliveryLog
     * const deliveryLog = await prisma.deliveryLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryLogFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryLogs
     * const deliveryLogs = await prisma.deliveryLog.findMany()
     * 
     * // Get first 10 DeliveryLogs
     * const deliveryLogs = await prisma.deliveryLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryLogWithIdOnly = await prisma.deliveryLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryLogFindManyArgs>(args?: SelectSubset<T, DeliveryLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryLog.
     * @param {DeliveryLogCreateArgs} args - Arguments to create a DeliveryLog.
     * @example
     * // Create one DeliveryLog
     * const DeliveryLog = await prisma.deliveryLog.create({
     *   data: {
     *     // ... data to create a DeliveryLog
     *   }
     * })
     * 
     */
    create<T extends DeliveryLogCreateArgs>(args: SelectSubset<T, DeliveryLogCreateArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryLogs.
     * @param {DeliveryLogCreateManyArgs} args - Arguments to create many DeliveryLogs.
     * @example
     * // Create many DeliveryLogs
     * const deliveryLog = await prisma.deliveryLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryLogCreateManyArgs>(args?: SelectSubset<T, DeliveryLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryLogs and returns the data saved in the database.
     * @param {DeliveryLogCreateManyAndReturnArgs} args - Arguments to create many DeliveryLogs.
     * @example
     * // Create many DeliveryLogs
     * const deliveryLog = await prisma.deliveryLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryLogs and only return the `id`
     * const deliveryLogWithIdOnly = await prisma.deliveryLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryLogCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryLog.
     * @param {DeliveryLogDeleteArgs} args - Arguments to delete one DeliveryLog.
     * @example
     * // Delete one DeliveryLog
     * const DeliveryLog = await prisma.deliveryLog.delete({
     *   where: {
     *     // ... filter to delete one DeliveryLog
     *   }
     * })
     * 
     */
    delete<T extends DeliveryLogDeleteArgs>(args: SelectSubset<T, DeliveryLogDeleteArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryLog.
     * @param {DeliveryLogUpdateArgs} args - Arguments to update one DeliveryLog.
     * @example
     * // Update one DeliveryLog
     * const deliveryLog = await prisma.deliveryLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryLogUpdateArgs>(args: SelectSubset<T, DeliveryLogUpdateArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryLogs.
     * @param {DeliveryLogDeleteManyArgs} args - Arguments to filter DeliveryLogs to delete.
     * @example
     * // Delete a few DeliveryLogs
     * const { count } = await prisma.deliveryLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryLogDeleteManyArgs>(args?: SelectSubset<T, DeliveryLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryLogs
     * const deliveryLog = await prisma.deliveryLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryLogUpdateManyArgs>(args: SelectSubset<T, DeliveryLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryLogs and returns the data updated in the database.
     * @param {DeliveryLogUpdateManyAndReturnArgs} args - Arguments to update many DeliveryLogs.
     * @example
     * // Update many DeliveryLogs
     * const deliveryLog = await prisma.deliveryLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryLogs and only return the `id`
     * const deliveryLogWithIdOnly = await prisma.deliveryLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryLogUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryLog.
     * @param {DeliveryLogUpsertArgs} args - Arguments to update or create a DeliveryLog.
     * @example
     * // Update or create a DeliveryLog
     * const deliveryLog = await prisma.deliveryLog.upsert({
     *   create: {
     *     // ... data to create a DeliveryLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryLog we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryLogUpsertArgs>(args: SelectSubset<T, DeliveryLogUpsertArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLogCountArgs} args - Arguments to filter DeliveryLogs to count.
     * @example
     * // Count the number of DeliveryLogs
     * const count = await prisma.deliveryLog.count({
     *   where: {
     *     // ... the filter for the DeliveryLogs we want to count
     *   }
     * })
    **/
    count<T extends DeliveryLogCountArgs>(
      args?: Subset<T, DeliveryLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryLogAggregateArgs>(args: Subset<T, DeliveryLogAggregateArgs>): Prisma.PrismaPromise<GetDeliveryLogAggregateType<T>>

    /**
     * Group by DeliveryLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryLogGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryLog model
   */
  readonly fields: DeliveryLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courier<T extends CourierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourierDefaultArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryLog model
   */
  interface DeliveryLogFieldRefs {
    readonly id: FieldRef<"DeliveryLog", 'String'>
    readonly courierId: FieldRef<"DeliveryLog", 'String'>
    readonly action: FieldRef<"DeliveryLog", 'String'>
    readonly timestamp: FieldRef<"DeliveryLog", 'DateTime'>
    readonly latitude: FieldRef<"DeliveryLog", 'Float'>
    readonly longitude: FieldRef<"DeliveryLog", 'Float'>
    readonly note: FieldRef<"DeliveryLog", 'String'>
    readonly metadata: FieldRef<"DeliveryLog", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryLog findUnique
   */
  export type DeliveryLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLog to fetch.
     */
    where: DeliveryLogWhereUniqueInput
  }

  /**
   * DeliveryLog findUniqueOrThrow
   */
  export type DeliveryLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLog to fetch.
     */
    where: DeliveryLogWhereUniqueInput
  }

  /**
   * DeliveryLog findFirst
   */
  export type DeliveryLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLog to fetch.
     */
    where?: DeliveryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLogs to fetch.
     */
    orderBy?: DeliveryLogOrderByWithRelationInput | DeliveryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryLogs.
     */
    cursor?: DeliveryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryLogs.
     */
    distinct?: DeliveryLogScalarFieldEnum | DeliveryLogScalarFieldEnum[]
  }

  /**
   * DeliveryLog findFirstOrThrow
   */
  export type DeliveryLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLog to fetch.
     */
    where?: DeliveryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLogs to fetch.
     */
    orderBy?: DeliveryLogOrderByWithRelationInput | DeliveryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryLogs.
     */
    cursor?: DeliveryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryLogs.
     */
    distinct?: DeliveryLogScalarFieldEnum | DeliveryLogScalarFieldEnum[]
  }

  /**
   * DeliveryLog findMany
   */
  export type DeliveryLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLogs to fetch.
     */
    where?: DeliveryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLogs to fetch.
     */
    orderBy?: DeliveryLogOrderByWithRelationInput | DeliveryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryLogs.
     */
    cursor?: DeliveryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLogs.
     */
    skip?: number
    distinct?: DeliveryLogScalarFieldEnum | DeliveryLogScalarFieldEnum[]
  }

  /**
   * DeliveryLog create
   */
  export type DeliveryLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryLog.
     */
    data: XOR<DeliveryLogCreateInput, DeliveryLogUncheckedCreateInput>
  }

  /**
   * DeliveryLog createMany
   */
  export type DeliveryLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryLogs.
     */
    data: DeliveryLogCreateManyInput | DeliveryLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryLog createManyAndReturn
   */
  export type DeliveryLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryLogs.
     */
    data: DeliveryLogCreateManyInput | DeliveryLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryLog update
   */
  export type DeliveryLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryLog.
     */
    data: XOR<DeliveryLogUpdateInput, DeliveryLogUncheckedUpdateInput>
    /**
     * Choose, which DeliveryLog to update.
     */
    where: DeliveryLogWhereUniqueInput
  }

  /**
   * DeliveryLog updateMany
   */
  export type DeliveryLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryLogs.
     */
    data: XOR<DeliveryLogUpdateManyMutationInput, DeliveryLogUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryLogs to update
     */
    where?: DeliveryLogWhereInput
    /**
     * Limit how many DeliveryLogs to update.
     */
    limit?: number
  }

  /**
   * DeliveryLog updateManyAndReturn
   */
  export type DeliveryLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryLogs.
     */
    data: XOR<DeliveryLogUpdateManyMutationInput, DeliveryLogUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryLogs to update
     */
    where?: DeliveryLogWhereInput
    /**
     * Limit how many DeliveryLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryLog upsert
   */
  export type DeliveryLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryLog to update in case it exists.
     */
    where: DeliveryLogWhereUniqueInput
    /**
     * In case the DeliveryLog found by the `where` argument doesn't exist, create a new DeliveryLog with this data.
     */
    create: XOR<DeliveryLogCreateInput, DeliveryLogUncheckedCreateInput>
    /**
     * In case the DeliveryLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryLogUpdateInput, DeliveryLogUncheckedUpdateInput>
  }

  /**
   * DeliveryLog delete
   */
  export type DeliveryLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * Filter which DeliveryLog to delete.
     */
    where: DeliveryLogWhereUniqueInput
  }

  /**
   * DeliveryLog deleteMany
   */
  export type DeliveryLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryLogs to delete
     */
    where?: DeliveryLogWhereInput
    /**
     * Limit how many DeliveryLogs to delete.
     */
    limit?: number
  }

  /**
   * DeliveryLog without action
   */
  export type DeliveryLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    type: $Enums.ReportType | null
    format: $Enums.ReportFormat | null
    createdAt: Date | null
    url: string | null
    expiresAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    type: $Enums.ReportType | null
    format: $Enums.ReportFormat | null
    createdAt: Date | null
    url: string | null
    expiresAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    type: number
    format: number
    parameters: number
    createdAt: number
    data: number
    url: number
    expiresAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    format?: true
    createdAt?: true
    url?: true
    expiresAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    format?: true
    createdAt?: true
    url?: true
    expiresAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    format?: true
    parameters?: true
    createdAt?: true
    data?: true
    url?: true
    expiresAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    userId: string
    name: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters: JsonValue | null
    createdAt: Date
    data: JsonValue | null
    url: string | null
    expiresAt: Date | null
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    format?: boolean
    parameters?: boolean
    createdAt?: boolean
    data?: boolean
    url?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    format?: boolean
    parameters?: boolean
    createdAt?: boolean
    data?: boolean
    url?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    format?: boolean
    parameters?: boolean
    createdAt?: boolean
    data?: boolean
    url?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    format?: boolean
    parameters?: boolean
    createdAt?: boolean
    data?: boolean
    url?: boolean
    expiresAt?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "type" | "format" | "parameters" | "createdAt" | "data" | "url" | "expiresAt", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      type: $Enums.ReportType
      format: $Enums.ReportFormat
      parameters: Prisma.JsonValue | null
      createdAt: Date
      data: Prisma.JsonValue | null
      url: string | null
      expiresAt: Date | null
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly userId: FieldRef<"Report", 'String'>
    readonly name: FieldRef<"Report", 'String'>
    readonly type: FieldRef<"Report", 'ReportType'>
    readonly format: FieldRef<"Report", 'ReportFormat'>
    readonly parameters: FieldRef<"Report", 'Json'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly data: FieldRef<"Report", 'Json'>
    readonly url: FieldRef<"Report", 'String'>
    readonly expiresAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type ScheduleSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    dayOfWeek: number
    startTime: number
    endTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type ScheduleSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type ScheduleMinAggregateInputType = {
    id?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _avg?: ScheduleAvgAggregateInputType
    _sum?: ScheduleSumAggregateInputType
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: string
    dayOfWeek: number
    startTime: string
    endTime: string
    createdAt: Date
    updatedAt: Date
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reports?: boolean | Schedule$reportsArgs<ExtArgs>
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectScalar = {
    id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dayOfWeek" | "startTime" | "endTime" | "createdAt" | "updatedAt", ExtArgs["result"]["schedule"]>
  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | Schedule$reportsArgs<ExtArgs>
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      reports: Prisma.$ScheduledReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dayOfWeek: number
      startTime: string
      endTime: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {ScheduleCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules and returns the data updated in the database.
     * @param {ScheduleUpdateManyAndReturnArgs} args - Arguments to update many Schedules.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reports<T extends Schedule$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'String'>
    readonly dayOfWeek: FieldRef<"Schedule", 'Int'>
    readonly startTime: FieldRef<"Schedule", 'String'>
    readonly endTime: FieldRef<"Schedule", 'String'>
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Schedule createManyAndReturn
   */
  export type ScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedule updateManyAndReturn
   */
  export type ScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number
  }

  /**
   * Schedule.reports
   */
  export type Schedule$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    where?: ScheduledReportWhereInput
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    cursor?: ScheduledReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Model ScheduledReport
   */

  export type AggregateScheduledReport = {
    _count: ScheduledReportCountAggregateOutputType | null
    _min: ScheduledReportMinAggregateOutputType | null
    _max: ScheduledReportMaxAggregateOutputType | null
  }

  export type ScheduledReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    scheduleId: string | null
    reportName: string | null
    type: $Enums.ReportType | null
    format: $Enums.ReportFormat | null
    enabled: boolean | null
    nextRunAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    scheduleId: string | null
    reportName: string | null
    type: $Enums.ReportType | null
    format: $Enums.ReportFormat | null
    enabled: boolean | null
    nextRunAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledReportCountAggregateOutputType = {
    id: number
    userId: number
    scheduleId: number
    reportName: number
    type: number
    format: number
    parameters: number
    enabled: number
    recipients: number
    nextRunAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduledReportMinAggregateInputType = {
    id?: true
    userId?: true
    scheduleId?: true
    reportName?: true
    type?: true
    format?: true
    enabled?: true
    nextRunAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledReportMaxAggregateInputType = {
    id?: true
    userId?: true
    scheduleId?: true
    reportName?: true
    type?: true
    format?: true
    enabled?: true
    nextRunAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledReportCountAggregateInputType = {
    id?: true
    userId?: true
    scheduleId?: true
    reportName?: true
    type?: true
    format?: true
    parameters?: true
    enabled?: true
    recipients?: true
    nextRunAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduledReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledReport to aggregate.
     */
    where?: ScheduledReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReports to fetch.
     */
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledReports
    **/
    _count?: true | ScheduledReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledReportMaxAggregateInputType
  }

  export type GetScheduledReportAggregateType<T extends ScheduledReportAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledReport[P]>
      : GetScalarType<T[P], AggregateScheduledReport[P]>
  }




  export type ScheduledReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledReportWhereInput
    orderBy?: ScheduledReportOrderByWithAggregationInput | ScheduledReportOrderByWithAggregationInput[]
    by: ScheduledReportScalarFieldEnum[] | ScheduledReportScalarFieldEnum
    having?: ScheduledReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledReportCountAggregateInputType | true
    _min?: ScheduledReportMinAggregateInputType
    _max?: ScheduledReportMaxAggregateInputType
  }

  export type ScheduledReportGroupByOutputType = {
    id: string
    userId: string
    scheduleId: string
    reportName: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters: JsonValue | null
    enabled: boolean
    recipients: string[]
    nextRunAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduledReportCountAggregateOutputType | null
    _min: ScheduledReportMinAggregateOutputType | null
    _max: ScheduledReportMaxAggregateOutputType | null
  }

  type GetScheduledReportGroupByPayload<T extends ScheduledReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledReportGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledReportGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scheduleId?: boolean
    reportName?: boolean
    type?: boolean
    format?: boolean
    parameters?: boolean
    enabled?: boolean
    recipients?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledReport"]>

  export type ScheduledReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scheduleId?: boolean
    reportName?: boolean
    type?: boolean
    format?: boolean
    parameters?: boolean
    enabled?: boolean
    recipients?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledReport"]>

  export type ScheduledReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scheduleId?: boolean
    reportName?: boolean
    type?: boolean
    format?: boolean
    parameters?: boolean
    enabled?: boolean
    recipients?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledReport"]>

  export type ScheduledReportSelectScalar = {
    id?: boolean
    userId?: boolean
    scheduleId?: boolean
    reportName?: boolean
    type?: boolean
    format?: boolean
    parameters?: boolean
    enabled?: boolean
    recipients?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduledReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "scheduleId" | "reportName" | "type" | "format" | "parameters" | "enabled" | "recipients" | "nextRunAt" | "createdAt" | "updatedAt", ExtArgs["result"]["scheduledReport"]>
  export type ScheduledReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }
  export type ScheduledReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }
  export type ScheduledReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }

  export type $ScheduledReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledReport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      schedule: Prisma.$SchedulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      scheduleId: string
      reportName: string
      type: $Enums.ReportType
      format: $Enums.ReportFormat
      parameters: Prisma.JsonValue | null
      enabled: boolean
      recipients: string[]
      nextRunAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduledReport"]>
    composites: {}
  }

  type ScheduledReportGetPayload<S extends boolean | null | undefined | ScheduledReportDefaultArgs> = $Result.GetResult<Prisma.$ScheduledReportPayload, S>

  type ScheduledReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduledReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduledReportCountAggregateInputType | true
    }

  export interface ScheduledReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledReport'], meta: { name: 'ScheduledReport' } }
    /**
     * Find zero or one ScheduledReport that matches the filter.
     * @param {ScheduledReportFindUniqueArgs} args - Arguments to find a ScheduledReport
     * @example
     * // Get one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledReportFindUniqueArgs>(args: SelectSubset<T, ScheduledReportFindUniqueArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduledReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduledReportFindUniqueOrThrowArgs} args - Arguments to find a ScheduledReport
     * @example
     * // Get one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportFindFirstArgs} args - Arguments to find a ScheduledReport
     * @example
     * // Get one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledReportFindFirstArgs>(args?: SelectSubset<T, ScheduledReportFindFirstArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportFindFirstOrThrowArgs} args - Arguments to find a ScheduledReport
     * @example
     * // Get one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduledReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledReports
     * const scheduledReports = await prisma.scheduledReport.findMany()
     * 
     * // Get first 10 ScheduledReports
     * const scheduledReports = await prisma.scheduledReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledReportWithIdOnly = await prisma.scheduledReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledReportFindManyArgs>(args?: SelectSubset<T, ScheduledReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduledReport.
     * @param {ScheduledReportCreateArgs} args - Arguments to create a ScheduledReport.
     * @example
     * // Create one ScheduledReport
     * const ScheduledReport = await prisma.scheduledReport.create({
     *   data: {
     *     // ... data to create a ScheduledReport
     *   }
     * })
     * 
     */
    create<T extends ScheduledReportCreateArgs>(args: SelectSubset<T, ScheduledReportCreateArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduledReports.
     * @param {ScheduledReportCreateManyArgs} args - Arguments to create many ScheduledReports.
     * @example
     * // Create many ScheduledReports
     * const scheduledReport = await prisma.scheduledReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledReportCreateManyArgs>(args?: SelectSubset<T, ScheduledReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduledReports and returns the data saved in the database.
     * @param {ScheduledReportCreateManyAndReturnArgs} args - Arguments to create many ScheduledReports.
     * @example
     * // Create many ScheduledReports
     * const scheduledReport = await prisma.scheduledReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduledReports and only return the `id`
     * const scheduledReportWithIdOnly = await prisma.scheduledReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduledReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduledReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduledReport.
     * @param {ScheduledReportDeleteArgs} args - Arguments to delete one ScheduledReport.
     * @example
     * // Delete one ScheduledReport
     * const ScheduledReport = await prisma.scheduledReport.delete({
     *   where: {
     *     // ... filter to delete one ScheduledReport
     *   }
     * })
     * 
     */
    delete<T extends ScheduledReportDeleteArgs>(args: SelectSubset<T, ScheduledReportDeleteArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduledReport.
     * @param {ScheduledReportUpdateArgs} args - Arguments to update one ScheduledReport.
     * @example
     * // Update one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledReportUpdateArgs>(args: SelectSubset<T, ScheduledReportUpdateArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduledReports.
     * @param {ScheduledReportDeleteManyArgs} args - Arguments to filter ScheduledReports to delete.
     * @example
     * // Delete a few ScheduledReports
     * const { count } = await prisma.scheduledReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledReportDeleteManyArgs>(args?: SelectSubset<T, ScheduledReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledReports
     * const scheduledReport = await prisma.scheduledReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledReportUpdateManyArgs>(args: SelectSubset<T, ScheduledReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledReports and returns the data updated in the database.
     * @param {ScheduledReportUpdateManyAndReturnArgs} args - Arguments to update many ScheduledReports.
     * @example
     * // Update many ScheduledReports
     * const scheduledReport = await prisma.scheduledReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduledReports and only return the `id`
     * const scheduledReportWithIdOnly = await prisma.scheduledReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduledReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduledReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduledReport.
     * @param {ScheduledReportUpsertArgs} args - Arguments to update or create a ScheduledReport.
     * @example
     * // Update or create a ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.upsert({
     *   create: {
     *     // ... data to create a ScheduledReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledReport we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledReportUpsertArgs>(args: SelectSubset<T, ScheduledReportUpsertArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduledReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportCountArgs} args - Arguments to filter ScheduledReports to count.
     * @example
     * // Count the number of ScheduledReports
     * const count = await prisma.scheduledReport.count({
     *   where: {
     *     // ... the filter for the ScheduledReports we want to count
     *   }
     * })
    **/
    count<T extends ScheduledReportCountArgs>(
      args?: Subset<T, ScheduledReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledReportAggregateArgs>(args: Subset<T, ScheduledReportAggregateArgs>): Prisma.PrismaPromise<GetScheduledReportAggregateType<T>>

    /**
     * Group by ScheduledReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledReportGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledReport model
   */
  readonly fields: ScheduledReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schedule<T extends ScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleDefaultArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledReport model
   */
  interface ScheduledReportFieldRefs {
    readonly id: FieldRef<"ScheduledReport", 'String'>
    readonly userId: FieldRef<"ScheduledReport", 'String'>
    readonly scheduleId: FieldRef<"ScheduledReport", 'String'>
    readonly reportName: FieldRef<"ScheduledReport", 'String'>
    readonly type: FieldRef<"ScheduledReport", 'ReportType'>
    readonly format: FieldRef<"ScheduledReport", 'ReportFormat'>
    readonly parameters: FieldRef<"ScheduledReport", 'Json'>
    readonly enabled: FieldRef<"ScheduledReport", 'Boolean'>
    readonly recipients: FieldRef<"ScheduledReport", 'String[]'>
    readonly nextRunAt: FieldRef<"ScheduledReport", 'DateTime'>
    readonly createdAt: FieldRef<"ScheduledReport", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduledReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledReport findUnique
   */
  export type ScheduledReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReport to fetch.
     */
    where: ScheduledReportWhereUniqueInput
  }

  /**
   * ScheduledReport findUniqueOrThrow
   */
  export type ScheduledReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReport to fetch.
     */
    where: ScheduledReportWhereUniqueInput
  }

  /**
   * ScheduledReport findFirst
   */
  export type ScheduledReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReport to fetch.
     */
    where?: ScheduledReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReports to fetch.
     */
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledReports.
     */
    cursor?: ScheduledReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledReports.
     */
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * ScheduledReport findFirstOrThrow
   */
  export type ScheduledReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReport to fetch.
     */
    where?: ScheduledReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReports to fetch.
     */
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledReports.
     */
    cursor?: ScheduledReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledReports.
     */
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * ScheduledReport findMany
   */
  export type ScheduledReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReports to fetch.
     */
    where?: ScheduledReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReports to fetch.
     */
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledReports.
     */
    cursor?: ScheduledReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReports.
     */
    skip?: number
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * ScheduledReport create
   */
  export type ScheduledReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduledReport.
     */
    data: XOR<ScheduledReportCreateInput, ScheduledReportUncheckedCreateInput>
  }

  /**
   * ScheduledReport createMany
   */
  export type ScheduledReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledReports.
     */
    data: ScheduledReportCreateManyInput | ScheduledReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledReport createManyAndReturn
   */
  export type ScheduledReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduledReports.
     */
    data: ScheduledReportCreateManyInput | ScheduledReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledReport update
   */
  export type ScheduledReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduledReport.
     */
    data: XOR<ScheduledReportUpdateInput, ScheduledReportUncheckedUpdateInput>
    /**
     * Choose, which ScheduledReport to update.
     */
    where: ScheduledReportWhereUniqueInput
  }

  /**
   * ScheduledReport updateMany
   */
  export type ScheduledReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledReports.
     */
    data: XOR<ScheduledReportUpdateManyMutationInput, ScheduledReportUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledReports to update
     */
    where?: ScheduledReportWhereInput
    /**
     * Limit how many ScheduledReports to update.
     */
    limit?: number
  }

  /**
   * ScheduledReport updateManyAndReturn
   */
  export type ScheduledReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * The data used to update ScheduledReports.
     */
    data: XOR<ScheduledReportUpdateManyMutationInput, ScheduledReportUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledReports to update
     */
    where?: ScheduledReportWhereInput
    /**
     * Limit how many ScheduledReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledReport upsert
   */
  export type ScheduledReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduledReport to update in case it exists.
     */
    where: ScheduledReportWhereUniqueInput
    /**
     * In case the ScheduledReport found by the `where` argument doesn't exist, create a new ScheduledReport with this data.
     */
    create: XOR<ScheduledReportCreateInput, ScheduledReportUncheckedCreateInput>
    /**
     * In case the ScheduledReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledReportUpdateInput, ScheduledReportUncheckedUpdateInput>
  }

  /**
   * ScheduledReport delete
   */
  export type ScheduledReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter which ScheduledReport to delete.
     */
    where: ScheduledReportWhereUniqueInput
  }

  /**
   * ScheduledReport deleteMany
   */
  export type ScheduledReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledReports to delete
     */
    where?: ScheduledReportWhereInput
    /**
     * Limit how many ScheduledReports to delete.
     */
    limit?: number
  }

  /**
   * ScheduledReport without action
   */
  export type ScheduledReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReport
     */
    omit?: ScheduledReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    language: string | null
    theme: string | null
    notifications: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    language: string | null
    theme: string | null
    notifications: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    id: number
    userId: number
    language: number
    theme: number
    notifications: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    language?: true
    theme?: true
    notifications?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    language?: true
    theme?: true
    notifications?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    language?: true
    theme?: true
    notifications?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    id: string
    userId: string
    language: string
    theme: string
    notifications: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    language?: boolean
    theme?: boolean
    notifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    language?: boolean
    theme?: boolean
    notifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    language?: boolean
    theme?: boolean
    notifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    language?: boolean
    theme?: boolean
    notifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "language" | "theme" | "notifications" | "createdAt" | "updatedAt", ExtArgs["result"]["userSettings"]>
  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      language: string
      theme: string
      notifications: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings and returns the data updated in the database.
     * @param {UserSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserSettings.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */
  interface UserSettingsFieldRefs {
    readonly id: FieldRef<"UserSettings", 'String'>
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly language: FieldRef<"UserSettings", 'String'>
    readonly theme: FieldRef<"UserSettings", 'String'>
    readonly notifications: FieldRef<"UserSettings", 'Boolean'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSettings updateManyAndReturn
   */
  export type UserSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to delete.
     */
    limit?: number
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model MenuItem
   */

  export type AggregateMenuItem = {
    _count: MenuItemCountAggregateOutputType | null
    _avg: MenuItemAvgAggregateOutputType | null
    _sum: MenuItemSumAggregateOutputType | null
    _min: MenuItemMinAggregateOutputType | null
    _max: MenuItemMaxAggregateOutputType | null
  }

  export type MenuItemAvgAggregateOutputType = {
    price: number | null
    calories: number | null
  }

  export type MenuItemSumAggregateOutputType = {
    price: number | null
    calories: number | null
  }

  export type MenuItemMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    description: string | null
    price: number | null
    imageUrl: string | null
    category: string | null
    calories: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuItemMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    description: string | null
    price: number | null
    imageUrl: string | null
    category: string | null
    calories: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuItemCountAggregateOutputType = {
    id: number
    businessId: number
    name: number
    description: number
    price: number
    imageUrl: number
    category: number
    tags: number
    ingredients: number
    calories: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuItemAvgAggregateInputType = {
    price?: true
    calories?: true
  }

  export type MenuItemSumAggregateInputType = {
    price?: true
    calories?: true
  }

  export type MenuItemMinAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    price?: true
    imageUrl?: true
    category?: true
    calories?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuItemMaxAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    price?: true
    imageUrl?: true
    category?: true
    calories?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuItemCountAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    price?: true
    imageUrl?: true
    category?: true
    tags?: true
    ingredients?: true
    calories?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItem to aggregate.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuItems
    **/
    _count?: true | MenuItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuItemMaxAggregateInputType
  }

  export type GetMenuItemAggregateType<T extends MenuItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuItem[P]>
      : GetScalarType<T[P], AggregateMenuItem[P]>
  }




  export type MenuItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithAggregationInput | MenuItemOrderByWithAggregationInput[]
    by: MenuItemScalarFieldEnum[] | MenuItemScalarFieldEnum
    having?: MenuItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuItemCountAggregateInputType | true
    _avg?: MenuItemAvgAggregateInputType
    _sum?: MenuItemSumAggregateInputType
    _min?: MenuItemMinAggregateInputType
    _max?: MenuItemMaxAggregateInputType
  }

  export type MenuItemGroupByOutputType = {
    id: string
    businessId: string
    name: string
    description: string | null
    price: number
    imageUrl: string | null
    category: string | null
    tags: string[]
    ingredients: string[]
    calories: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: MenuItemCountAggregateOutputType | null
    _avg: MenuItemAvgAggregateOutputType | null
    _sum: MenuItemSumAggregateOutputType | null
    _min: MenuItemMinAggregateOutputType | null
    _max: MenuItemMaxAggregateOutputType | null
  }

  type GetMenuItemGroupByPayload<T extends MenuItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuItemGroupByOutputType[P]>
            : GetScalarType<T[P], MenuItemGroupByOutputType[P]>
        }
      >
    >


  export type MenuItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    imageUrl?: boolean
    category?: boolean
    tags?: boolean
    ingredients?: boolean
    calories?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    imageUrl?: boolean
    category?: boolean
    tags?: boolean
    ingredients?: boolean
    calories?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    imageUrl?: boolean
    category?: boolean
    tags?: boolean
    ingredients?: boolean
    calories?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectScalar = {
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    imageUrl?: boolean
    category?: boolean
    tags?: boolean
    ingredients?: boolean
    calories?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessId" | "name" | "description" | "price" | "imageUrl" | "category" | "tags" | "ingredients" | "calories" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["menuItem"]>
  export type MenuItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type MenuItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type MenuItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $MenuItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenuItem"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      name: string
      description: string | null
      price: number
      imageUrl: string | null
      category: string | null
      tags: string[]
      ingredients: string[]
      calories: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menuItem"]>
    composites: {}
  }

  type MenuItemGetPayload<S extends boolean | null | undefined | MenuItemDefaultArgs> = $Result.GetResult<Prisma.$MenuItemPayload, S>

  type MenuItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenuItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenuItemCountAggregateInputType | true
    }

  export interface MenuItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenuItem'], meta: { name: 'MenuItem' } }
    /**
     * Find zero or one MenuItem that matches the filter.
     * @param {MenuItemFindUniqueArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuItemFindUniqueArgs>(args: SelectSubset<T, MenuItemFindUniqueArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenuItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenuItemFindUniqueOrThrowArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindFirstArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuItemFindFirstArgs>(args?: SelectSubset<T, MenuItemFindFirstArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindFirstOrThrowArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenuItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuItems
     * const menuItems = await prisma.menuItem.findMany()
     * 
     * // Get first 10 MenuItems
     * const menuItems = await prisma.menuItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuItemFindManyArgs>(args?: SelectSubset<T, MenuItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenuItem.
     * @param {MenuItemCreateArgs} args - Arguments to create a MenuItem.
     * @example
     * // Create one MenuItem
     * const MenuItem = await prisma.menuItem.create({
     *   data: {
     *     // ... data to create a MenuItem
     *   }
     * })
     * 
     */
    create<T extends MenuItemCreateArgs>(args: SelectSubset<T, MenuItemCreateArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenuItems.
     * @param {MenuItemCreateManyArgs} args - Arguments to create many MenuItems.
     * @example
     * // Create many MenuItems
     * const menuItem = await prisma.menuItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuItemCreateManyArgs>(args?: SelectSubset<T, MenuItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenuItems and returns the data saved in the database.
     * @param {MenuItemCreateManyAndReturnArgs} args - Arguments to create many MenuItems.
     * @example
     * // Create many MenuItems
     * const menuItem = await prisma.menuItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenuItems and only return the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenuItem.
     * @param {MenuItemDeleteArgs} args - Arguments to delete one MenuItem.
     * @example
     * // Delete one MenuItem
     * const MenuItem = await prisma.menuItem.delete({
     *   where: {
     *     // ... filter to delete one MenuItem
     *   }
     * })
     * 
     */
    delete<T extends MenuItemDeleteArgs>(args: SelectSubset<T, MenuItemDeleteArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenuItem.
     * @param {MenuItemUpdateArgs} args - Arguments to update one MenuItem.
     * @example
     * // Update one MenuItem
     * const menuItem = await prisma.menuItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuItemUpdateArgs>(args: SelectSubset<T, MenuItemUpdateArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenuItems.
     * @param {MenuItemDeleteManyArgs} args - Arguments to filter MenuItems to delete.
     * @example
     * // Delete a few MenuItems
     * const { count } = await prisma.menuItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuItemDeleteManyArgs>(args?: SelectSubset<T, MenuItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuItems
     * const menuItem = await prisma.menuItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuItemUpdateManyArgs>(args: SelectSubset<T, MenuItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItems and returns the data updated in the database.
     * @param {MenuItemUpdateManyAndReturnArgs} args - Arguments to update many MenuItems.
     * @example
     * // Update many MenuItems
     * const menuItem = await prisma.menuItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenuItems and only return the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenuItemUpdateManyAndReturnArgs>(args: SelectSubset<T, MenuItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenuItem.
     * @param {MenuItemUpsertArgs} args - Arguments to update or create a MenuItem.
     * @example
     * // Update or create a MenuItem
     * const menuItem = await prisma.menuItem.upsert({
     *   create: {
     *     // ... data to create a MenuItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuItem we want to update
     *   }
     * })
     */
    upsert<T extends MenuItemUpsertArgs>(args: SelectSubset<T, MenuItemUpsertArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemCountArgs} args - Arguments to filter MenuItems to count.
     * @example
     * // Count the number of MenuItems
     * const count = await prisma.menuItem.count({
     *   where: {
     *     // ... the filter for the MenuItems we want to count
     *   }
     * })
    **/
    count<T extends MenuItemCountArgs>(
      args?: Subset<T, MenuItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuItemAggregateArgs>(args: Subset<T, MenuItemAggregateArgs>): Prisma.PrismaPromise<GetMenuItemAggregateType<T>>

    /**
     * Group by MenuItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuItemGroupByArgs['orderBy'] }
        : { orderBy?: MenuItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenuItem model
   */
  readonly fields: MenuItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenuItem model
   */
  interface MenuItemFieldRefs {
    readonly id: FieldRef<"MenuItem", 'String'>
    readonly businessId: FieldRef<"MenuItem", 'String'>
    readonly name: FieldRef<"MenuItem", 'String'>
    readonly description: FieldRef<"MenuItem", 'String'>
    readonly price: FieldRef<"MenuItem", 'Float'>
    readonly imageUrl: FieldRef<"MenuItem", 'String'>
    readonly category: FieldRef<"MenuItem", 'String'>
    readonly tags: FieldRef<"MenuItem", 'String[]'>
    readonly ingredients: FieldRef<"MenuItem", 'String[]'>
    readonly calories: FieldRef<"MenuItem", 'Int'>
    readonly isActive: FieldRef<"MenuItem", 'Boolean'>
    readonly createdAt: FieldRef<"MenuItem", 'DateTime'>
    readonly updatedAt: FieldRef<"MenuItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MenuItem findUnique
   */
  export type MenuItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem findUniqueOrThrow
   */
  export type MenuItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem findFirst
   */
  export type MenuItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItems.
     */
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem findFirstOrThrow
   */
  export type MenuItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItems.
     */
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem findMany
   */
  export type MenuItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItems to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem create
   */
  export type MenuItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MenuItem.
     */
    data: XOR<MenuItemCreateInput, MenuItemUncheckedCreateInput>
  }

  /**
   * MenuItem createMany
   */
  export type MenuItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenuItems.
     */
    data: MenuItemCreateManyInput | MenuItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenuItem createManyAndReturn
   */
  export type MenuItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * The data used to create many MenuItems.
     */
    data: MenuItemCreateManyInput | MenuItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuItem update
   */
  export type MenuItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MenuItem.
     */
    data: XOR<MenuItemUpdateInput, MenuItemUncheckedUpdateInput>
    /**
     * Choose, which MenuItem to update.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem updateMany
   */
  export type MenuItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenuItems.
     */
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyInput>
    /**
     * Filter which MenuItems to update
     */
    where?: MenuItemWhereInput
    /**
     * Limit how many MenuItems to update.
     */
    limit?: number
  }

  /**
   * MenuItem updateManyAndReturn
   */
  export type MenuItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * The data used to update MenuItems.
     */
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyInput>
    /**
     * Filter which MenuItems to update
     */
    where?: MenuItemWhereInput
    /**
     * Limit how many MenuItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuItem upsert
   */
  export type MenuItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MenuItem to update in case it exists.
     */
    where: MenuItemWhereUniqueInput
    /**
     * In case the MenuItem found by the `where` argument doesn't exist, create a new MenuItem with this data.
     */
    create: XOR<MenuItemCreateInput, MenuItemUncheckedCreateInput>
    /**
     * In case the MenuItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuItemUpdateInput, MenuItemUncheckedUpdateInput>
  }

  /**
   * MenuItem delete
   */
  export type MenuItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter which MenuItem to delete.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem deleteMany
   */
  export type MenuItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItems to delete
     */
    where?: MenuItemWhereInput
    /**
     * Limit how many MenuItems to delete.
     */
    limit?: number
  }

  /**
   * MenuItem without action
   */
  export type MenuItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
  }


  /**
   * Model CourierAvailability
   */

  export type AggregateCourierAvailability = {
    _count: CourierAvailabilityCountAggregateOutputType | null
    _min: CourierAvailabilityMinAggregateOutputType | null
    _max: CourierAvailabilityMaxAggregateOutputType | null
  }

  export type CourierAvailabilityMinAggregateOutputType = {
    id: string | null
    courierId: string | null
    status: $Enums.CourierAvailabilityStatus | null
    startTime: Date | null
    endTime: Date | null
    note: string | null
    createdAt: Date | null
  }

  export type CourierAvailabilityMaxAggregateOutputType = {
    id: string | null
    courierId: string | null
    status: $Enums.CourierAvailabilityStatus | null
    startTime: Date | null
    endTime: Date | null
    note: string | null
    createdAt: Date | null
  }

  export type CourierAvailabilityCountAggregateOutputType = {
    id: number
    courierId: number
    status: number
    startTime: number
    endTime: number
    note: number
    createdAt: number
    _all: number
  }


  export type CourierAvailabilityMinAggregateInputType = {
    id?: true
    courierId?: true
    status?: true
    startTime?: true
    endTime?: true
    note?: true
    createdAt?: true
  }

  export type CourierAvailabilityMaxAggregateInputType = {
    id?: true
    courierId?: true
    status?: true
    startTime?: true
    endTime?: true
    note?: true
    createdAt?: true
  }

  export type CourierAvailabilityCountAggregateInputType = {
    id?: true
    courierId?: true
    status?: true
    startTime?: true
    endTime?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type CourierAvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourierAvailability to aggregate.
     */
    where?: CourierAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourierAvailabilities to fetch.
     */
    orderBy?: CourierAvailabilityOrderByWithRelationInput | CourierAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourierAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourierAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourierAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourierAvailabilities
    **/
    _count?: true | CourierAvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourierAvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourierAvailabilityMaxAggregateInputType
  }

  export type GetCourierAvailabilityAggregateType<T extends CourierAvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateCourierAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourierAvailability[P]>
      : GetScalarType<T[P], AggregateCourierAvailability[P]>
  }




  export type CourierAvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourierAvailabilityWhereInput
    orderBy?: CourierAvailabilityOrderByWithAggregationInput | CourierAvailabilityOrderByWithAggregationInput[]
    by: CourierAvailabilityScalarFieldEnum[] | CourierAvailabilityScalarFieldEnum
    having?: CourierAvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourierAvailabilityCountAggregateInputType | true
    _min?: CourierAvailabilityMinAggregateInputType
    _max?: CourierAvailabilityMaxAggregateInputType
  }

  export type CourierAvailabilityGroupByOutputType = {
    id: string
    courierId: string
    status: $Enums.CourierAvailabilityStatus
    startTime: Date
    endTime: Date | null
    note: string | null
    createdAt: Date
    _count: CourierAvailabilityCountAggregateOutputType | null
    _min: CourierAvailabilityMinAggregateOutputType | null
    _max: CourierAvailabilityMaxAggregateOutputType | null
  }

  type GetCourierAvailabilityGroupByPayload<T extends CourierAvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourierAvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourierAvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourierAvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], CourierAvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type CourierAvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courierId?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    createdAt?: boolean
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courierAvailability"]>

  export type CourierAvailabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courierId?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    createdAt?: boolean
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courierAvailability"]>

  export type CourierAvailabilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courierId?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    createdAt?: boolean
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courierAvailability"]>

  export type CourierAvailabilitySelectScalar = {
    id?: boolean
    courierId?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type CourierAvailabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courierId" | "status" | "startTime" | "endTime" | "note" | "createdAt", ExtArgs["result"]["courierAvailability"]>
  export type CourierAvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }
  export type CourierAvailabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }
  export type CourierAvailabilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }

  export type $CourierAvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourierAvailability"
    objects: {
      courier: Prisma.$CourierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courierId: string
      status: $Enums.CourierAvailabilityStatus
      startTime: Date
      endTime: Date | null
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["courierAvailability"]>
    composites: {}
  }

  type CourierAvailabilityGetPayload<S extends boolean | null | undefined | CourierAvailabilityDefaultArgs> = $Result.GetResult<Prisma.$CourierAvailabilityPayload, S>

  type CourierAvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourierAvailabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourierAvailabilityCountAggregateInputType | true
    }

  export interface CourierAvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourierAvailability'], meta: { name: 'CourierAvailability' } }
    /**
     * Find zero or one CourierAvailability that matches the filter.
     * @param {CourierAvailabilityFindUniqueArgs} args - Arguments to find a CourierAvailability
     * @example
     * // Get one CourierAvailability
     * const courierAvailability = await prisma.courierAvailability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourierAvailabilityFindUniqueArgs>(args: SelectSubset<T, CourierAvailabilityFindUniqueArgs<ExtArgs>>): Prisma__CourierAvailabilityClient<$Result.GetResult<Prisma.$CourierAvailabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourierAvailability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourierAvailabilityFindUniqueOrThrowArgs} args - Arguments to find a CourierAvailability
     * @example
     * // Get one CourierAvailability
     * const courierAvailability = await prisma.courierAvailability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourierAvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, CourierAvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourierAvailabilityClient<$Result.GetResult<Prisma.$CourierAvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourierAvailability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierAvailabilityFindFirstArgs} args - Arguments to find a CourierAvailability
     * @example
     * // Get one CourierAvailability
     * const courierAvailability = await prisma.courierAvailability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourierAvailabilityFindFirstArgs>(args?: SelectSubset<T, CourierAvailabilityFindFirstArgs<ExtArgs>>): Prisma__CourierAvailabilityClient<$Result.GetResult<Prisma.$CourierAvailabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourierAvailability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierAvailabilityFindFirstOrThrowArgs} args - Arguments to find a CourierAvailability
     * @example
     * // Get one CourierAvailability
     * const courierAvailability = await prisma.courierAvailability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourierAvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, CourierAvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourierAvailabilityClient<$Result.GetResult<Prisma.$CourierAvailabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourierAvailabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierAvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourierAvailabilities
     * const courierAvailabilities = await prisma.courierAvailability.findMany()
     * 
     * // Get first 10 CourierAvailabilities
     * const courierAvailabilities = await prisma.courierAvailability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courierAvailabilityWithIdOnly = await prisma.courierAvailability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourierAvailabilityFindManyArgs>(args?: SelectSubset<T, CourierAvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierAvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourierAvailability.
     * @param {CourierAvailabilityCreateArgs} args - Arguments to create a CourierAvailability.
     * @example
     * // Create one CourierAvailability
     * const CourierAvailability = await prisma.courierAvailability.create({
     *   data: {
     *     // ... data to create a CourierAvailability
     *   }
     * })
     * 
     */
    create<T extends CourierAvailabilityCreateArgs>(args: SelectSubset<T, CourierAvailabilityCreateArgs<ExtArgs>>): Prisma__CourierAvailabilityClient<$Result.GetResult<Prisma.$CourierAvailabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourierAvailabilities.
     * @param {CourierAvailabilityCreateManyArgs} args - Arguments to create many CourierAvailabilities.
     * @example
     * // Create many CourierAvailabilities
     * const courierAvailability = await prisma.courierAvailability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourierAvailabilityCreateManyArgs>(args?: SelectSubset<T, CourierAvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourierAvailabilities and returns the data saved in the database.
     * @param {CourierAvailabilityCreateManyAndReturnArgs} args - Arguments to create many CourierAvailabilities.
     * @example
     * // Create many CourierAvailabilities
     * const courierAvailability = await prisma.courierAvailability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourierAvailabilities and only return the `id`
     * const courierAvailabilityWithIdOnly = await prisma.courierAvailability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourierAvailabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, CourierAvailabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierAvailabilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourierAvailability.
     * @param {CourierAvailabilityDeleteArgs} args - Arguments to delete one CourierAvailability.
     * @example
     * // Delete one CourierAvailability
     * const CourierAvailability = await prisma.courierAvailability.delete({
     *   where: {
     *     // ... filter to delete one CourierAvailability
     *   }
     * })
     * 
     */
    delete<T extends CourierAvailabilityDeleteArgs>(args: SelectSubset<T, CourierAvailabilityDeleteArgs<ExtArgs>>): Prisma__CourierAvailabilityClient<$Result.GetResult<Prisma.$CourierAvailabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourierAvailability.
     * @param {CourierAvailabilityUpdateArgs} args - Arguments to update one CourierAvailability.
     * @example
     * // Update one CourierAvailability
     * const courierAvailability = await prisma.courierAvailability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourierAvailabilityUpdateArgs>(args: SelectSubset<T, CourierAvailabilityUpdateArgs<ExtArgs>>): Prisma__CourierAvailabilityClient<$Result.GetResult<Prisma.$CourierAvailabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourierAvailabilities.
     * @param {CourierAvailabilityDeleteManyArgs} args - Arguments to filter CourierAvailabilities to delete.
     * @example
     * // Delete a few CourierAvailabilities
     * const { count } = await prisma.courierAvailability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourierAvailabilityDeleteManyArgs>(args?: SelectSubset<T, CourierAvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourierAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierAvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourierAvailabilities
     * const courierAvailability = await prisma.courierAvailability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourierAvailabilityUpdateManyArgs>(args: SelectSubset<T, CourierAvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourierAvailabilities and returns the data updated in the database.
     * @param {CourierAvailabilityUpdateManyAndReturnArgs} args - Arguments to update many CourierAvailabilities.
     * @example
     * // Update many CourierAvailabilities
     * const courierAvailability = await prisma.courierAvailability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourierAvailabilities and only return the `id`
     * const courierAvailabilityWithIdOnly = await prisma.courierAvailability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourierAvailabilityUpdateManyAndReturnArgs>(args: SelectSubset<T, CourierAvailabilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierAvailabilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourierAvailability.
     * @param {CourierAvailabilityUpsertArgs} args - Arguments to update or create a CourierAvailability.
     * @example
     * // Update or create a CourierAvailability
     * const courierAvailability = await prisma.courierAvailability.upsert({
     *   create: {
     *     // ... data to create a CourierAvailability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourierAvailability we want to update
     *   }
     * })
     */
    upsert<T extends CourierAvailabilityUpsertArgs>(args: SelectSubset<T, CourierAvailabilityUpsertArgs<ExtArgs>>): Prisma__CourierAvailabilityClient<$Result.GetResult<Prisma.$CourierAvailabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourierAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierAvailabilityCountArgs} args - Arguments to filter CourierAvailabilities to count.
     * @example
     * // Count the number of CourierAvailabilities
     * const count = await prisma.courierAvailability.count({
     *   where: {
     *     // ... the filter for the CourierAvailabilities we want to count
     *   }
     * })
    **/
    count<T extends CourierAvailabilityCountArgs>(
      args?: Subset<T, CourierAvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourierAvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourierAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierAvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourierAvailabilityAggregateArgs>(args: Subset<T, CourierAvailabilityAggregateArgs>): Prisma.PrismaPromise<GetCourierAvailabilityAggregateType<T>>

    /**
     * Group by CourierAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierAvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourierAvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourierAvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: CourierAvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourierAvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourierAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourierAvailability model
   */
  readonly fields: CourierAvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourierAvailability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourierAvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courier<T extends CourierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourierDefaultArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourierAvailability model
   */
  interface CourierAvailabilityFieldRefs {
    readonly id: FieldRef<"CourierAvailability", 'String'>
    readonly courierId: FieldRef<"CourierAvailability", 'String'>
    readonly status: FieldRef<"CourierAvailability", 'CourierAvailabilityStatus'>
    readonly startTime: FieldRef<"CourierAvailability", 'DateTime'>
    readonly endTime: FieldRef<"CourierAvailability", 'DateTime'>
    readonly note: FieldRef<"CourierAvailability", 'String'>
    readonly createdAt: FieldRef<"CourierAvailability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourierAvailability findUnique
   */
  export type CourierAvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierAvailability
     */
    select?: CourierAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierAvailability
     */
    omit?: CourierAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which CourierAvailability to fetch.
     */
    where: CourierAvailabilityWhereUniqueInput
  }

  /**
   * CourierAvailability findUniqueOrThrow
   */
  export type CourierAvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierAvailability
     */
    select?: CourierAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierAvailability
     */
    omit?: CourierAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which CourierAvailability to fetch.
     */
    where: CourierAvailabilityWhereUniqueInput
  }

  /**
   * CourierAvailability findFirst
   */
  export type CourierAvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierAvailability
     */
    select?: CourierAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierAvailability
     */
    omit?: CourierAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which CourierAvailability to fetch.
     */
    where?: CourierAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourierAvailabilities to fetch.
     */
    orderBy?: CourierAvailabilityOrderByWithRelationInput | CourierAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourierAvailabilities.
     */
    cursor?: CourierAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourierAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourierAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourierAvailabilities.
     */
    distinct?: CourierAvailabilityScalarFieldEnum | CourierAvailabilityScalarFieldEnum[]
  }

  /**
   * CourierAvailability findFirstOrThrow
   */
  export type CourierAvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierAvailability
     */
    select?: CourierAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierAvailability
     */
    omit?: CourierAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which CourierAvailability to fetch.
     */
    where?: CourierAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourierAvailabilities to fetch.
     */
    orderBy?: CourierAvailabilityOrderByWithRelationInput | CourierAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourierAvailabilities.
     */
    cursor?: CourierAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourierAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourierAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourierAvailabilities.
     */
    distinct?: CourierAvailabilityScalarFieldEnum | CourierAvailabilityScalarFieldEnum[]
  }

  /**
   * CourierAvailability findMany
   */
  export type CourierAvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierAvailability
     */
    select?: CourierAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierAvailability
     */
    omit?: CourierAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which CourierAvailabilities to fetch.
     */
    where?: CourierAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourierAvailabilities to fetch.
     */
    orderBy?: CourierAvailabilityOrderByWithRelationInput | CourierAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourierAvailabilities.
     */
    cursor?: CourierAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourierAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourierAvailabilities.
     */
    skip?: number
    distinct?: CourierAvailabilityScalarFieldEnum | CourierAvailabilityScalarFieldEnum[]
  }

  /**
   * CourierAvailability create
   */
  export type CourierAvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierAvailability
     */
    select?: CourierAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierAvailability
     */
    omit?: CourierAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a CourierAvailability.
     */
    data: XOR<CourierAvailabilityCreateInput, CourierAvailabilityUncheckedCreateInput>
  }

  /**
   * CourierAvailability createMany
   */
  export type CourierAvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourierAvailabilities.
     */
    data: CourierAvailabilityCreateManyInput | CourierAvailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourierAvailability createManyAndReturn
   */
  export type CourierAvailabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierAvailability
     */
    select?: CourierAvailabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourierAvailability
     */
    omit?: CourierAvailabilityOmit<ExtArgs> | null
    /**
     * The data used to create many CourierAvailabilities.
     */
    data: CourierAvailabilityCreateManyInput | CourierAvailabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierAvailabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourierAvailability update
   */
  export type CourierAvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierAvailability
     */
    select?: CourierAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierAvailability
     */
    omit?: CourierAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a CourierAvailability.
     */
    data: XOR<CourierAvailabilityUpdateInput, CourierAvailabilityUncheckedUpdateInput>
    /**
     * Choose, which CourierAvailability to update.
     */
    where: CourierAvailabilityWhereUniqueInput
  }

  /**
   * CourierAvailability updateMany
   */
  export type CourierAvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourierAvailabilities.
     */
    data: XOR<CourierAvailabilityUpdateManyMutationInput, CourierAvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which CourierAvailabilities to update
     */
    where?: CourierAvailabilityWhereInput
    /**
     * Limit how many CourierAvailabilities to update.
     */
    limit?: number
  }

  /**
   * CourierAvailability updateManyAndReturn
   */
  export type CourierAvailabilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierAvailability
     */
    select?: CourierAvailabilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourierAvailability
     */
    omit?: CourierAvailabilityOmit<ExtArgs> | null
    /**
     * The data used to update CourierAvailabilities.
     */
    data: XOR<CourierAvailabilityUpdateManyMutationInput, CourierAvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which CourierAvailabilities to update
     */
    where?: CourierAvailabilityWhereInput
    /**
     * Limit how many CourierAvailabilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierAvailabilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourierAvailability upsert
   */
  export type CourierAvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierAvailability
     */
    select?: CourierAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierAvailability
     */
    omit?: CourierAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierAvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the CourierAvailability to update in case it exists.
     */
    where: CourierAvailabilityWhereUniqueInput
    /**
     * In case the CourierAvailability found by the `where` argument doesn't exist, create a new CourierAvailability with this data.
     */
    create: XOR<CourierAvailabilityCreateInput, CourierAvailabilityUncheckedCreateInput>
    /**
     * In case the CourierAvailability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourierAvailabilityUpdateInput, CourierAvailabilityUncheckedUpdateInput>
  }

  /**
   * CourierAvailability delete
   */
  export type CourierAvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierAvailability
     */
    select?: CourierAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierAvailability
     */
    omit?: CourierAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierAvailabilityInclude<ExtArgs> | null
    /**
     * Filter which CourierAvailability to delete.
     */
    where: CourierAvailabilityWhereUniqueInput
  }

  /**
   * CourierAvailability deleteMany
   */
  export type CourierAvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourierAvailabilities to delete
     */
    where?: CourierAvailabilityWhereInput
    /**
     * Limit how many CourierAvailabilities to delete.
     */
    limit?: number
  }

  /**
   * CourierAvailability without action
   */
  export type CourierAvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierAvailability
     */
    select?: CourierAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierAvailability
     */
    omit?: CourierAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierAvailabilityInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryTimeWindow
   */

  export type AggregateDeliveryTimeWindow = {
    _count: DeliveryTimeWindowCountAggregateOutputType | null
    _avg: DeliveryTimeWindowAvgAggregateOutputType | null
    _sum: DeliveryTimeWindowSumAggregateOutputType | null
    _min: DeliveryTimeWindowMinAggregateOutputType | null
    _max: DeliveryTimeWindowMaxAggregateOutputType | null
  }

  export type DeliveryTimeWindowAvgAggregateOutputType = {
    priorityFactor: number | null
  }

  export type DeliveryTimeWindowSumAggregateOutputType = {
    priorityFactor: number | null
  }

  export type DeliveryTimeWindowMinAggregateOutputType = {
    id: string | null
    name: string | null
    startTime: string | null
    endTime: string | null
    description: string | null
    priorityFactor: number | null
  }

  export type DeliveryTimeWindowMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startTime: string | null
    endTime: string | null
    description: string | null
    priorityFactor: number | null
  }

  export type DeliveryTimeWindowCountAggregateOutputType = {
    id: number
    name: number
    startTime: number
    endTime: number
    description: number
    priorityFactor: number
    _all: number
  }


  export type DeliveryTimeWindowAvgAggregateInputType = {
    priorityFactor?: true
  }

  export type DeliveryTimeWindowSumAggregateInputType = {
    priorityFactor?: true
  }

  export type DeliveryTimeWindowMinAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    description?: true
    priorityFactor?: true
  }

  export type DeliveryTimeWindowMaxAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    description?: true
    priorityFactor?: true
  }

  export type DeliveryTimeWindowCountAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    description?: true
    priorityFactor?: true
    _all?: true
  }

  export type DeliveryTimeWindowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryTimeWindow to aggregate.
     */
    where?: DeliveryTimeWindowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTimeWindows to fetch.
     */
    orderBy?: DeliveryTimeWindowOrderByWithRelationInput | DeliveryTimeWindowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryTimeWindowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTimeWindows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTimeWindows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryTimeWindows
    **/
    _count?: true | DeliveryTimeWindowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryTimeWindowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryTimeWindowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryTimeWindowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryTimeWindowMaxAggregateInputType
  }

  export type GetDeliveryTimeWindowAggregateType<T extends DeliveryTimeWindowAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryTimeWindow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryTimeWindow[P]>
      : GetScalarType<T[P], AggregateDeliveryTimeWindow[P]>
  }




  export type DeliveryTimeWindowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryTimeWindowWhereInput
    orderBy?: DeliveryTimeWindowOrderByWithAggregationInput | DeliveryTimeWindowOrderByWithAggregationInput[]
    by: DeliveryTimeWindowScalarFieldEnum[] | DeliveryTimeWindowScalarFieldEnum
    having?: DeliveryTimeWindowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryTimeWindowCountAggregateInputType | true
    _avg?: DeliveryTimeWindowAvgAggregateInputType
    _sum?: DeliveryTimeWindowSumAggregateInputType
    _min?: DeliveryTimeWindowMinAggregateInputType
    _max?: DeliveryTimeWindowMaxAggregateInputType
  }

  export type DeliveryTimeWindowGroupByOutputType = {
    id: string
    name: string
    startTime: string
    endTime: string
    description: string | null
    priorityFactor: number
    _count: DeliveryTimeWindowCountAggregateOutputType | null
    _avg: DeliveryTimeWindowAvgAggregateOutputType | null
    _sum: DeliveryTimeWindowSumAggregateOutputType | null
    _min: DeliveryTimeWindowMinAggregateOutputType | null
    _max: DeliveryTimeWindowMaxAggregateOutputType | null
  }

  type GetDeliveryTimeWindowGroupByPayload<T extends DeliveryTimeWindowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryTimeWindowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryTimeWindowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryTimeWindowGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryTimeWindowGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryTimeWindowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    description?: boolean
    priorityFactor?: boolean
    orders?: boolean | DeliveryTimeWindow$ordersArgs<ExtArgs>
    _count?: boolean | DeliveryTimeWindowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryTimeWindow"]>

  export type DeliveryTimeWindowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    description?: boolean
    priorityFactor?: boolean
  }, ExtArgs["result"]["deliveryTimeWindow"]>

  export type DeliveryTimeWindowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    description?: boolean
    priorityFactor?: boolean
  }, ExtArgs["result"]["deliveryTimeWindow"]>

  export type DeliveryTimeWindowSelectScalar = {
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    description?: boolean
    priorityFactor?: boolean
  }

  export type DeliveryTimeWindowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startTime" | "endTime" | "description" | "priorityFactor", ExtArgs["result"]["deliveryTimeWindow"]>
  export type DeliveryTimeWindowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | DeliveryTimeWindow$ordersArgs<ExtArgs>
    _count?: boolean | DeliveryTimeWindowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeliveryTimeWindowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DeliveryTimeWindowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DeliveryTimeWindowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryTimeWindow"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startTime: string
      endTime: string
      description: string | null
      priorityFactor: number
    }, ExtArgs["result"]["deliveryTimeWindow"]>
    composites: {}
  }

  type DeliveryTimeWindowGetPayload<S extends boolean | null | undefined | DeliveryTimeWindowDefaultArgs> = $Result.GetResult<Prisma.$DeliveryTimeWindowPayload, S>

  type DeliveryTimeWindowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryTimeWindowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryTimeWindowCountAggregateInputType | true
    }

  export interface DeliveryTimeWindowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryTimeWindow'], meta: { name: 'DeliveryTimeWindow' } }
    /**
     * Find zero or one DeliveryTimeWindow that matches the filter.
     * @param {DeliveryTimeWindowFindUniqueArgs} args - Arguments to find a DeliveryTimeWindow
     * @example
     * // Get one DeliveryTimeWindow
     * const deliveryTimeWindow = await prisma.deliveryTimeWindow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryTimeWindowFindUniqueArgs>(args: SelectSubset<T, DeliveryTimeWindowFindUniqueArgs<ExtArgs>>): Prisma__DeliveryTimeWindowClient<$Result.GetResult<Prisma.$DeliveryTimeWindowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryTimeWindow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryTimeWindowFindUniqueOrThrowArgs} args - Arguments to find a DeliveryTimeWindow
     * @example
     * // Get one DeliveryTimeWindow
     * const deliveryTimeWindow = await prisma.deliveryTimeWindow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryTimeWindowFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryTimeWindowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryTimeWindowClient<$Result.GetResult<Prisma.$DeliveryTimeWindowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryTimeWindow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTimeWindowFindFirstArgs} args - Arguments to find a DeliveryTimeWindow
     * @example
     * // Get one DeliveryTimeWindow
     * const deliveryTimeWindow = await prisma.deliveryTimeWindow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryTimeWindowFindFirstArgs>(args?: SelectSubset<T, DeliveryTimeWindowFindFirstArgs<ExtArgs>>): Prisma__DeliveryTimeWindowClient<$Result.GetResult<Prisma.$DeliveryTimeWindowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryTimeWindow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTimeWindowFindFirstOrThrowArgs} args - Arguments to find a DeliveryTimeWindow
     * @example
     * // Get one DeliveryTimeWindow
     * const deliveryTimeWindow = await prisma.deliveryTimeWindow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryTimeWindowFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryTimeWindowFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryTimeWindowClient<$Result.GetResult<Prisma.$DeliveryTimeWindowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryTimeWindows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTimeWindowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryTimeWindows
     * const deliveryTimeWindows = await prisma.deliveryTimeWindow.findMany()
     * 
     * // Get first 10 DeliveryTimeWindows
     * const deliveryTimeWindows = await prisma.deliveryTimeWindow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryTimeWindowWithIdOnly = await prisma.deliveryTimeWindow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryTimeWindowFindManyArgs>(args?: SelectSubset<T, DeliveryTimeWindowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTimeWindowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryTimeWindow.
     * @param {DeliveryTimeWindowCreateArgs} args - Arguments to create a DeliveryTimeWindow.
     * @example
     * // Create one DeliveryTimeWindow
     * const DeliveryTimeWindow = await prisma.deliveryTimeWindow.create({
     *   data: {
     *     // ... data to create a DeliveryTimeWindow
     *   }
     * })
     * 
     */
    create<T extends DeliveryTimeWindowCreateArgs>(args: SelectSubset<T, DeliveryTimeWindowCreateArgs<ExtArgs>>): Prisma__DeliveryTimeWindowClient<$Result.GetResult<Prisma.$DeliveryTimeWindowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryTimeWindows.
     * @param {DeliveryTimeWindowCreateManyArgs} args - Arguments to create many DeliveryTimeWindows.
     * @example
     * // Create many DeliveryTimeWindows
     * const deliveryTimeWindow = await prisma.deliveryTimeWindow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryTimeWindowCreateManyArgs>(args?: SelectSubset<T, DeliveryTimeWindowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryTimeWindows and returns the data saved in the database.
     * @param {DeliveryTimeWindowCreateManyAndReturnArgs} args - Arguments to create many DeliveryTimeWindows.
     * @example
     * // Create many DeliveryTimeWindows
     * const deliveryTimeWindow = await prisma.deliveryTimeWindow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryTimeWindows and only return the `id`
     * const deliveryTimeWindowWithIdOnly = await prisma.deliveryTimeWindow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryTimeWindowCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryTimeWindowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTimeWindowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryTimeWindow.
     * @param {DeliveryTimeWindowDeleteArgs} args - Arguments to delete one DeliveryTimeWindow.
     * @example
     * // Delete one DeliveryTimeWindow
     * const DeliveryTimeWindow = await prisma.deliveryTimeWindow.delete({
     *   where: {
     *     // ... filter to delete one DeliveryTimeWindow
     *   }
     * })
     * 
     */
    delete<T extends DeliveryTimeWindowDeleteArgs>(args: SelectSubset<T, DeliveryTimeWindowDeleteArgs<ExtArgs>>): Prisma__DeliveryTimeWindowClient<$Result.GetResult<Prisma.$DeliveryTimeWindowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryTimeWindow.
     * @param {DeliveryTimeWindowUpdateArgs} args - Arguments to update one DeliveryTimeWindow.
     * @example
     * // Update one DeliveryTimeWindow
     * const deliveryTimeWindow = await prisma.deliveryTimeWindow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryTimeWindowUpdateArgs>(args: SelectSubset<T, DeliveryTimeWindowUpdateArgs<ExtArgs>>): Prisma__DeliveryTimeWindowClient<$Result.GetResult<Prisma.$DeliveryTimeWindowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryTimeWindows.
     * @param {DeliveryTimeWindowDeleteManyArgs} args - Arguments to filter DeliveryTimeWindows to delete.
     * @example
     * // Delete a few DeliveryTimeWindows
     * const { count } = await prisma.deliveryTimeWindow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryTimeWindowDeleteManyArgs>(args?: SelectSubset<T, DeliveryTimeWindowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryTimeWindows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTimeWindowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryTimeWindows
     * const deliveryTimeWindow = await prisma.deliveryTimeWindow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryTimeWindowUpdateManyArgs>(args: SelectSubset<T, DeliveryTimeWindowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryTimeWindows and returns the data updated in the database.
     * @param {DeliveryTimeWindowUpdateManyAndReturnArgs} args - Arguments to update many DeliveryTimeWindows.
     * @example
     * // Update many DeliveryTimeWindows
     * const deliveryTimeWindow = await prisma.deliveryTimeWindow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryTimeWindows and only return the `id`
     * const deliveryTimeWindowWithIdOnly = await prisma.deliveryTimeWindow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryTimeWindowUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryTimeWindowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTimeWindowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryTimeWindow.
     * @param {DeliveryTimeWindowUpsertArgs} args - Arguments to update or create a DeliveryTimeWindow.
     * @example
     * // Update or create a DeliveryTimeWindow
     * const deliveryTimeWindow = await prisma.deliveryTimeWindow.upsert({
     *   create: {
     *     // ... data to create a DeliveryTimeWindow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryTimeWindow we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryTimeWindowUpsertArgs>(args: SelectSubset<T, DeliveryTimeWindowUpsertArgs<ExtArgs>>): Prisma__DeliveryTimeWindowClient<$Result.GetResult<Prisma.$DeliveryTimeWindowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryTimeWindows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTimeWindowCountArgs} args - Arguments to filter DeliveryTimeWindows to count.
     * @example
     * // Count the number of DeliveryTimeWindows
     * const count = await prisma.deliveryTimeWindow.count({
     *   where: {
     *     // ... the filter for the DeliveryTimeWindows we want to count
     *   }
     * })
    **/
    count<T extends DeliveryTimeWindowCountArgs>(
      args?: Subset<T, DeliveryTimeWindowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryTimeWindowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryTimeWindow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTimeWindowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryTimeWindowAggregateArgs>(args: Subset<T, DeliveryTimeWindowAggregateArgs>): Prisma.PrismaPromise<GetDeliveryTimeWindowAggregateType<T>>

    /**
     * Group by DeliveryTimeWindow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTimeWindowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryTimeWindowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryTimeWindowGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryTimeWindowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryTimeWindowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryTimeWindowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryTimeWindow model
   */
  readonly fields: DeliveryTimeWindowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryTimeWindow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryTimeWindowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends DeliveryTimeWindow$ordersArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryTimeWindow$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryTimeWindow model
   */
  interface DeliveryTimeWindowFieldRefs {
    readonly id: FieldRef<"DeliveryTimeWindow", 'String'>
    readonly name: FieldRef<"DeliveryTimeWindow", 'String'>
    readonly startTime: FieldRef<"DeliveryTimeWindow", 'String'>
    readonly endTime: FieldRef<"DeliveryTimeWindow", 'String'>
    readonly description: FieldRef<"DeliveryTimeWindow", 'String'>
    readonly priorityFactor: FieldRef<"DeliveryTimeWindow", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryTimeWindow findUnique
   */
  export type DeliveryTimeWindowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTimeWindow
     */
    select?: DeliveryTimeWindowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTimeWindow
     */
    omit?: DeliveryTimeWindowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTimeWindowInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTimeWindow to fetch.
     */
    where: DeliveryTimeWindowWhereUniqueInput
  }

  /**
   * DeliveryTimeWindow findUniqueOrThrow
   */
  export type DeliveryTimeWindowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTimeWindow
     */
    select?: DeliveryTimeWindowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTimeWindow
     */
    omit?: DeliveryTimeWindowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTimeWindowInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTimeWindow to fetch.
     */
    where: DeliveryTimeWindowWhereUniqueInput
  }

  /**
   * DeliveryTimeWindow findFirst
   */
  export type DeliveryTimeWindowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTimeWindow
     */
    select?: DeliveryTimeWindowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTimeWindow
     */
    omit?: DeliveryTimeWindowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTimeWindowInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTimeWindow to fetch.
     */
    where?: DeliveryTimeWindowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTimeWindows to fetch.
     */
    orderBy?: DeliveryTimeWindowOrderByWithRelationInput | DeliveryTimeWindowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryTimeWindows.
     */
    cursor?: DeliveryTimeWindowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTimeWindows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTimeWindows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryTimeWindows.
     */
    distinct?: DeliveryTimeWindowScalarFieldEnum | DeliveryTimeWindowScalarFieldEnum[]
  }

  /**
   * DeliveryTimeWindow findFirstOrThrow
   */
  export type DeliveryTimeWindowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTimeWindow
     */
    select?: DeliveryTimeWindowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTimeWindow
     */
    omit?: DeliveryTimeWindowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTimeWindowInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTimeWindow to fetch.
     */
    where?: DeliveryTimeWindowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTimeWindows to fetch.
     */
    orderBy?: DeliveryTimeWindowOrderByWithRelationInput | DeliveryTimeWindowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryTimeWindows.
     */
    cursor?: DeliveryTimeWindowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTimeWindows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTimeWindows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryTimeWindows.
     */
    distinct?: DeliveryTimeWindowScalarFieldEnum | DeliveryTimeWindowScalarFieldEnum[]
  }

  /**
   * DeliveryTimeWindow findMany
   */
  export type DeliveryTimeWindowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTimeWindow
     */
    select?: DeliveryTimeWindowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTimeWindow
     */
    omit?: DeliveryTimeWindowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTimeWindowInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTimeWindows to fetch.
     */
    where?: DeliveryTimeWindowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTimeWindows to fetch.
     */
    orderBy?: DeliveryTimeWindowOrderByWithRelationInput | DeliveryTimeWindowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryTimeWindows.
     */
    cursor?: DeliveryTimeWindowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTimeWindows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTimeWindows.
     */
    skip?: number
    distinct?: DeliveryTimeWindowScalarFieldEnum | DeliveryTimeWindowScalarFieldEnum[]
  }

  /**
   * DeliveryTimeWindow create
   */
  export type DeliveryTimeWindowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTimeWindow
     */
    select?: DeliveryTimeWindowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTimeWindow
     */
    omit?: DeliveryTimeWindowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTimeWindowInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryTimeWindow.
     */
    data: XOR<DeliveryTimeWindowCreateInput, DeliveryTimeWindowUncheckedCreateInput>
  }

  /**
   * DeliveryTimeWindow createMany
   */
  export type DeliveryTimeWindowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryTimeWindows.
     */
    data: DeliveryTimeWindowCreateManyInput | DeliveryTimeWindowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryTimeWindow createManyAndReturn
   */
  export type DeliveryTimeWindowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTimeWindow
     */
    select?: DeliveryTimeWindowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTimeWindow
     */
    omit?: DeliveryTimeWindowOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryTimeWindows.
     */
    data: DeliveryTimeWindowCreateManyInput | DeliveryTimeWindowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryTimeWindow update
   */
  export type DeliveryTimeWindowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTimeWindow
     */
    select?: DeliveryTimeWindowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTimeWindow
     */
    omit?: DeliveryTimeWindowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTimeWindowInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryTimeWindow.
     */
    data: XOR<DeliveryTimeWindowUpdateInput, DeliveryTimeWindowUncheckedUpdateInput>
    /**
     * Choose, which DeliveryTimeWindow to update.
     */
    where: DeliveryTimeWindowWhereUniqueInput
  }

  /**
   * DeliveryTimeWindow updateMany
   */
  export type DeliveryTimeWindowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryTimeWindows.
     */
    data: XOR<DeliveryTimeWindowUpdateManyMutationInput, DeliveryTimeWindowUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryTimeWindows to update
     */
    where?: DeliveryTimeWindowWhereInput
    /**
     * Limit how many DeliveryTimeWindows to update.
     */
    limit?: number
  }

  /**
   * DeliveryTimeWindow updateManyAndReturn
   */
  export type DeliveryTimeWindowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTimeWindow
     */
    select?: DeliveryTimeWindowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTimeWindow
     */
    omit?: DeliveryTimeWindowOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryTimeWindows.
     */
    data: XOR<DeliveryTimeWindowUpdateManyMutationInput, DeliveryTimeWindowUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryTimeWindows to update
     */
    where?: DeliveryTimeWindowWhereInput
    /**
     * Limit how many DeliveryTimeWindows to update.
     */
    limit?: number
  }

  /**
   * DeliveryTimeWindow upsert
   */
  export type DeliveryTimeWindowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTimeWindow
     */
    select?: DeliveryTimeWindowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTimeWindow
     */
    omit?: DeliveryTimeWindowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTimeWindowInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryTimeWindow to update in case it exists.
     */
    where: DeliveryTimeWindowWhereUniqueInput
    /**
     * In case the DeliveryTimeWindow found by the `where` argument doesn't exist, create a new DeliveryTimeWindow with this data.
     */
    create: XOR<DeliveryTimeWindowCreateInput, DeliveryTimeWindowUncheckedCreateInput>
    /**
     * In case the DeliveryTimeWindow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryTimeWindowUpdateInput, DeliveryTimeWindowUncheckedUpdateInput>
  }

  /**
   * DeliveryTimeWindow delete
   */
  export type DeliveryTimeWindowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTimeWindow
     */
    select?: DeliveryTimeWindowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTimeWindow
     */
    omit?: DeliveryTimeWindowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTimeWindowInclude<ExtArgs> | null
    /**
     * Filter which DeliveryTimeWindow to delete.
     */
    where: DeliveryTimeWindowWhereUniqueInput
  }

  /**
   * DeliveryTimeWindow deleteMany
   */
  export type DeliveryTimeWindowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryTimeWindows to delete
     */
    where?: DeliveryTimeWindowWhereInput
    /**
     * Limit how many DeliveryTimeWindows to delete.
     */
    limit?: number
  }

  /**
   * DeliveryTimeWindow.orders
   */
  export type DeliveryTimeWindow$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * DeliveryTimeWindow without action
   */
  export type DeliveryTimeWindowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTimeWindow
     */
    select?: DeliveryTimeWindowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTimeWindow
     */
    omit?: DeliveryTimeWindowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTimeWindowInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryRoute
   */

  export type AggregateDeliveryRoute = {
    _count: DeliveryRouteCountAggregateOutputType | null
    _avg: DeliveryRouteAvgAggregateOutputType | null
    _sum: DeliveryRouteSumAggregateOutputType | null
    _min: DeliveryRouteMinAggregateOutputType | null
    _max: DeliveryRouteMaxAggregateOutputType | null
  }

  export type DeliveryRouteAvgAggregateOutputType = {
    totalDistance: number | null
    totalDuration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
  }

  export type DeliveryRouteSumAggregateOutputType = {
    totalDistance: number | null
    totalDuration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
  }

  export type DeliveryRouteMinAggregateOutputType = {
    id: string | null
    courierId: string | null
    name: string | null
    createdAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    status: $Enums.Status | null
    totalDistance: number | null
    totalDuration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
  }

  export type DeliveryRouteMaxAggregateOutputType = {
    id: string | null
    courierId: string | null
    name: string | null
    createdAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    status: $Enums.Status | null
    totalDistance: number | null
    totalDuration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
  }

  export type DeliveryRouteCountAggregateOutputType = {
    id: number
    courierId: number
    name: number
    createdAt: number
    startedAt: number
    completedAt: number
    status: number
    totalDistance: number
    totalDuration: number
    startLatitude: number
    startLongitude: number
    endLatitude: number
    endLongitude: number
    routePath: number
    _all: number
  }


  export type DeliveryRouteAvgAggregateInputType = {
    totalDistance?: true
    totalDuration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
  }

  export type DeliveryRouteSumAggregateInputType = {
    totalDistance?: true
    totalDuration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
  }

  export type DeliveryRouteMinAggregateInputType = {
    id?: true
    courierId?: true
    name?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
    status?: true
    totalDistance?: true
    totalDuration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
  }

  export type DeliveryRouteMaxAggregateInputType = {
    id?: true
    courierId?: true
    name?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
    status?: true
    totalDistance?: true
    totalDuration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
  }

  export type DeliveryRouteCountAggregateInputType = {
    id?: true
    courierId?: true
    name?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
    status?: true
    totalDistance?: true
    totalDuration?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    routePath?: true
    _all?: true
  }

  export type DeliveryRouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryRoute to aggregate.
     */
    where?: DeliveryRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryRoutes to fetch.
     */
    orderBy?: DeliveryRouteOrderByWithRelationInput | DeliveryRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryRoutes
    **/
    _count?: true | DeliveryRouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryRouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryRouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryRouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryRouteMaxAggregateInputType
  }

  export type GetDeliveryRouteAggregateType<T extends DeliveryRouteAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryRoute[P]>
      : GetScalarType<T[P], AggregateDeliveryRoute[P]>
  }




  export type DeliveryRouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryRouteWhereInput
    orderBy?: DeliveryRouteOrderByWithAggregationInput | DeliveryRouteOrderByWithAggregationInput[]
    by: DeliveryRouteScalarFieldEnum[] | DeliveryRouteScalarFieldEnum
    having?: DeliveryRouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryRouteCountAggregateInputType | true
    _avg?: DeliveryRouteAvgAggregateInputType
    _sum?: DeliveryRouteSumAggregateInputType
    _min?: DeliveryRouteMinAggregateInputType
    _max?: DeliveryRouteMaxAggregateInputType
  }

  export type DeliveryRouteGroupByOutputType = {
    id: string
    courierId: string
    name: string | null
    createdAt: Date
    startedAt: Date | null
    completedAt: Date | null
    status: $Enums.Status
    totalDistance: number | null
    totalDuration: number | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    routePath: JsonValue | null
    _count: DeliveryRouteCountAggregateOutputType | null
    _avg: DeliveryRouteAvgAggregateOutputType | null
    _sum: DeliveryRouteSumAggregateOutputType | null
    _min: DeliveryRouteMinAggregateOutputType | null
    _max: DeliveryRouteMaxAggregateOutputType | null
  }

  type GetDeliveryRouteGroupByPayload<T extends DeliveryRouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryRouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryRouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryRouteGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryRouteGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryRouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courierId?: boolean
    name?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    totalDistance?: boolean
    totalDuration?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    routePath?: boolean
    courier?: boolean | CourierDefaultArgs<ExtArgs>
    deliveries?: boolean | DeliveryRoute$deliveriesArgs<ExtArgs>
    _count?: boolean | DeliveryRouteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryRoute"]>

  export type DeliveryRouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courierId?: boolean
    name?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    totalDistance?: boolean
    totalDuration?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    routePath?: boolean
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryRoute"]>

  export type DeliveryRouteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courierId?: boolean
    name?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    totalDistance?: boolean
    totalDuration?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    routePath?: boolean
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryRoute"]>

  export type DeliveryRouteSelectScalar = {
    id?: boolean
    courierId?: boolean
    name?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    totalDistance?: boolean
    totalDuration?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    routePath?: boolean
  }

  export type DeliveryRouteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courierId" | "name" | "createdAt" | "startedAt" | "completedAt" | "status" | "totalDistance" | "totalDuration" | "startLatitude" | "startLongitude" | "endLatitude" | "endLongitude" | "routePath", ExtArgs["result"]["deliveryRoute"]>
  export type DeliveryRouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courier?: boolean | CourierDefaultArgs<ExtArgs>
    deliveries?: boolean | DeliveryRoute$deliveriesArgs<ExtArgs>
    _count?: boolean | DeliveryRouteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeliveryRouteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }
  export type DeliveryRouteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courier?: boolean | CourierDefaultArgs<ExtArgs>
  }

  export type $DeliveryRoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryRoute"
    objects: {
      courier: Prisma.$CourierPayload<ExtArgs>
      deliveries: Prisma.$DeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courierId: string
      name: string | null
      createdAt: Date
      startedAt: Date | null
      completedAt: Date | null
      status: $Enums.Status
      totalDistance: number | null
      totalDuration: number | null
      startLatitude: number | null
      startLongitude: number | null
      endLatitude: number | null
      endLongitude: number | null
      routePath: Prisma.JsonValue | null
    }, ExtArgs["result"]["deliveryRoute"]>
    composites: {}
  }

  type DeliveryRouteGetPayload<S extends boolean | null | undefined | DeliveryRouteDefaultArgs> = $Result.GetResult<Prisma.$DeliveryRoutePayload, S>

  type DeliveryRouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryRouteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryRouteCountAggregateInputType | true
    }

  export interface DeliveryRouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryRoute'], meta: { name: 'DeliveryRoute' } }
    /**
     * Find zero or one DeliveryRoute that matches the filter.
     * @param {DeliveryRouteFindUniqueArgs} args - Arguments to find a DeliveryRoute
     * @example
     * // Get one DeliveryRoute
     * const deliveryRoute = await prisma.deliveryRoute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryRouteFindUniqueArgs>(args: SelectSubset<T, DeliveryRouteFindUniqueArgs<ExtArgs>>): Prisma__DeliveryRouteClient<$Result.GetResult<Prisma.$DeliveryRoutePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryRoute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryRouteFindUniqueOrThrowArgs} args - Arguments to find a DeliveryRoute
     * @example
     * // Get one DeliveryRoute
     * const deliveryRoute = await prisma.deliveryRoute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryRouteFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryRouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryRouteClient<$Result.GetResult<Prisma.$DeliveryRoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryRoute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryRouteFindFirstArgs} args - Arguments to find a DeliveryRoute
     * @example
     * // Get one DeliveryRoute
     * const deliveryRoute = await prisma.deliveryRoute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryRouteFindFirstArgs>(args?: SelectSubset<T, DeliveryRouteFindFirstArgs<ExtArgs>>): Prisma__DeliveryRouteClient<$Result.GetResult<Prisma.$DeliveryRoutePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryRoute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryRouteFindFirstOrThrowArgs} args - Arguments to find a DeliveryRoute
     * @example
     * // Get one DeliveryRoute
     * const deliveryRoute = await prisma.deliveryRoute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryRouteFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryRouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryRouteClient<$Result.GetResult<Prisma.$DeliveryRoutePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryRoutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryRouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryRoutes
     * const deliveryRoutes = await prisma.deliveryRoute.findMany()
     * 
     * // Get first 10 DeliveryRoutes
     * const deliveryRoutes = await prisma.deliveryRoute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryRouteWithIdOnly = await prisma.deliveryRoute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryRouteFindManyArgs>(args?: SelectSubset<T, DeliveryRouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryRoutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryRoute.
     * @param {DeliveryRouteCreateArgs} args - Arguments to create a DeliveryRoute.
     * @example
     * // Create one DeliveryRoute
     * const DeliveryRoute = await prisma.deliveryRoute.create({
     *   data: {
     *     // ... data to create a DeliveryRoute
     *   }
     * })
     * 
     */
    create<T extends DeliveryRouteCreateArgs>(args: SelectSubset<T, DeliveryRouteCreateArgs<ExtArgs>>): Prisma__DeliveryRouteClient<$Result.GetResult<Prisma.$DeliveryRoutePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryRoutes.
     * @param {DeliveryRouteCreateManyArgs} args - Arguments to create many DeliveryRoutes.
     * @example
     * // Create many DeliveryRoutes
     * const deliveryRoute = await prisma.deliveryRoute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryRouteCreateManyArgs>(args?: SelectSubset<T, DeliveryRouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryRoutes and returns the data saved in the database.
     * @param {DeliveryRouteCreateManyAndReturnArgs} args - Arguments to create many DeliveryRoutes.
     * @example
     * // Create many DeliveryRoutes
     * const deliveryRoute = await prisma.deliveryRoute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryRoutes and only return the `id`
     * const deliveryRouteWithIdOnly = await prisma.deliveryRoute.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryRouteCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryRouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryRoutePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryRoute.
     * @param {DeliveryRouteDeleteArgs} args - Arguments to delete one DeliveryRoute.
     * @example
     * // Delete one DeliveryRoute
     * const DeliveryRoute = await prisma.deliveryRoute.delete({
     *   where: {
     *     // ... filter to delete one DeliveryRoute
     *   }
     * })
     * 
     */
    delete<T extends DeliveryRouteDeleteArgs>(args: SelectSubset<T, DeliveryRouteDeleteArgs<ExtArgs>>): Prisma__DeliveryRouteClient<$Result.GetResult<Prisma.$DeliveryRoutePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryRoute.
     * @param {DeliveryRouteUpdateArgs} args - Arguments to update one DeliveryRoute.
     * @example
     * // Update one DeliveryRoute
     * const deliveryRoute = await prisma.deliveryRoute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryRouteUpdateArgs>(args: SelectSubset<T, DeliveryRouteUpdateArgs<ExtArgs>>): Prisma__DeliveryRouteClient<$Result.GetResult<Prisma.$DeliveryRoutePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryRoutes.
     * @param {DeliveryRouteDeleteManyArgs} args - Arguments to filter DeliveryRoutes to delete.
     * @example
     * // Delete a few DeliveryRoutes
     * const { count } = await prisma.deliveryRoute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryRouteDeleteManyArgs>(args?: SelectSubset<T, DeliveryRouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryRouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryRoutes
     * const deliveryRoute = await prisma.deliveryRoute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryRouteUpdateManyArgs>(args: SelectSubset<T, DeliveryRouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryRoutes and returns the data updated in the database.
     * @param {DeliveryRouteUpdateManyAndReturnArgs} args - Arguments to update many DeliveryRoutes.
     * @example
     * // Update many DeliveryRoutes
     * const deliveryRoute = await prisma.deliveryRoute.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryRoutes and only return the `id`
     * const deliveryRouteWithIdOnly = await prisma.deliveryRoute.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryRouteUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryRouteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryRoutePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryRoute.
     * @param {DeliveryRouteUpsertArgs} args - Arguments to update or create a DeliveryRoute.
     * @example
     * // Update or create a DeliveryRoute
     * const deliveryRoute = await prisma.deliveryRoute.upsert({
     *   create: {
     *     // ... data to create a DeliveryRoute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryRoute we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryRouteUpsertArgs>(args: SelectSubset<T, DeliveryRouteUpsertArgs<ExtArgs>>): Prisma__DeliveryRouteClient<$Result.GetResult<Prisma.$DeliveryRoutePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryRouteCountArgs} args - Arguments to filter DeliveryRoutes to count.
     * @example
     * // Count the number of DeliveryRoutes
     * const count = await prisma.deliveryRoute.count({
     *   where: {
     *     // ... the filter for the DeliveryRoutes we want to count
     *   }
     * })
    **/
    count<T extends DeliveryRouteCountArgs>(
      args?: Subset<T, DeliveryRouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryRouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryRouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryRouteAggregateArgs>(args: Subset<T, DeliveryRouteAggregateArgs>): Prisma.PrismaPromise<GetDeliveryRouteAggregateType<T>>

    /**
     * Group by DeliveryRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryRouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryRouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryRouteGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryRouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryRouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryRoute model
   */
  readonly fields: DeliveryRouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryRoute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryRouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courier<T extends CourierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourierDefaultArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deliveries<T extends DeliveryRoute$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryRoute$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryRoute model
   */
  interface DeliveryRouteFieldRefs {
    readonly id: FieldRef<"DeliveryRoute", 'String'>
    readonly courierId: FieldRef<"DeliveryRoute", 'String'>
    readonly name: FieldRef<"DeliveryRoute", 'String'>
    readonly createdAt: FieldRef<"DeliveryRoute", 'DateTime'>
    readonly startedAt: FieldRef<"DeliveryRoute", 'DateTime'>
    readonly completedAt: FieldRef<"DeliveryRoute", 'DateTime'>
    readonly status: FieldRef<"DeliveryRoute", 'Status'>
    readonly totalDistance: FieldRef<"DeliveryRoute", 'Float'>
    readonly totalDuration: FieldRef<"DeliveryRoute", 'Int'>
    readonly startLatitude: FieldRef<"DeliveryRoute", 'Float'>
    readonly startLongitude: FieldRef<"DeliveryRoute", 'Float'>
    readonly endLatitude: FieldRef<"DeliveryRoute", 'Float'>
    readonly endLongitude: FieldRef<"DeliveryRoute", 'Float'>
    readonly routePath: FieldRef<"DeliveryRoute", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryRoute findUnique
   */
  export type DeliveryRouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRoute
     */
    select?: DeliveryRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryRoute
     */
    omit?: DeliveryRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryRouteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryRoute to fetch.
     */
    where: DeliveryRouteWhereUniqueInput
  }

  /**
   * DeliveryRoute findUniqueOrThrow
   */
  export type DeliveryRouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRoute
     */
    select?: DeliveryRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryRoute
     */
    omit?: DeliveryRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryRouteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryRoute to fetch.
     */
    where: DeliveryRouteWhereUniqueInput
  }

  /**
   * DeliveryRoute findFirst
   */
  export type DeliveryRouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRoute
     */
    select?: DeliveryRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryRoute
     */
    omit?: DeliveryRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryRouteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryRoute to fetch.
     */
    where?: DeliveryRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryRoutes to fetch.
     */
    orderBy?: DeliveryRouteOrderByWithRelationInput | DeliveryRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryRoutes.
     */
    cursor?: DeliveryRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryRoutes.
     */
    distinct?: DeliveryRouteScalarFieldEnum | DeliveryRouteScalarFieldEnum[]
  }

  /**
   * DeliveryRoute findFirstOrThrow
   */
  export type DeliveryRouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRoute
     */
    select?: DeliveryRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryRoute
     */
    omit?: DeliveryRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryRouteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryRoute to fetch.
     */
    where?: DeliveryRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryRoutes to fetch.
     */
    orderBy?: DeliveryRouteOrderByWithRelationInput | DeliveryRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryRoutes.
     */
    cursor?: DeliveryRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryRoutes.
     */
    distinct?: DeliveryRouteScalarFieldEnum | DeliveryRouteScalarFieldEnum[]
  }

  /**
   * DeliveryRoute findMany
   */
  export type DeliveryRouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRoute
     */
    select?: DeliveryRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryRoute
     */
    omit?: DeliveryRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryRouteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryRoutes to fetch.
     */
    where?: DeliveryRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryRoutes to fetch.
     */
    orderBy?: DeliveryRouteOrderByWithRelationInput | DeliveryRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryRoutes.
     */
    cursor?: DeliveryRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryRoutes.
     */
    skip?: number
    distinct?: DeliveryRouteScalarFieldEnum | DeliveryRouteScalarFieldEnum[]
  }

  /**
   * DeliveryRoute create
   */
  export type DeliveryRouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRoute
     */
    select?: DeliveryRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryRoute
     */
    omit?: DeliveryRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryRouteInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryRoute.
     */
    data: XOR<DeliveryRouteCreateInput, DeliveryRouteUncheckedCreateInput>
  }

  /**
   * DeliveryRoute createMany
   */
  export type DeliveryRouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryRoutes.
     */
    data: DeliveryRouteCreateManyInput | DeliveryRouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryRoute createManyAndReturn
   */
  export type DeliveryRouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRoute
     */
    select?: DeliveryRouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryRoute
     */
    omit?: DeliveryRouteOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryRoutes.
     */
    data: DeliveryRouteCreateManyInput | DeliveryRouteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryRouteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryRoute update
   */
  export type DeliveryRouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRoute
     */
    select?: DeliveryRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryRoute
     */
    omit?: DeliveryRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryRouteInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryRoute.
     */
    data: XOR<DeliveryRouteUpdateInput, DeliveryRouteUncheckedUpdateInput>
    /**
     * Choose, which DeliveryRoute to update.
     */
    where: DeliveryRouteWhereUniqueInput
  }

  /**
   * DeliveryRoute updateMany
   */
  export type DeliveryRouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryRoutes.
     */
    data: XOR<DeliveryRouteUpdateManyMutationInput, DeliveryRouteUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryRoutes to update
     */
    where?: DeliveryRouteWhereInput
    /**
     * Limit how many DeliveryRoutes to update.
     */
    limit?: number
  }

  /**
   * DeliveryRoute updateManyAndReturn
   */
  export type DeliveryRouteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRoute
     */
    select?: DeliveryRouteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryRoute
     */
    omit?: DeliveryRouteOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryRoutes.
     */
    data: XOR<DeliveryRouteUpdateManyMutationInput, DeliveryRouteUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryRoutes to update
     */
    where?: DeliveryRouteWhereInput
    /**
     * Limit how many DeliveryRoutes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryRouteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryRoute upsert
   */
  export type DeliveryRouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRoute
     */
    select?: DeliveryRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryRoute
     */
    omit?: DeliveryRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryRouteInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryRoute to update in case it exists.
     */
    where: DeliveryRouteWhereUniqueInput
    /**
     * In case the DeliveryRoute found by the `where` argument doesn't exist, create a new DeliveryRoute with this data.
     */
    create: XOR<DeliveryRouteCreateInput, DeliveryRouteUncheckedCreateInput>
    /**
     * In case the DeliveryRoute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryRouteUpdateInput, DeliveryRouteUncheckedUpdateInput>
  }

  /**
   * DeliveryRoute delete
   */
  export type DeliveryRouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRoute
     */
    select?: DeliveryRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryRoute
     */
    omit?: DeliveryRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryRouteInclude<ExtArgs> | null
    /**
     * Filter which DeliveryRoute to delete.
     */
    where: DeliveryRouteWhereUniqueInput
  }

  /**
   * DeliveryRoute deleteMany
   */
  export type DeliveryRouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryRoutes to delete
     */
    where?: DeliveryRouteWhereInput
    /**
     * Limit how many DeliveryRoutes to delete.
     */
    limit?: number
  }

  /**
   * DeliveryRoute.deliveries
   */
  export type DeliveryRoute$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * DeliveryRoute without action
   */
  export type DeliveryRouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryRoute
     */
    select?: DeliveryRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryRoute
     */
    omit?: DeliveryRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryRouteInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    amount: number | null
    currency: string | null
    method: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    reference: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    processedAt: Date | null
    orderId: string | null
    recipientId: string | null
    businessId: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    currency: string | null
    method: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    reference: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    processedAt: Date | null
    orderId: string | null
    recipientId: string | null
    businessId: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    amount: number
    currency: number
    method: number
    status: number
    reference: number
    description: number
    createdAt: number
    updatedAt: number
    processedAt: number
    orderId: number
    recipientId: number
    businessId: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    reference?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    processedAt?: true
    orderId?: true
    recipientId?: true
    businessId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    reference?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    processedAt?: true
    orderId?: true
    recipientId?: true
    businessId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    reference?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    processedAt?: true
    orderId?: true
    recipientId?: true
    businessId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    amount: number
    currency: string
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    reference: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    processedAt: Date | null
    orderId: string | null
    recipientId: string | null
    businessId: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    reference?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
    orderId?: boolean
    recipientId?: boolean
    businessId?: boolean
    order?: boolean | Payment$orderArgs<ExtArgs>
    recipient?: boolean | Payment$recipientArgs<ExtArgs>
    business?: boolean | Payment$businessArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    reference?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
    orderId?: boolean
    recipientId?: boolean
    businessId?: boolean
    order?: boolean | Payment$orderArgs<ExtArgs>
    recipient?: boolean | Payment$recipientArgs<ExtArgs>
    business?: boolean | Payment$businessArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    reference?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
    orderId?: boolean
    recipientId?: boolean
    businessId?: boolean
    order?: boolean | Payment$orderArgs<ExtArgs>
    recipient?: boolean | Payment$recipientArgs<ExtArgs>
    business?: boolean | Payment$businessArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    reference?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
    orderId?: boolean
    recipientId?: boolean
    businessId?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "currency" | "method" | "status" | "reference" | "description" | "createdAt" | "updatedAt" | "processedAt" | "orderId" | "recipientId" | "businessId", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Payment$orderArgs<ExtArgs>
    recipient?: boolean | Payment$recipientArgs<ExtArgs>
    business?: boolean | Payment$businessArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Payment$orderArgs<ExtArgs>
    recipient?: boolean | Payment$recipientArgs<ExtArgs>
    business?: boolean | Payment$businessArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Payment$orderArgs<ExtArgs>
    recipient?: boolean | Payment$recipientArgs<ExtArgs>
    business?: boolean | Payment$businessArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs> | null
      recipient: Prisma.$CourierPayload<ExtArgs> | null
      business: Prisma.$BusinessPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      currency: string
      method: $Enums.PaymentMethod
      status: $Enums.PaymentStatus
      reference: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      processedAt: Date | null
      orderId: string | null
      recipientId: string | null
      businessId: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends Payment$orderArgs<ExtArgs> = {}>(args?: Subset<T, Payment$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recipient<T extends Payment$recipientArgs<ExtArgs> = {}>(args?: Subset<T, Payment$recipientArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    business<T extends Payment$businessArgs<ExtArgs> = {}>(args?: Subset<T, Payment$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly description: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly processedAt: FieldRef<"Payment", 'DateTime'>
    readonly orderId: FieldRef<"Payment", 'String'>
    readonly recipientId: FieldRef<"Payment", 'String'>
    readonly businessId: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.order
   */
  export type Payment$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Payment.recipient
   */
  export type Payment$recipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierInclude<ExtArgs> | null
    where?: CourierWhereInput
  }

  /**
   * Payment.business
   */
  export type Payment$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    description: string | null
    slug: string | null
    imageUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    description: string | null
    slug: string | null
    imageUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    businessId: number
    name: number
    description: number
    slug: number
    imageUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    parentId: number
    _all: number
  }


  export type ProductCategoryMinAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    slug?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    slug?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    slug?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: string
    businessId: string
    name: string
    description: string | null
    slug: string
    imageUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    parentId: string | null
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
    children?: boolean | ProductCategory$childrenArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessId" | "name" | "description" | "slug" | "imageUrl" | "isActive" | "createdAt" | "updatedAt" | "parentId", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
    children?: boolean | ProductCategory$childrenArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
  }
  export type ProductCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
      parent: Prisma.$ProductCategoryPayload<ExtArgs> | null
      children: Prisma.$ProductCategoryPayload<ExtArgs>[]
      products: Prisma.$InventoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      name: string
      description: string | null
      slug: string
      imageUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      parentId: string | null
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories and returns the data updated in the database.
     * @param {ProductCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProductCategories.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends ProductCategory$parentArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$parentArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends ProductCategory$childrenArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends ProductCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'String'>
    readonly businessId: FieldRef<"ProductCategory", 'String'>
    readonly name: FieldRef<"ProductCategory", 'String'>
    readonly description: FieldRef<"ProductCategory", 'String'>
    readonly slug: FieldRef<"ProductCategory", 'String'>
    readonly imageUrl: FieldRef<"ProductCategory", 'String'>
    readonly isActive: FieldRef<"ProductCategory", 'Boolean'>
    readonly createdAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly parentId: FieldRef<"ProductCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory updateManyAndReturn
   */
  export type ProductCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory.parent
   */
  export type ProductCategory$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategory.children
   */
  export type ProductCategory$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory.products
   */
  export type ProductCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    description: string | null
    createdAt: Date | null
    userId: string | null
    targetId: string | null
    targetType: string | null
    ip: string | null
    userAgent: string | null
    adminId: string | null
    severity: string | null
    category: string | null
    isResolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    description: string | null
    createdAt: Date | null
    userId: string | null
    targetId: string | null
    targetType: string | null
    ip: string | null
    userAgent: string | null
    adminId: string | null
    severity: string | null
    category: string | null
    isResolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    action: number
    description: number
    createdAt: number
    userId: number
    targetId: number
    targetType: number
    ip: number
    userAgent: number
    adminId: number
    metadata: number
    severity: number
    category: number
    isResolved: number
    resolvedAt: number
    resolvedBy: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    action?: true
    description?: true
    createdAt?: true
    userId?: true
    targetId?: true
    targetType?: true
    ip?: true
    userAgent?: true
    adminId?: true
    severity?: true
    category?: true
    isResolved?: true
    resolvedAt?: true
    resolvedBy?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    action?: true
    description?: true
    createdAt?: true
    userId?: true
    targetId?: true
    targetType?: true
    ip?: true
    userAgent?: true
    adminId?: true
    severity?: true
    category?: true
    isResolved?: true
    resolvedAt?: true
    resolvedBy?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    action?: true
    description?: true
    createdAt?: true
    userId?: true
    targetId?: true
    targetType?: true
    ip?: true
    userAgent?: true
    adminId?: true
    metadata?: true
    severity?: true
    category?: true
    isResolved?: true
    resolvedAt?: true
    resolvedBy?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    action: string
    description: string
    createdAt: Date
    userId: string | null
    targetId: string | null
    targetType: string | null
    ip: string | null
    userAgent: string | null
    adminId: string | null
    metadata: JsonValue | null
    severity: string | null
    category: string | null
    isResolved: boolean
    resolvedAt: Date | null
    resolvedBy: string | null
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
    userId?: boolean
    targetId?: boolean
    targetType?: boolean
    ip?: boolean
    userAgent?: boolean
    adminId?: boolean
    metadata?: boolean
    severity?: boolean
    category?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    user?: boolean | ActivityLog$userArgs<ExtArgs>
    admin?: boolean | ActivityLog$adminArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
    userId?: boolean
    targetId?: boolean
    targetType?: boolean
    ip?: boolean
    userAgent?: boolean
    adminId?: boolean
    metadata?: boolean
    severity?: boolean
    category?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    user?: boolean | ActivityLog$userArgs<ExtArgs>
    admin?: boolean | ActivityLog$adminArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
    userId?: boolean
    targetId?: boolean
    targetType?: boolean
    ip?: boolean
    userAgent?: boolean
    adminId?: boolean
    metadata?: boolean
    severity?: boolean
    category?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    user?: boolean | ActivityLog$userArgs<ExtArgs>
    admin?: boolean | ActivityLog$adminArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
    userId?: boolean
    targetId?: boolean
    targetType?: boolean
    ip?: boolean
    userAgent?: boolean
    adminId?: boolean
    metadata?: boolean
    severity?: boolean
    category?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "description" | "createdAt" | "userId" | "targetId" | "targetType" | "ip" | "userAgent" | "adminId" | "metadata" | "severity" | "category" | "isResolved" | "resolvedAt" | "resolvedBy", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ActivityLog$userArgs<ExtArgs>
    admin?: boolean | ActivityLog$adminArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ActivityLog$userArgs<ExtArgs>
    admin?: boolean | ActivityLog$adminArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ActivityLog$userArgs<ExtArgs>
    admin?: boolean | ActivityLog$adminArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      description: string
      createdAt: Date
      userId: string | null
      targetId: string | null
      targetType: string | null
      ip: string | null
      userAgent: string | null
      adminId: string | null
      metadata: Prisma.JsonValue | null
      severity: string | null
      category: string | null
      isResolved: boolean
      resolvedAt: Date | null
      resolvedBy: string | null
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ActivityLog$userArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin<T extends ActivityLog$adminArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly description: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
    readonly userId: FieldRef<"ActivityLog", 'String'>
    readonly targetId: FieldRef<"ActivityLog", 'String'>
    readonly targetType: FieldRef<"ActivityLog", 'String'>
    readonly ip: FieldRef<"ActivityLog", 'String'>
    readonly userAgent: FieldRef<"ActivityLog", 'String'>
    readonly adminId: FieldRef<"ActivityLog", 'String'>
    readonly metadata: FieldRef<"ActivityLog", 'Json'>
    readonly severity: FieldRef<"ActivityLog", 'String'>
    readonly category: FieldRef<"ActivityLog", 'String'>
    readonly isResolved: FieldRef<"ActivityLog", 'Boolean'>
    readonly resolvedAt: FieldRef<"ActivityLog", 'DateTime'>
    readonly resolvedBy: FieldRef<"ActivityLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog.user
   */
  export type ActivityLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ActivityLog.admin
   */
  export type ActivityLog$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model SystemAction
   */

  export type AggregateSystemAction = {
    _count: SystemActionCountAggregateOutputType | null
    _avg: SystemActionAvgAggregateOutputType | null
    _sum: SystemActionSumAggregateOutputType | null
    _min: SystemActionMinAggregateOutputType | null
    _max: SystemActionMaxAggregateOutputType | null
  }

  export type SystemActionAvgAggregateOutputType = {
    executionTime: number | null
  }

  export type SystemActionSumAggregateOutputType = {
    executionTime: number | null
  }

  export type SystemActionMinAggregateOutputType = {
    id: string | null
    action: string | null
    description: string | null
    createdAt: Date | null
    adminId: string | null
    status: string | null
    error: string | null
    executionTime: number | null
  }

  export type SystemActionMaxAggregateOutputType = {
    id: string | null
    action: string | null
    description: string | null
    createdAt: Date | null
    adminId: string | null
    status: string | null
    error: string | null
    executionTime: number | null
  }

  export type SystemActionCountAggregateOutputType = {
    id: number
    action: number
    description: number
    createdAt: number
    adminId: number
    status: number
    payload: number
    result: number
    error: number
    executionTime: number
    _all: number
  }


  export type SystemActionAvgAggregateInputType = {
    executionTime?: true
  }

  export type SystemActionSumAggregateInputType = {
    executionTime?: true
  }

  export type SystemActionMinAggregateInputType = {
    id?: true
    action?: true
    description?: true
    createdAt?: true
    adminId?: true
    status?: true
    error?: true
    executionTime?: true
  }

  export type SystemActionMaxAggregateInputType = {
    id?: true
    action?: true
    description?: true
    createdAt?: true
    adminId?: true
    status?: true
    error?: true
    executionTime?: true
  }

  export type SystemActionCountAggregateInputType = {
    id?: true
    action?: true
    description?: true
    createdAt?: true
    adminId?: true
    status?: true
    payload?: true
    result?: true
    error?: true
    executionTime?: true
    _all?: true
  }

  export type SystemActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemAction to aggregate.
     */
    where?: SystemActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemActions to fetch.
     */
    orderBy?: SystemActionOrderByWithRelationInput | SystemActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemActions
    **/
    _count?: true | SystemActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemActionMaxAggregateInputType
  }

  export type GetSystemActionAggregateType<T extends SystemActionAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemAction[P]>
      : GetScalarType<T[P], AggregateSystemAction[P]>
  }




  export type SystemActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemActionWhereInput
    orderBy?: SystemActionOrderByWithAggregationInput | SystemActionOrderByWithAggregationInput[]
    by: SystemActionScalarFieldEnum[] | SystemActionScalarFieldEnum
    having?: SystemActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemActionCountAggregateInputType | true
    _avg?: SystemActionAvgAggregateInputType
    _sum?: SystemActionSumAggregateInputType
    _min?: SystemActionMinAggregateInputType
    _max?: SystemActionMaxAggregateInputType
  }

  export type SystemActionGroupByOutputType = {
    id: string
    action: string
    description: string
    createdAt: Date
    adminId: string | null
    status: string
    payload: JsonValue | null
    result: JsonValue | null
    error: string | null
    executionTime: number | null
    _count: SystemActionCountAggregateOutputType | null
    _avg: SystemActionAvgAggregateOutputType | null
    _sum: SystemActionSumAggregateOutputType | null
    _min: SystemActionMinAggregateOutputType | null
    _max: SystemActionMaxAggregateOutputType | null
  }

  type GetSystemActionGroupByPayload<T extends SystemActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemActionGroupByOutputType[P]>
            : GetScalarType<T[P], SystemActionGroupByOutputType[P]>
        }
      >
    >


  export type SystemActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
    adminId?: boolean
    status?: boolean
    payload?: boolean
    result?: boolean
    error?: boolean
    executionTime?: boolean
    admin?: boolean | SystemAction$adminArgs<ExtArgs>
  }, ExtArgs["result"]["systemAction"]>

  export type SystemActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
    adminId?: boolean
    status?: boolean
    payload?: boolean
    result?: boolean
    error?: boolean
    executionTime?: boolean
    admin?: boolean | SystemAction$adminArgs<ExtArgs>
  }, ExtArgs["result"]["systemAction"]>

  export type SystemActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
    adminId?: boolean
    status?: boolean
    payload?: boolean
    result?: boolean
    error?: boolean
    executionTime?: boolean
    admin?: boolean | SystemAction$adminArgs<ExtArgs>
  }, ExtArgs["result"]["systemAction"]>

  export type SystemActionSelectScalar = {
    id?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
    adminId?: boolean
    status?: boolean
    payload?: boolean
    result?: boolean
    error?: boolean
    executionTime?: boolean
  }

  export type SystemActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "description" | "createdAt" | "adminId" | "status" | "payload" | "result" | "error" | "executionTime", ExtArgs["result"]["systemAction"]>
  export type SystemActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | SystemAction$adminArgs<ExtArgs>
  }
  export type SystemActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | SystemAction$adminArgs<ExtArgs>
  }
  export type SystemActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | SystemAction$adminArgs<ExtArgs>
  }

  export type $SystemActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemAction"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      description: string
      createdAt: Date
      adminId: string | null
      status: string
      payload: Prisma.JsonValue | null
      result: Prisma.JsonValue | null
      error: string | null
      executionTime: number | null
    }, ExtArgs["result"]["systemAction"]>
    composites: {}
  }

  type SystemActionGetPayload<S extends boolean | null | undefined | SystemActionDefaultArgs> = $Result.GetResult<Prisma.$SystemActionPayload, S>

  type SystemActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemActionCountAggregateInputType | true
    }

  export interface SystemActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemAction'], meta: { name: 'SystemAction' } }
    /**
     * Find zero or one SystemAction that matches the filter.
     * @param {SystemActionFindUniqueArgs} args - Arguments to find a SystemAction
     * @example
     * // Get one SystemAction
     * const systemAction = await prisma.systemAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemActionFindUniqueArgs>(args: SelectSubset<T, SystemActionFindUniqueArgs<ExtArgs>>): Prisma__SystemActionClient<$Result.GetResult<Prisma.$SystemActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemActionFindUniqueOrThrowArgs} args - Arguments to find a SystemAction
     * @example
     * // Get one SystemAction
     * const systemAction = await prisma.systemAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemActionFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemActionClient<$Result.GetResult<Prisma.$SystemActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemActionFindFirstArgs} args - Arguments to find a SystemAction
     * @example
     * // Get one SystemAction
     * const systemAction = await prisma.systemAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemActionFindFirstArgs>(args?: SelectSubset<T, SystemActionFindFirstArgs<ExtArgs>>): Prisma__SystemActionClient<$Result.GetResult<Prisma.$SystemActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemActionFindFirstOrThrowArgs} args - Arguments to find a SystemAction
     * @example
     * // Get one SystemAction
     * const systemAction = await prisma.systemAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemActionFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemActionClient<$Result.GetResult<Prisma.$SystemActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemActions
     * const systemActions = await prisma.systemAction.findMany()
     * 
     * // Get first 10 SystemActions
     * const systemActions = await prisma.systemAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemActionWithIdOnly = await prisma.systemAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemActionFindManyArgs>(args?: SelectSubset<T, SystemActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemAction.
     * @param {SystemActionCreateArgs} args - Arguments to create a SystemAction.
     * @example
     * // Create one SystemAction
     * const SystemAction = await prisma.systemAction.create({
     *   data: {
     *     // ... data to create a SystemAction
     *   }
     * })
     * 
     */
    create<T extends SystemActionCreateArgs>(args: SelectSubset<T, SystemActionCreateArgs<ExtArgs>>): Prisma__SystemActionClient<$Result.GetResult<Prisma.$SystemActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemActions.
     * @param {SystemActionCreateManyArgs} args - Arguments to create many SystemActions.
     * @example
     * // Create many SystemActions
     * const systemAction = await prisma.systemAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemActionCreateManyArgs>(args?: SelectSubset<T, SystemActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemActions and returns the data saved in the database.
     * @param {SystemActionCreateManyAndReturnArgs} args - Arguments to create many SystemActions.
     * @example
     * // Create many SystemActions
     * const systemAction = await prisma.systemAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemActions and only return the `id`
     * const systemActionWithIdOnly = await prisma.systemAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemActionCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemAction.
     * @param {SystemActionDeleteArgs} args - Arguments to delete one SystemAction.
     * @example
     * // Delete one SystemAction
     * const SystemAction = await prisma.systemAction.delete({
     *   where: {
     *     // ... filter to delete one SystemAction
     *   }
     * })
     * 
     */
    delete<T extends SystemActionDeleteArgs>(args: SelectSubset<T, SystemActionDeleteArgs<ExtArgs>>): Prisma__SystemActionClient<$Result.GetResult<Prisma.$SystemActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemAction.
     * @param {SystemActionUpdateArgs} args - Arguments to update one SystemAction.
     * @example
     * // Update one SystemAction
     * const systemAction = await prisma.systemAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemActionUpdateArgs>(args: SelectSubset<T, SystemActionUpdateArgs<ExtArgs>>): Prisma__SystemActionClient<$Result.GetResult<Prisma.$SystemActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemActions.
     * @param {SystemActionDeleteManyArgs} args - Arguments to filter SystemActions to delete.
     * @example
     * // Delete a few SystemActions
     * const { count } = await prisma.systemAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemActionDeleteManyArgs>(args?: SelectSubset<T, SystemActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemActions
     * const systemAction = await prisma.systemAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemActionUpdateManyArgs>(args: SelectSubset<T, SystemActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemActions and returns the data updated in the database.
     * @param {SystemActionUpdateManyAndReturnArgs} args - Arguments to update many SystemActions.
     * @example
     * // Update many SystemActions
     * const systemAction = await prisma.systemAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemActions and only return the `id`
     * const systemActionWithIdOnly = await prisma.systemAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemActionUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemAction.
     * @param {SystemActionUpsertArgs} args - Arguments to update or create a SystemAction.
     * @example
     * // Update or create a SystemAction
     * const systemAction = await prisma.systemAction.upsert({
     *   create: {
     *     // ... data to create a SystemAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemAction we want to update
     *   }
     * })
     */
    upsert<T extends SystemActionUpsertArgs>(args: SelectSubset<T, SystemActionUpsertArgs<ExtArgs>>): Prisma__SystemActionClient<$Result.GetResult<Prisma.$SystemActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemActionCountArgs} args - Arguments to filter SystemActions to count.
     * @example
     * // Count the number of SystemActions
     * const count = await prisma.systemAction.count({
     *   where: {
     *     // ... the filter for the SystemActions we want to count
     *   }
     * })
    **/
    count<T extends SystemActionCountArgs>(
      args?: Subset<T, SystemActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemActionAggregateArgs>(args: Subset<T, SystemActionAggregateArgs>): Prisma.PrismaPromise<GetSystemActionAggregateType<T>>

    /**
     * Group by SystemAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemActionGroupByArgs['orderBy'] }
        : { orderBy?: SystemActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemAction model
   */
  readonly fields: SystemActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends SystemAction$adminArgs<ExtArgs> = {}>(args?: Subset<T, SystemAction$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemAction model
   */
  interface SystemActionFieldRefs {
    readonly id: FieldRef<"SystemAction", 'String'>
    readonly action: FieldRef<"SystemAction", 'String'>
    readonly description: FieldRef<"SystemAction", 'String'>
    readonly createdAt: FieldRef<"SystemAction", 'DateTime'>
    readonly adminId: FieldRef<"SystemAction", 'String'>
    readonly status: FieldRef<"SystemAction", 'String'>
    readonly payload: FieldRef<"SystemAction", 'Json'>
    readonly result: FieldRef<"SystemAction", 'Json'>
    readonly error: FieldRef<"SystemAction", 'String'>
    readonly executionTime: FieldRef<"SystemAction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SystemAction findUnique
   */
  export type SystemActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAction
     */
    select?: SystemActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAction
     */
    omit?: SystemActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemActionInclude<ExtArgs> | null
    /**
     * Filter, which SystemAction to fetch.
     */
    where: SystemActionWhereUniqueInput
  }

  /**
   * SystemAction findUniqueOrThrow
   */
  export type SystemActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAction
     */
    select?: SystemActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAction
     */
    omit?: SystemActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemActionInclude<ExtArgs> | null
    /**
     * Filter, which SystemAction to fetch.
     */
    where: SystemActionWhereUniqueInput
  }

  /**
   * SystemAction findFirst
   */
  export type SystemActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAction
     */
    select?: SystemActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAction
     */
    omit?: SystemActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemActionInclude<ExtArgs> | null
    /**
     * Filter, which SystemAction to fetch.
     */
    where?: SystemActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemActions to fetch.
     */
    orderBy?: SystemActionOrderByWithRelationInput | SystemActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemActions.
     */
    cursor?: SystemActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemActions.
     */
    distinct?: SystemActionScalarFieldEnum | SystemActionScalarFieldEnum[]
  }

  /**
   * SystemAction findFirstOrThrow
   */
  export type SystemActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAction
     */
    select?: SystemActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAction
     */
    omit?: SystemActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemActionInclude<ExtArgs> | null
    /**
     * Filter, which SystemAction to fetch.
     */
    where?: SystemActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemActions to fetch.
     */
    orderBy?: SystemActionOrderByWithRelationInput | SystemActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemActions.
     */
    cursor?: SystemActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemActions.
     */
    distinct?: SystemActionScalarFieldEnum | SystemActionScalarFieldEnum[]
  }

  /**
   * SystemAction findMany
   */
  export type SystemActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAction
     */
    select?: SystemActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAction
     */
    omit?: SystemActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemActionInclude<ExtArgs> | null
    /**
     * Filter, which SystemActions to fetch.
     */
    where?: SystemActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemActions to fetch.
     */
    orderBy?: SystemActionOrderByWithRelationInput | SystemActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemActions.
     */
    cursor?: SystemActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemActions.
     */
    skip?: number
    distinct?: SystemActionScalarFieldEnum | SystemActionScalarFieldEnum[]
  }

  /**
   * SystemAction create
   */
  export type SystemActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAction
     */
    select?: SystemActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAction
     */
    omit?: SystemActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemActionInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemAction.
     */
    data: XOR<SystemActionCreateInput, SystemActionUncheckedCreateInput>
  }

  /**
   * SystemAction createMany
   */
  export type SystemActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemActions.
     */
    data: SystemActionCreateManyInput | SystemActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemAction createManyAndReturn
   */
  export type SystemActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAction
     */
    select?: SystemActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAction
     */
    omit?: SystemActionOmit<ExtArgs> | null
    /**
     * The data used to create many SystemActions.
     */
    data: SystemActionCreateManyInput | SystemActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemAction update
   */
  export type SystemActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAction
     */
    select?: SystemActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAction
     */
    omit?: SystemActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemActionInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemAction.
     */
    data: XOR<SystemActionUpdateInput, SystemActionUncheckedUpdateInput>
    /**
     * Choose, which SystemAction to update.
     */
    where: SystemActionWhereUniqueInput
  }

  /**
   * SystemAction updateMany
   */
  export type SystemActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemActions.
     */
    data: XOR<SystemActionUpdateManyMutationInput, SystemActionUncheckedUpdateManyInput>
    /**
     * Filter which SystemActions to update
     */
    where?: SystemActionWhereInput
    /**
     * Limit how many SystemActions to update.
     */
    limit?: number
  }

  /**
   * SystemAction updateManyAndReturn
   */
  export type SystemActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAction
     */
    select?: SystemActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAction
     */
    omit?: SystemActionOmit<ExtArgs> | null
    /**
     * The data used to update SystemActions.
     */
    data: XOR<SystemActionUpdateManyMutationInput, SystemActionUncheckedUpdateManyInput>
    /**
     * Filter which SystemActions to update
     */
    where?: SystemActionWhereInput
    /**
     * Limit how many SystemActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemAction upsert
   */
  export type SystemActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAction
     */
    select?: SystemActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAction
     */
    omit?: SystemActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemActionInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemAction to update in case it exists.
     */
    where: SystemActionWhereUniqueInput
    /**
     * In case the SystemAction found by the `where` argument doesn't exist, create a new SystemAction with this data.
     */
    create: XOR<SystemActionCreateInput, SystemActionUncheckedCreateInput>
    /**
     * In case the SystemAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemActionUpdateInput, SystemActionUncheckedUpdateInput>
  }

  /**
   * SystemAction delete
   */
  export type SystemActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAction
     */
    select?: SystemActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAction
     */
    omit?: SystemActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemActionInclude<ExtArgs> | null
    /**
     * Filter which SystemAction to delete.
     */
    where: SystemActionWhereUniqueInput
  }

  /**
   * SystemAction deleteMany
   */
  export type SystemActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemActions to delete
     */
    where?: SystemActionWhereInput
    /**
     * Limit how many SystemActions to delete.
     */
    limit?: number
  }

  /**
   * SystemAction.admin
   */
  export type SystemAction$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * SystemAction without action
   */
  export type SystemActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAction
     */
    select?: SystemActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAction
     */
    omit?: SystemActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemActionInclude<ExtArgs> | null
  }


  /**
   * Model SystemSettings
   */

  export type AggregateSystemSettings = {
    _count: SystemSettingsCountAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  export type SystemSettingsMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    category: string | null
    description: string | null
    dataType: string | null
    isEncrypted: boolean | null
    lastUpdated: Date | null
    updatedBy: string | null
  }

  export type SystemSettingsMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    category: string | null
    description: string | null
    dataType: string | null
    isEncrypted: boolean | null
    lastUpdated: Date | null
    updatedBy: string | null
  }

  export type SystemSettingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    category: number
    description: number
    dataType: number
    isEncrypted: number
    lastUpdated: number
    updatedBy: number
    _all: number
  }


  export type SystemSettingsMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    dataType?: true
    isEncrypted?: true
    lastUpdated?: true
    updatedBy?: true
  }

  export type SystemSettingsMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    dataType?: true
    isEncrypted?: true
    lastUpdated?: true
    updatedBy?: true
  }

  export type SystemSettingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    dataType?: true
    isEncrypted?: true
    lastUpdated?: true
    updatedBy?: true
    _all?: true
  }

  export type SystemSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to aggregate.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type GetSystemSettingsAggregateType<T extends SystemSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSettings[P]>
      : GetScalarType<T[P], AggregateSystemSettings[P]>
  }




  export type SystemSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingsWhereInput
    orderBy?: SystemSettingsOrderByWithAggregationInput | SystemSettingsOrderByWithAggregationInput[]
    by: SystemSettingsScalarFieldEnum[] | SystemSettingsScalarFieldEnum
    having?: SystemSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingsCountAggregateInputType | true
    _min?: SystemSettingsMinAggregateInputType
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type SystemSettingsGroupByOutputType = {
    id: string
    key: string
    value: string
    category: string
    description: string | null
    dataType: string
    isEncrypted: boolean
    lastUpdated: Date
    updatedBy: string | null
    _count: SystemSettingsCountAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  type GetSystemSettingsGroupByPayload<T extends SystemSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    dataType?: boolean
    isEncrypted?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    dataType?: boolean
    isEncrypted?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    dataType?: boolean
    isEncrypted?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    dataType?: boolean
    isEncrypted?: boolean
    lastUpdated?: boolean
    updatedBy?: boolean
  }

  export type SystemSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "category" | "description" | "dataType" | "isEncrypted" | "lastUpdated" | "updatedBy", ExtArgs["result"]["systemSettings"]>

  export type $SystemSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      category: string
      description: string | null
      dataType: string
      isEncrypted: boolean
      lastUpdated: Date
      updatedBy: string | null
    }, ExtArgs["result"]["systemSettings"]>
    composites: {}
  }

  type SystemSettingsGetPayload<S extends boolean | null | undefined | SystemSettingsDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingsPayload, S>

  type SystemSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingsCountAggregateInputType | true
    }

  export interface SystemSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSettings'], meta: { name: 'SystemSettings' } }
    /**
     * Find zero or one SystemSettings that matches the filter.
     * @param {SystemSettingsFindUniqueArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingsFindUniqueArgs>(args: SelectSubset<T, SystemSettingsFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingsFindUniqueOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingsFindFirstArgs>(args?: SelectSubset<T, SystemSettingsFindFirstArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingsFindManyArgs>(args?: SelectSubset<T, SystemSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSettings.
     * @param {SystemSettingsCreateArgs} args - Arguments to create a SystemSettings.
     * @example
     * // Create one SystemSettings
     * const SystemSettings = await prisma.systemSettings.create({
     *   data: {
     *     // ... data to create a SystemSettings
     *   }
     * })
     * 
     */
    create<T extends SystemSettingsCreateArgs>(args: SelectSubset<T, SystemSettingsCreateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingsCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingsCreateManyArgs>(args?: SelectSubset<T, SystemSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingsCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSettings.
     * @param {SystemSettingsDeleteArgs} args - Arguments to delete one SystemSettings.
     * @example
     * // Delete one SystemSettings
     * const SystemSettings = await prisma.systemSettings.delete({
     *   where: {
     *     // ... filter to delete one SystemSettings
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingsDeleteArgs>(args: SelectSubset<T, SystemSettingsDeleteArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSettings.
     * @param {SystemSettingsUpdateArgs} args - Arguments to update one SystemSettings.
     * @example
     * // Update one SystemSettings
     * const systemSettings = await prisma.systemSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingsUpdateArgs>(args: SelectSubset<T, SystemSettingsUpdateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingsDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingsDeleteManyArgs>(args?: SelectSubset<T, SystemSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingsUpdateManyArgs>(args: SelectSubset<T, SystemSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingsUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSettings.
     * @param {SystemSettingsUpsertArgs} args - Arguments to update or create a SystemSettings.
     * @example
     * // Update or create a SystemSettings
     * const systemSettings = await prisma.systemSettings.upsert({
     *   create: {
     *     // ... data to create a SystemSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSettings we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingsUpsertArgs>(args: SelectSubset<T, SystemSettingsUpsertArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSettings.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingsCountArgs>(
      args?: Subset<T, SystemSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingsAggregateArgs>(args: Subset<T, SystemSettingsAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingsAggregateType<T>>

    /**
     * Group by SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSettings model
   */
  readonly fields: SystemSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSettings model
   */
  interface SystemSettingsFieldRefs {
    readonly id: FieldRef<"SystemSettings", 'String'>
    readonly key: FieldRef<"SystemSettings", 'String'>
    readonly value: FieldRef<"SystemSettings", 'String'>
    readonly category: FieldRef<"SystemSettings", 'String'>
    readonly description: FieldRef<"SystemSettings", 'String'>
    readonly dataType: FieldRef<"SystemSettings", 'String'>
    readonly isEncrypted: FieldRef<"SystemSettings", 'Boolean'>
    readonly lastUpdated: FieldRef<"SystemSettings", 'DateTime'>
    readonly updatedBy: FieldRef<"SystemSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SystemSettings findUnique
   */
  export type SystemSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findUniqueOrThrow
   */
  export type SystemSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findFirst
   */
  export type SystemSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findFirstOrThrow
   */
  export type SystemSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findMany
   */
  export type SystemSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings create
   */
  export type SystemSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSettings.
     */
    data: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
  }

  /**
   * SystemSettings createMany
   */
  export type SystemSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings createManyAndReturn
   */
  export type SystemSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings update
   */
  export type SystemSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSettings.
     */
    data: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
    /**
     * Choose, which SystemSettings to update.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings updateMany
   */
  export type SystemSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings updateManyAndReturn
   */
  export type SystemSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings upsert
   */
  export type SystemSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSettings to update in case it exists.
     */
    where: SystemSettingsWhereUniqueInput
    /**
     * In case the SystemSettings found by the `where` argument doesn't exist, create a new SystemSettings with this data.
     */
    create: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
    /**
     * In case the SystemSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
  }

  /**
   * SystemSettings delete
   */
  export type SystemSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter which SystemSettings to delete.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings deleteMany
   */
  export type SystemSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSettings without action
   */
  export type SystemSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
  }


  /**
   * Model AdminDashboardWidget
   */

  export type AggregateAdminDashboardWidget = {
    _count: AdminDashboardWidgetCountAggregateOutputType | null
    _avg: AdminDashboardWidgetAvgAggregateOutputType | null
    _sum: AdminDashboardWidgetSumAggregateOutputType | null
    _min: AdminDashboardWidgetMinAggregateOutputType | null
    _max: AdminDashboardWidgetMaxAggregateOutputType | null
  }

  export type AdminDashboardWidgetAvgAggregateOutputType = {
    position: number | null
  }

  export type AdminDashboardWidgetSumAggregateOutputType = {
    position: number | null
  }

  export type AdminDashboardWidgetMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    position: number | null
    size: string | null
    isActive: boolean | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminDashboardWidgetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    position: number | null
    size: string | null
    isActive: boolean | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminDashboardWidgetCountAggregateOutputType = {
    id: number
    name: number
    type: number
    position: number
    size: number
    config: number
    isActive: number
    adminId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminDashboardWidgetAvgAggregateInputType = {
    position?: true
  }

  export type AdminDashboardWidgetSumAggregateInputType = {
    position?: true
  }

  export type AdminDashboardWidgetMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    position?: true
    size?: true
    isActive?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminDashboardWidgetMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    position?: true
    size?: true
    isActive?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminDashboardWidgetCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    position?: true
    size?: true
    config?: true
    isActive?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminDashboardWidgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminDashboardWidget to aggregate.
     */
    where?: AdminDashboardWidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminDashboardWidgets to fetch.
     */
    orderBy?: AdminDashboardWidgetOrderByWithRelationInput | AdminDashboardWidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminDashboardWidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminDashboardWidgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminDashboardWidgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminDashboardWidgets
    **/
    _count?: true | AdminDashboardWidgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminDashboardWidgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminDashboardWidgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminDashboardWidgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminDashboardWidgetMaxAggregateInputType
  }

  export type GetAdminDashboardWidgetAggregateType<T extends AdminDashboardWidgetAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminDashboardWidget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminDashboardWidget[P]>
      : GetScalarType<T[P], AggregateAdminDashboardWidget[P]>
  }




  export type AdminDashboardWidgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminDashboardWidgetWhereInput
    orderBy?: AdminDashboardWidgetOrderByWithAggregationInput | AdminDashboardWidgetOrderByWithAggregationInput[]
    by: AdminDashboardWidgetScalarFieldEnum[] | AdminDashboardWidgetScalarFieldEnum
    having?: AdminDashboardWidgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminDashboardWidgetCountAggregateInputType | true
    _avg?: AdminDashboardWidgetAvgAggregateInputType
    _sum?: AdminDashboardWidgetSumAggregateInputType
    _min?: AdminDashboardWidgetMinAggregateInputType
    _max?: AdminDashboardWidgetMaxAggregateInputType
  }

  export type AdminDashboardWidgetGroupByOutputType = {
    id: string
    name: string
    type: string
    position: number
    size: string
    config: JsonValue
    isActive: boolean
    adminId: string
    createdAt: Date
    updatedAt: Date
    _count: AdminDashboardWidgetCountAggregateOutputType | null
    _avg: AdminDashboardWidgetAvgAggregateOutputType | null
    _sum: AdminDashboardWidgetSumAggregateOutputType | null
    _min: AdminDashboardWidgetMinAggregateOutputType | null
    _max: AdminDashboardWidgetMaxAggregateOutputType | null
  }

  type GetAdminDashboardWidgetGroupByPayload<T extends AdminDashboardWidgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminDashboardWidgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminDashboardWidgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminDashboardWidgetGroupByOutputType[P]>
            : GetScalarType<T[P], AdminDashboardWidgetGroupByOutputType[P]>
        }
      >
    >


  export type AdminDashboardWidgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    position?: boolean
    size?: boolean
    config?: boolean
    isActive?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminDashboardWidget"]>

  export type AdminDashboardWidgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    position?: boolean
    size?: boolean
    config?: boolean
    isActive?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminDashboardWidget"]>

  export type AdminDashboardWidgetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    position?: boolean
    size?: boolean
    config?: boolean
    isActive?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminDashboardWidget"]>

  export type AdminDashboardWidgetSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    position?: boolean
    size?: boolean
    config?: boolean
    isActive?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminDashboardWidgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "position" | "size" | "config" | "isActive" | "adminId" | "createdAt" | "updatedAt", ExtArgs["result"]["adminDashboardWidget"]>
  export type AdminDashboardWidgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminDashboardWidgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminDashboardWidgetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminDashboardWidgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminDashboardWidget"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      position: number
      size: string
      config: Prisma.JsonValue
      isActive: boolean
      adminId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminDashboardWidget"]>
    composites: {}
  }

  type AdminDashboardWidgetGetPayload<S extends boolean | null | undefined | AdminDashboardWidgetDefaultArgs> = $Result.GetResult<Prisma.$AdminDashboardWidgetPayload, S>

  type AdminDashboardWidgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminDashboardWidgetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminDashboardWidgetCountAggregateInputType | true
    }

  export interface AdminDashboardWidgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminDashboardWidget'], meta: { name: 'AdminDashboardWidget' } }
    /**
     * Find zero or one AdminDashboardWidget that matches the filter.
     * @param {AdminDashboardWidgetFindUniqueArgs} args - Arguments to find a AdminDashboardWidget
     * @example
     * // Get one AdminDashboardWidget
     * const adminDashboardWidget = await prisma.adminDashboardWidget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminDashboardWidgetFindUniqueArgs>(args: SelectSubset<T, AdminDashboardWidgetFindUniqueArgs<ExtArgs>>): Prisma__AdminDashboardWidgetClient<$Result.GetResult<Prisma.$AdminDashboardWidgetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminDashboardWidget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminDashboardWidgetFindUniqueOrThrowArgs} args - Arguments to find a AdminDashboardWidget
     * @example
     * // Get one AdminDashboardWidget
     * const adminDashboardWidget = await prisma.adminDashboardWidget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminDashboardWidgetFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminDashboardWidgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminDashboardWidgetClient<$Result.GetResult<Prisma.$AdminDashboardWidgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminDashboardWidget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminDashboardWidgetFindFirstArgs} args - Arguments to find a AdminDashboardWidget
     * @example
     * // Get one AdminDashboardWidget
     * const adminDashboardWidget = await prisma.adminDashboardWidget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminDashboardWidgetFindFirstArgs>(args?: SelectSubset<T, AdminDashboardWidgetFindFirstArgs<ExtArgs>>): Prisma__AdminDashboardWidgetClient<$Result.GetResult<Prisma.$AdminDashboardWidgetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminDashboardWidget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminDashboardWidgetFindFirstOrThrowArgs} args - Arguments to find a AdminDashboardWidget
     * @example
     * // Get one AdminDashboardWidget
     * const adminDashboardWidget = await prisma.adminDashboardWidget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminDashboardWidgetFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminDashboardWidgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminDashboardWidgetClient<$Result.GetResult<Prisma.$AdminDashboardWidgetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminDashboardWidgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminDashboardWidgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminDashboardWidgets
     * const adminDashboardWidgets = await prisma.adminDashboardWidget.findMany()
     * 
     * // Get first 10 AdminDashboardWidgets
     * const adminDashboardWidgets = await prisma.adminDashboardWidget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminDashboardWidgetWithIdOnly = await prisma.adminDashboardWidget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminDashboardWidgetFindManyArgs>(args?: SelectSubset<T, AdminDashboardWidgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminDashboardWidgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminDashboardWidget.
     * @param {AdminDashboardWidgetCreateArgs} args - Arguments to create a AdminDashboardWidget.
     * @example
     * // Create one AdminDashboardWidget
     * const AdminDashboardWidget = await prisma.adminDashboardWidget.create({
     *   data: {
     *     // ... data to create a AdminDashboardWidget
     *   }
     * })
     * 
     */
    create<T extends AdminDashboardWidgetCreateArgs>(args: SelectSubset<T, AdminDashboardWidgetCreateArgs<ExtArgs>>): Prisma__AdminDashboardWidgetClient<$Result.GetResult<Prisma.$AdminDashboardWidgetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminDashboardWidgets.
     * @param {AdminDashboardWidgetCreateManyArgs} args - Arguments to create many AdminDashboardWidgets.
     * @example
     * // Create many AdminDashboardWidgets
     * const adminDashboardWidget = await prisma.adminDashboardWidget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminDashboardWidgetCreateManyArgs>(args?: SelectSubset<T, AdminDashboardWidgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminDashboardWidgets and returns the data saved in the database.
     * @param {AdminDashboardWidgetCreateManyAndReturnArgs} args - Arguments to create many AdminDashboardWidgets.
     * @example
     * // Create many AdminDashboardWidgets
     * const adminDashboardWidget = await prisma.adminDashboardWidget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminDashboardWidgets and only return the `id`
     * const adminDashboardWidgetWithIdOnly = await prisma.adminDashboardWidget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminDashboardWidgetCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminDashboardWidgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminDashboardWidgetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminDashboardWidget.
     * @param {AdminDashboardWidgetDeleteArgs} args - Arguments to delete one AdminDashboardWidget.
     * @example
     * // Delete one AdminDashboardWidget
     * const AdminDashboardWidget = await prisma.adminDashboardWidget.delete({
     *   where: {
     *     // ... filter to delete one AdminDashboardWidget
     *   }
     * })
     * 
     */
    delete<T extends AdminDashboardWidgetDeleteArgs>(args: SelectSubset<T, AdminDashboardWidgetDeleteArgs<ExtArgs>>): Prisma__AdminDashboardWidgetClient<$Result.GetResult<Prisma.$AdminDashboardWidgetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminDashboardWidget.
     * @param {AdminDashboardWidgetUpdateArgs} args - Arguments to update one AdminDashboardWidget.
     * @example
     * // Update one AdminDashboardWidget
     * const adminDashboardWidget = await prisma.adminDashboardWidget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminDashboardWidgetUpdateArgs>(args: SelectSubset<T, AdminDashboardWidgetUpdateArgs<ExtArgs>>): Prisma__AdminDashboardWidgetClient<$Result.GetResult<Prisma.$AdminDashboardWidgetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminDashboardWidgets.
     * @param {AdminDashboardWidgetDeleteManyArgs} args - Arguments to filter AdminDashboardWidgets to delete.
     * @example
     * // Delete a few AdminDashboardWidgets
     * const { count } = await prisma.adminDashboardWidget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDashboardWidgetDeleteManyArgs>(args?: SelectSubset<T, AdminDashboardWidgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminDashboardWidgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminDashboardWidgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminDashboardWidgets
     * const adminDashboardWidget = await prisma.adminDashboardWidget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminDashboardWidgetUpdateManyArgs>(args: SelectSubset<T, AdminDashboardWidgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminDashboardWidgets and returns the data updated in the database.
     * @param {AdminDashboardWidgetUpdateManyAndReturnArgs} args - Arguments to update many AdminDashboardWidgets.
     * @example
     * // Update many AdminDashboardWidgets
     * const adminDashboardWidget = await prisma.adminDashboardWidget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminDashboardWidgets and only return the `id`
     * const adminDashboardWidgetWithIdOnly = await prisma.adminDashboardWidget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminDashboardWidgetUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminDashboardWidgetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminDashboardWidgetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminDashboardWidget.
     * @param {AdminDashboardWidgetUpsertArgs} args - Arguments to update or create a AdminDashboardWidget.
     * @example
     * // Update or create a AdminDashboardWidget
     * const adminDashboardWidget = await prisma.adminDashboardWidget.upsert({
     *   create: {
     *     // ... data to create a AdminDashboardWidget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminDashboardWidget we want to update
     *   }
     * })
     */
    upsert<T extends AdminDashboardWidgetUpsertArgs>(args: SelectSubset<T, AdminDashboardWidgetUpsertArgs<ExtArgs>>): Prisma__AdminDashboardWidgetClient<$Result.GetResult<Prisma.$AdminDashboardWidgetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminDashboardWidgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminDashboardWidgetCountArgs} args - Arguments to filter AdminDashboardWidgets to count.
     * @example
     * // Count the number of AdminDashboardWidgets
     * const count = await prisma.adminDashboardWidget.count({
     *   where: {
     *     // ... the filter for the AdminDashboardWidgets we want to count
     *   }
     * })
    **/
    count<T extends AdminDashboardWidgetCountArgs>(
      args?: Subset<T, AdminDashboardWidgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminDashboardWidgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminDashboardWidget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminDashboardWidgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminDashboardWidgetAggregateArgs>(args: Subset<T, AdminDashboardWidgetAggregateArgs>): Prisma.PrismaPromise<GetAdminDashboardWidgetAggregateType<T>>

    /**
     * Group by AdminDashboardWidget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminDashboardWidgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminDashboardWidgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminDashboardWidgetGroupByArgs['orderBy'] }
        : { orderBy?: AdminDashboardWidgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminDashboardWidgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminDashboardWidgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminDashboardWidget model
   */
  readonly fields: AdminDashboardWidgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminDashboardWidget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminDashboardWidgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminDashboardWidget model
   */
  interface AdminDashboardWidgetFieldRefs {
    readonly id: FieldRef<"AdminDashboardWidget", 'String'>
    readonly name: FieldRef<"AdminDashboardWidget", 'String'>
    readonly type: FieldRef<"AdminDashboardWidget", 'String'>
    readonly position: FieldRef<"AdminDashboardWidget", 'Int'>
    readonly size: FieldRef<"AdminDashboardWidget", 'String'>
    readonly config: FieldRef<"AdminDashboardWidget", 'Json'>
    readonly isActive: FieldRef<"AdminDashboardWidget", 'Boolean'>
    readonly adminId: FieldRef<"AdminDashboardWidget", 'String'>
    readonly createdAt: FieldRef<"AdminDashboardWidget", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminDashboardWidget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminDashboardWidget findUnique
   */
  export type AdminDashboardWidgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminDashboardWidget
     */
    select?: AdminDashboardWidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminDashboardWidget
     */
    omit?: AdminDashboardWidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminDashboardWidgetInclude<ExtArgs> | null
    /**
     * Filter, which AdminDashboardWidget to fetch.
     */
    where: AdminDashboardWidgetWhereUniqueInput
  }

  /**
   * AdminDashboardWidget findUniqueOrThrow
   */
  export type AdminDashboardWidgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminDashboardWidget
     */
    select?: AdminDashboardWidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminDashboardWidget
     */
    omit?: AdminDashboardWidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminDashboardWidgetInclude<ExtArgs> | null
    /**
     * Filter, which AdminDashboardWidget to fetch.
     */
    where: AdminDashboardWidgetWhereUniqueInput
  }

  /**
   * AdminDashboardWidget findFirst
   */
  export type AdminDashboardWidgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminDashboardWidget
     */
    select?: AdminDashboardWidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminDashboardWidget
     */
    omit?: AdminDashboardWidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminDashboardWidgetInclude<ExtArgs> | null
    /**
     * Filter, which AdminDashboardWidget to fetch.
     */
    where?: AdminDashboardWidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminDashboardWidgets to fetch.
     */
    orderBy?: AdminDashboardWidgetOrderByWithRelationInput | AdminDashboardWidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminDashboardWidgets.
     */
    cursor?: AdminDashboardWidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminDashboardWidgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminDashboardWidgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminDashboardWidgets.
     */
    distinct?: AdminDashboardWidgetScalarFieldEnum | AdminDashboardWidgetScalarFieldEnum[]
  }

  /**
   * AdminDashboardWidget findFirstOrThrow
   */
  export type AdminDashboardWidgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminDashboardWidget
     */
    select?: AdminDashboardWidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminDashboardWidget
     */
    omit?: AdminDashboardWidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminDashboardWidgetInclude<ExtArgs> | null
    /**
     * Filter, which AdminDashboardWidget to fetch.
     */
    where?: AdminDashboardWidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminDashboardWidgets to fetch.
     */
    orderBy?: AdminDashboardWidgetOrderByWithRelationInput | AdminDashboardWidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminDashboardWidgets.
     */
    cursor?: AdminDashboardWidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminDashboardWidgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminDashboardWidgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminDashboardWidgets.
     */
    distinct?: AdminDashboardWidgetScalarFieldEnum | AdminDashboardWidgetScalarFieldEnum[]
  }

  /**
   * AdminDashboardWidget findMany
   */
  export type AdminDashboardWidgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminDashboardWidget
     */
    select?: AdminDashboardWidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminDashboardWidget
     */
    omit?: AdminDashboardWidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminDashboardWidgetInclude<ExtArgs> | null
    /**
     * Filter, which AdminDashboardWidgets to fetch.
     */
    where?: AdminDashboardWidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminDashboardWidgets to fetch.
     */
    orderBy?: AdminDashboardWidgetOrderByWithRelationInput | AdminDashboardWidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminDashboardWidgets.
     */
    cursor?: AdminDashboardWidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminDashboardWidgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminDashboardWidgets.
     */
    skip?: number
    distinct?: AdminDashboardWidgetScalarFieldEnum | AdminDashboardWidgetScalarFieldEnum[]
  }

  /**
   * AdminDashboardWidget create
   */
  export type AdminDashboardWidgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminDashboardWidget
     */
    select?: AdminDashboardWidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminDashboardWidget
     */
    omit?: AdminDashboardWidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminDashboardWidgetInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminDashboardWidget.
     */
    data: XOR<AdminDashboardWidgetCreateInput, AdminDashboardWidgetUncheckedCreateInput>
  }

  /**
   * AdminDashboardWidget createMany
   */
  export type AdminDashboardWidgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminDashboardWidgets.
     */
    data: AdminDashboardWidgetCreateManyInput | AdminDashboardWidgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminDashboardWidget createManyAndReturn
   */
  export type AdminDashboardWidgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminDashboardWidget
     */
    select?: AdminDashboardWidgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminDashboardWidget
     */
    omit?: AdminDashboardWidgetOmit<ExtArgs> | null
    /**
     * The data used to create many AdminDashboardWidgets.
     */
    data: AdminDashboardWidgetCreateManyInput | AdminDashboardWidgetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminDashboardWidgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminDashboardWidget update
   */
  export type AdminDashboardWidgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminDashboardWidget
     */
    select?: AdminDashboardWidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminDashboardWidget
     */
    omit?: AdminDashboardWidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminDashboardWidgetInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminDashboardWidget.
     */
    data: XOR<AdminDashboardWidgetUpdateInput, AdminDashboardWidgetUncheckedUpdateInput>
    /**
     * Choose, which AdminDashboardWidget to update.
     */
    where: AdminDashboardWidgetWhereUniqueInput
  }

  /**
   * AdminDashboardWidget updateMany
   */
  export type AdminDashboardWidgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminDashboardWidgets.
     */
    data: XOR<AdminDashboardWidgetUpdateManyMutationInput, AdminDashboardWidgetUncheckedUpdateManyInput>
    /**
     * Filter which AdminDashboardWidgets to update
     */
    where?: AdminDashboardWidgetWhereInput
    /**
     * Limit how many AdminDashboardWidgets to update.
     */
    limit?: number
  }

  /**
   * AdminDashboardWidget updateManyAndReturn
   */
  export type AdminDashboardWidgetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminDashboardWidget
     */
    select?: AdminDashboardWidgetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminDashboardWidget
     */
    omit?: AdminDashboardWidgetOmit<ExtArgs> | null
    /**
     * The data used to update AdminDashboardWidgets.
     */
    data: XOR<AdminDashboardWidgetUpdateManyMutationInput, AdminDashboardWidgetUncheckedUpdateManyInput>
    /**
     * Filter which AdminDashboardWidgets to update
     */
    where?: AdminDashboardWidgetWhereInput
    /**
     * Limit how many AdminDashboardWidgets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminDashboardWidgetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminDashboardWidget upsert
   */
  export type AdminDashboardWidgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminDashboardWidget
     */
    select?: AdminDashboardWidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminDashboardWidget
     */
    omit?: AdminDashboardWidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminDashboardWidgetInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminDashboardWidget to update in case it exists.
     */
    where: AdminDashboardWidgetWhereUniqueInput
    /**
     * In case the AdminDashboardWidget found by the `where` argument doesn't exist, create a new AdminDashboardWidget with this data.
     */
    create: XOR<AdminDashboardWidgetCreateInput, AdminDashboardWidgetUncheckedCreateInput>
    /**
     * In case the AdminDashboardWidget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminDashboardWidgetUpdateInput, AdminDashboardWidgetUncheckedUpdateInput>
  }

  /**
   * AdminDashboardWidget delete
   */
  export type AdminDashboardWidgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminDashboardWidget
     */
    select?: AdminDashboardWidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminDashboardWidget
     */
    omit?: AdminDashboardWidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminDashboardWidgetInclude<ExtArgs> | null
    /**
     * Filter which AdminDashboardWidget to delete.
     */
    where: AdminDashboardWidgetWhereUniqueInput
  }

  /**
   * AdminDashboardWidget deleteMany
   */
  export type AdminDashboardWidgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminDashboardWidgets to delete
     */
    where?: AdminDashboardWidgetWhereInput
    /**
     * Limit how many AdminDashboardWidgets to delete.
     */
    limit?: number
  }

  /**
   * AdminDashboardWidget without action
   */
  export type AdminDashboardWidgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminDashboardWidget
     */
    select?: AdminDashboardWidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminDashboardWidget
     */
    omit?: AdminDashboardWidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminDashboardWidgetInclude<ExtArgs> | null
  }


  /**
   * Model AdminPermission
   */

  export type AggregateAdminPermission = {
    _count: AdminPermissionCountAggregateOutputType | null
    _min: AdminPermissionMinAggregateOutputType | null
    _max: AdminPermissionMaxAggregateOutputType | null
  }

  export type AdminPermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminPermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminPermissionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminPermissionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminPermissionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminPermissionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminPermission to aggregate.
     */
    where?: AdminPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPermissions to fetch.
     */
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminPermissions
    **/
    _count?: true | AdminPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminPermissionMaxAggregateInputType
  }

  export type GetAdminPermissionAggregateType<T extends AdminPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminPermission[P]>
      : GetScalarType<T[P], AggregateAdminPermission[P]>
  }




  export type AdminPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminPermissionWhereInput
    orderBy?: AdminPermissionOrderByWithAggregationInput | AdminPermissionOrderByWithAggregationInput[]
    by: AdminPermissionScalarFieldEnum[] | AdminPermissionScalarFieldEnum
    having?: AdminPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminPermissionCountAggregateInputType | true
    _min?: AdminPermissionMinAggregateInputType
    _max?: AdminPermissionMaxAggregateInputType
  }

  export type AdminPermissionGroupByOutputType = {
    id: string
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: AdminPermissionCountAggregateOutputType | null
    _min: AdminPermissionMinAggregateOutputType | null
    _max: AdminPermissionMaxAggregateOutputType | null
  }

  type GetAdminPermissionGroupByPayload<T extends AdminPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], AdminPermissionGroupByOutputType[P]>
        }
      >
    >


  export type AdminPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminRoles?: boolean | AdminPermission$adminRolesArgs<ExtArgs>
    _count?: boolean | AdminPermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminPermission"]>

  export type AdminPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminPermission"]>

  export type AdminPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminPermission"]>

  export type AdminPermissionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["adminPermission"]>
  export type AdminPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminRoles?: boolean | AdminPermission$adminRolesArgs<ExtArgs>
    _count?: boolean | AdminPermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdminPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminPermission"
    objects: {
      adminRoles: Prisma.$AdminRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminPermission"]>
    composites: {}
  }

  type AdminPermissionGetPayload<S extends boolean | null | undefined | AdminPermissionDefaultArgs> = $Result.GetResult<Prisma.$AdminPermissionPayload, S>

  type AdminPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminPermissionCountAggregateInputType | true
    }

  export interface AdminPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminPermission'], meta: { name: 'AdminPermission' } }
    /**
     * Find zero or one AdminPermission that matches the filter.
     * @param {AdminPermissionFindUniqueArgs} args - Arguments to find a AdminPermission
     * @example
     * // Get one AdminPermission
     * const adminPermission = await prisma.adminPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminPermissionFindUniqueArgs>(args: SelectSubset<T, AdminPermissionFindUniqueArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminPermissionFindUniqueOrThrowArgs} args - Arguments to find a AdminPermission
     * @example
     * // Get one AdminPermission
     * const adminPermission = await prisma.adminPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionFindFirstArgs} args - Arguments to find a AdminPermission
     * @example
     * // Get one AdminPermission
     * const adminPermission = await prisma.adminPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminPermissionFindFirstArgs>(args?: SelectSubset<T, AdminPermissionFindFirstArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionFindFirstOrThrowArgs} args - Arguments to find a AdminPermission
     * @example
     * // Get one AdminPermission
     * const adminPermission = await prisma.adminPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminPermissions
     * const adminPermissions = await prisma.adminPermission.findMany()
     * 
     * // Get first 10 AdminPermissions
     * const adminPermissions = await prisma.adminPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminPermissionWithIdOnly = await prisma.adminPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminPermissionFindManyArgs>(args?: SelectSubset<T, AdminPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminPermission.
     * @param {AdminPermissionCreateArgs} args - Arguments to create a AdminPermission.
     * @example
     * // Create one AdminPermission
     * const AdminPermission = await prisma.adminPermission.create({
     *   data: {
     *     // ... data to create a AdminPermission
     *   }
     * })
     * 
     */
    create<T extends AdminPermissionCreateArgs>(args: SelectSubset<T, AdminPermissionCreateArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminPermissions.
     * @param {AdminPermissionCreateManyArgs} args - Arguments to create many AdminPermissions.
     * @example
     * // Create many AdminPermissions
     * const adminPermission = await prisma.adminPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminPermissionCreateManyArgs>(args?: SelectSubset<T, AdminPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminPermissions and returns the data saved in the database.
     * @param {AdminPermissionCreateManyAndReturnArgs} args - Arguments to create many AdminPermissions.
     * @example
     * // Create many AdminPermissions
     * const adminPermission = await prisma.adminPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminPermissions and only return the `id`
     * const adminPermissionWithIdOnly = await prisma.adminPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminPermission.
     * @param {AdminPermissionDeleteArgs} args - Arguments to delete one AdminPermission.
     * @example
     * // Delete one AdminPermission
     * const AdminPermission = await prisma.adminPermission.delete({
     *   where: {
     *     // ... filter to delete one AdminPermission
     *   }
     * })
     * 
     */
    delete<T extends AdminPermissionDeleteArgs>(args: SelectSubset<T, AdminPermissionDeleteArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminPermission.
     * @param {AdminPermissionUpdateArgs} args - Arguments to update one AdminPermission.
     * @example
     * // Update one AdminPermission
     * const adminPermission = await prisma.adminPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminPermissionUpdateArgs>(args: SelectSubset<T, AdminPermissionUpdateArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminPermissions.
     * @param {AdminPermissionDeleteManyArgs} args - Arguments to filter AdminPermissions to delete.
     * @example
     * // Delete a few AdminPermissions
     * const { count } = await prisma.adminPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminPermissionDeleteManyArgs>(args?: SelectSubset<T, AdminPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminPermissions
     * const adminPermission = await prisma.adminPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminPermissionUpdateManyArgs>(args: SelectSubset<T, AdminPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminPermissions and returns the data updated in the database.
     * @param {AdminPermissionUpdateManyAndReturnArgs} args - Arguments to update many AdminPermissions.
     * @example
     * // Update many AdminPermissions
     * const adminPermission = await prisma.adminPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminPermissions and only return the `id`
     * const adminPermissionWithIdOnly = await prisma.adminPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminPermission.
     * @param {AdminPermissionUpsertArgs} args - Arguments to update or create a AdminPermission.
     * @example
     * // Update or create a AdminPermission
     * const adminPermission = await prisma.adminPermission.upsert({
     *   create: {
     *     // ... data to create a AdminPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminPermission we want to update
     *   }
     * })
     */
    upsert<T extends AdminPermissionUpsertArgs>(args: SelectSubset<T, AdminPermissionUpsertArgs<ExtArgs>>): Prisma__AdminPermissionClient<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionCountArgs} args - Arguments to filter AdminPermissions to count.
     * @example
     * // Count the number of AdminPermissions
     * const count = await prisma.adminPermission.count({
     *   where: {
     *     // ... the filter for the AdminPermissions we want to count
     *   }
     * })
    **/
    count<T extends AdminPermissionCountArgs>(
      args?: Subset<T, AdminPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminPermissionAggregateArgs>(args: Subset<T, AdminPermissionAggregateArgs>): Prisma.PrismaPromise<GetAdminPermissionAggregateType<T>>

    /**
     * Group by AdminPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminPermissionGroupByArgs['orderBy'] }
        : { orderBy?: AdminPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminPermission model
   */
  readonly fields: AdminPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminRoles<T extends AdminPermission$adminRolesArgs<ExtArgs> = {}>(args?: Subset<T, AdminPermission$adminRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminPermission model
   */
  interface AdminPermissionFieldRefs {
    readonly id: FieldRef<"AdminPermission", 'String'>
    readonly name: FieldRef<"AdminPermission", 'String'>
    readonly description: FieldRef<"AdminPermission", 'String'>
    readonly createdAt: FieldRef<"AdminPermission", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminPermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminPermission findUnique
   */
  export type AdminPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermission to fetch.
     */
    where: AdminPermissionWhereUniqueInput
  }

  /**
   * AdminPermission findUniqueOrThrow
   */
  export type AdminPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermission to fetch.
     */
    where: AdminPermissionWhereUniqueInput
  }

  /**
   * AdminPermission findFirst
   */
  export type AdminPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermission to fetch.
     */
    where?: AdminPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPermissions to fetch.
     */
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminPermissions.
     */
    cursor?: AdminPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminPermissions.
     */
    distinct?: AdminPermissionScalarFieldEnum | AdminPermissionScalarFieldEnum[]
  }

  /**
   * AdminPermission findFirstOrThrow
   */
  export type AdminPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermission to fetch.
     */
    where?: AdminPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPermissions to fetch.
     */
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminPermissions.
     */
    cursor?: AdminPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminPermissions.
     */
    distinct?: AdminPermissionScalarFieldEnum | AdminPermissionScalarFieldEnum[]
  }

  /**
   * AdminPermission findMany
   */
  export type AdminPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AdminPermissions to fetch.
     */
    where?: AdminPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPermissions to fetch.
     */
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminPermissions.
     */
    cursor?: AdminPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPermissions.
     */
    skip?: number
    distinct?: AdminPermissionScalarFieldEnum | AdminPermissionScalarFieldEnum[]
  }

  /**
   * AdminPermission create
   */
  export type AdminPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminPermission.
     */
    data: XOR<AdminPermissionCreateInput, AdminPermissionUncheckedCreateInput>
  }

  /**
   * AdminPermission createMany
   */
  export type AdminPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminPermissions.
     */
    data: AdminPermissionCreateManyInput | AdminPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminPermission createManyAndReturn
   */
  export type AdminPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many AdminPermissions.
     */
    data: AdminPermissionCreateManyInput | AdminPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminPermission update
   */
  export type AdminPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminPermission.
     */
    data: XOR<AdminPermissionUpdateInput, AdminPermissionUncheckedUpdateInput>
    /**
     * Choose, which AdminPermission to update.
     */
    where: AdminPermissionWhereUniqueInput
  }

  /**
   * AdminPermission updateMany
   */
  export type AdminPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminPermissions.
     */
    data: XOR<AdminPermissionUpdateManyMutationInput, AdminPermissionUncheckedUpdateManyInput>
    /**
     * Filter which AdminPermissions to update
     */
    where?: AdminPermissionWhereInput
    /**
     * Limit how many AdminPermissions to update.
     */
    limit?: number
  }

  /**
   * AdminPermission updateManyAndReturn
   */
  export type AdminPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * The data used to update AdminPermissions.
     */
    data: XOR<AdminPermissionUpdateManyMutationInput, AdminPermissionUncheckedUpdateManyInput>
    /**
     * Filter which AdminPermissions to update
     */
    where?: AdminPermissionWhereInput
    /**
     * Limit how many AdminPermissions to update.
     */
    limit?: number
  }

  /**
   * AdminPermission upsert
   */
  export type AdminPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminPermission to update in case it exists.
     */
    where: AdminPermissionWhereUniqueInput
    /**
     * In case the AdminPermission found by the `where` argument doesn't exist, create a new AdminPermission with this data.
     */
    create: XOR<AdminPermissionCreateInput, AdminPermissionUncheckedCreateInput>
    /**
     * In case the AdminPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminPermissionUpdateInput, AdminPermissionUncheckedUpdateInput>
  }

  /**
   * AdminPermission delete
   */
  export type AdminPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    /**
     * Filter which AdminPermission to delete.
     */
    where: AdminPermissionWhereUniqueInput
  }

  /**
   * AdminPermission deleteMany
   */
  export type AdminPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminPermissions to delete
     */
    where?: AdminPermissionWhereInput
    /**
     * Limit how many AdminPermissions to delete.
     */
    limit?: number
  }

  /**
   * AdminPermission.adminRoles
   */
  export type AdminPermission$adminRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRole
     */
    omit?: AdminRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    where?: AdminRoleWhereInput
    orderBy?: AdminRoleOrderByWithRelationInput | AdminRoleOrderByWithRelationInput[]
    cursor?: AdminRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminRoleScalarFieldEnum | AdminRoleScalarFieldEnum[]
  }

  /**
   * AdminPermission without action
   */
  export type AdminPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
  }


  /**
   * Model AdminRole
   */

  export type AggregateAdminRole = {
    _count: AdminRoleCountAggregateOutputType | null
    _min: AdminRoleMinAggregateOutputType | null
    _max: AdminRoleMaxAggregateOutputType | null
  }

  export type AdminRoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminRoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminRoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminRoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminRoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminRoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminRole to aggregate.
     */
    where?: AdminRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoles to fetch.
     */
    orderBy?: AdminRoleOrderByWithRelationInput | AdminRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminRoles
    **/
    _count?: true | AdminRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminRoleMaxAggregateInputType
  }

  export type GetAdminRoleAggregateType<T extends AdminRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminRole[P]>
      : GetScalarType<T[P], AggregateAdminRole[P]>
  }




  export type AdminRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminRoleWhereInput
    orderBy?: AdminRoleOrderByWithAggregationInput | AdminRoleOrderByWithAggregationInput[]
    by: AdminRoleScalarFieldEnum[] | AdminRoleScalarFieldEnum
    having?: AdminRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminRoleCountAggregateInputType | true
    _min?: AdminRoleMinAggregateInputType
    _max?: AdminRoleMaxAggregateInputType
  }

  export type AdminRoleGroupByOutputType = {
    id: string
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: AdminRoleCountAggregateOutputType | null
    _min: AdminRoleMinAggregateOutputType | null
    _max: AdminRoleMaxAggregateOutputType | null
  }

  type GetAdminRoleGroupByPayload<T extends AdminRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminRoleGroupByOutputType[P]>
            : GetScalarType<T[P], AdminRoleGroupByOutputType[P]>
        }
      >
    >


  export type AdminRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean | AdminRole$permissionsArgs<ExtArgs>
    admins?: boolean | AdminRole$adminsArgs<ExtArgs>
    _count?: boolean | AdminRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminRole"]>

  export type AdminRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminRole"]>

  export type AdminRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminRole"]>

  export type AdminRoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["adminRole"]>
  export type AdminRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | AdminRole$permissionsArgs<ExtArgs>
    admins?: boolean | AdminRole$adminsArgs<ExtArgs>
    _count?: boolean | AdminRoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdminRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminRole"
    objects: {
      permissions: Prisma.$AdminPermissionPayload<ExtArgs>[]
      admins: Prisma.$AdminRoleMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminRole"]>
    composites: {}
  }

  type AdminRoleGetPayload<S extends boolean | null | undefined | AdminRoleDefaultArgs> = $Result.GetResult<Prisma.$AdminRolePayload, S>

  type AdminRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminRoleCountAggregateInputType | true
    }

  export interface AdminRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminRole'], meta: { name: 'AdminRole' } }
    /**
     * Find zero or one AdminRole that matches the filter.
     * @param {AdminRoleFindUniqueArgs} args - Arguments to find a AdminRole
     * @example
     * // Get one AdminRole
     * const adminRole = await prisma.adminRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminRoleFindUniqueArgs>(args: SelectSubset<T, AdminRoleFindUniqueArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminRoleFindUniqueOrThrowArgs} args - Arguments to find a AdminRole
     * @example
     * // Get one AdminRole
     * const adminRole = await prisma.adminRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleFindFirstArgs} args - Arguments to find a AdminRole
     * @example
     * // Get one AdminRole
     * const adminRole = await prisma.adminRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminRoleFindFirstArgs>(args?: SelectSubset<T, AdminRoleFindFirstArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleFindFirstOrThrowArgs} args - Arguments to find a AdminRole
     * @example
     * // Get one AdminRole
     * const adminRole = await prisma.adminRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminRoles
     * const adminRoles = await prisma.adminRole.findMany()
     * 
     * // Get first 10 AdminRoles
     * const adminRoles = await prisma.adminRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminRoleWithIdOnly = await prisma.adminRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminRoleFindManyArgs>(args?: SelectSubset<T, AdminRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminRole.
     * @param {AdminRoleCreateArgs} args - Arguments to create a AdminRole.
     * @example
     * // Create one AdminRole
     * const AdminRole = await prisma.adminRole.create({
     *   data: {
     *     // ... data to create a AdminRole
     *   }
     * })
     * 
     */
    create<T extends AdminRoleCreateArgs>(args: SelectSubset<T, AdminRoleCreateArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminRoles.
     * @param {AdminRoleCreateManyArgs} args - Arguments to create many AdminRoles.
     * @example
     * // Create many AdminRoles
     * const adminRole = await prisma.adminRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminRoleCreateManyArgs>(args?: SelectSubset<T, AdminRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminRoles and returns the data saved in the database.
     * @param {AdminRoleCreateManyAndReturnArgs} args - Arguments to create many AdminRoles.
     * @example
     * // Create many AdminRoles
     * const adminRole = await prisma.adminRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminRoles and only return the `id`
     * const adminRoleWithIdOnly = await prisma.adminRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminRole.
     * @param {AdminRoleDeleteArgs} args - Arguments to delete one AdminRole.
     * @example
     * // Delete one AdminRole
     * const AdminRole = await prisma.adminRole.delete({
     *   where: {
     *     // ... filter to delete one AdminRole
     *   }
     * })
     * 
     */
    delete<T extends AdminRoleDeleteArgs>(args: SelectSubset<T, AdminRoleDeleteArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminRole.
     * @param {AdminRoleUpdateArgs} args - Arguments to update one AdminRole.
     * @example
     * // Update one AdminRole
     * const adminRole = await prisma.adminRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminRoleUpdateArgs>(args: SelectSubset<T, AdminRoleUpdateArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminRoles.
     * @param {AdminRoleDeleteManyArgs} args - Arguments to filter AdminRoles to delete.
     * @example
     * // Delete a few AdminRoles
     * const { count } = await prisma.adminRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminRoleDeleteManyArgs>(args?: SelectSubset<T, AdminRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminRoles
     * const adminRole = await prisma.adminRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminRoleUpdateManyArgs>(args: SelectSubset<T, AdminRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminRoles and returns the data updated in the database.
     * @param {AdminRoleUpdateManyAndReturnArgs} args - Arguments to update many AdminRoles.
     * @example
     * // Update many AdminRoles
     * const adminRole = await prisma.adminRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminRoles and only return the `id`
     * const adminRoleWithIdOnly = await prisma.adminRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminRole.
     * @param {AdminRoleUpsertArgs} args - Arguments to update or create a AdminRole.
     * @example
     * // Update or create a AdminRole
     * const adminRole = await prisma.adminRole.upsert({
     *   create: {
     *     // ... data to create a AdminRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminRole we want to update
     *   }
     * })
     */
    upsert<T extends AdminRoleUpsertArgs>(args: SelectSubset<T, AdminRoleUpsertArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleCountArgs} args - Arguments to filter AdminRoles to count.
     * @example
     * // Count the number of AdminRoles
     * const count = await prisma.adminRole.count({
     *   where: {
     *     // ... the filter for the AdminRoles we want to count
     *   }
     * })
    **/
    count<T extends AdminRoleCountArgs>(
      args?: Subset<T, AdminRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminRoleAggregateArgs>(args: Subset<T, AdminRoleAggregateArgs>): Prisma.PrismaPromise<GetAdminRoleAggregateType<T>>

    /**
     * Group by AdminRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminRoleGroupByArgs['orderBy'] }
        : { orderBy?: AdminRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminRole model
   */
  readonly fields: AdminRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends AdminRole$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, AdminRole$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admins<T extends AdminRole$adminsArgs<ExtArgs> = {}>(args?: Subset<T, AdminRole$adminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRoleMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminRole model
   */
  interface AdminRoleFieldRefs {
    readonly id: FieldRef<"AdminRole", 'String'>
    readonly name: FieldRef<"AdminRole", 'String'>
    readonly description: FieldRef<"AdminRole", 'String'>
    readonly createdAt: FieldRef<"AdminRole", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminRole findUnique
   */
  export type AdminRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRole
     */
    omit?: AdminRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminRole to fetch.
     */
    where: AdminRoleWhereUniqueInput
  }

  /**
   * AdminRole findUniqueOrThrow
   */
  export type AdminRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRole
     */
    omit?: AdminRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminRole to fetch.
     */
    where: AdminRoleWhereUniqueInput
  }

  /**
   * AdminRole findFirst
   */
  export type AdminRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRole
     */
    omit?: AdminRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminRole to fetch.
     */
    where?: AdminRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoles to fetch.
     */
    orderBy?: AdminRoleOrderByWithRelationInput | AdminRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminRoles.
     */
    cursor?: AdminRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminRoles.
     */
    distinct?: AdminRoleScalarFieldEnum | AdminRoleScalarFieldEnum[]
  }

  /**
   * AdminRole findFirstOrThrow
   */
  export type AdminRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRole
     */
    omit?: AdminRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminRole to fetch.
     */
    where?: AdminRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoles to fetch.
     */
    orderBy?: AdminRoleOrderByWithRelationInput | AdminRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminRoles.
     */
    cursor?: AdminRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminRoles.
     */
    distinct?: AdminRoleScalarFieldEnum | AdminRoleScalarFieldEnum[]
  }

  /**
   * AdminRole findMany
   */
  export type AdminRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRole
     */
    omit?: AdminRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminRoles to fetch.
     */
    where?: AdminRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoles to fetch.
     */
    orderBy?: AdminRoleOrderByWithRelationInput | AdminRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminRoles.
     */
    cursor?: AdminRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoles.
     */
    skip?: number
    distinct?: AdminRoleScalarFieldEnum | AdminRoleScalarFieldEnum[]
  }

  /**
   * AdminRole create
   */
  export type AdminRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRole
     */
    omit?: AdminRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminRole.
     */
    data: XOR<AdminRoleCreateInput, AdminRoleUncheckedCreateInput>
  }

  /**
   * AdminRole createMany
   */
  export type AdminRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminRoles.
     */
    data: AdminRoleCreateManyInput | AdminRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminRole createManyAndReturn
   */
  export type AdminRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRole
     */
    omit?: AdminRoleOmit<ExtArgs> | null
    /**
     * The data used to create many AdminRoles.
     */
    data: AdminRoleCreateManyInput | AdminRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminRole update
   */
  export type AdminRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRole
     */
    omit?: AdminRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminRole.
     */
    data: XOR<AdminRoleUpdateInput, AdminRoleUncheckedUpdateInput>
    /**
     * Choose, which AdminRole to update.
     */
    where: AdminRoleWhereUniqueInput
  }

  /**
   * AdminRole updateMany
   */
  export type AdminRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminRoles.
     */
    data: XOR<AdminRoleUpdateManyMutationInput, AdminRoleUncheckedUpdateManyInput>
    /**
     * Filter which AdminRoles to update
     */
    where?: AdminRoleWhereInput
    /**
     * Limit how many AdminRoles to update.
     */
    limit?: number
  }

  /**
   * AdminRole updateManyAndReturn
   */
  export type AdminRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRole
     */
    omit?: AdminRoleOmit<ExtArgs> | null
    /**
     * The data used to update AdminRoles.
     */
    data: XOR<AdminRoleUpdateManyMutationInput, AdminRoleUncheckedUpdateManyInput>
    /**
     * Filter which AdminRoles to update
     */
    where?: AdminRoleWhereInput
    /**
     * Limit how many AdminRoles to update.
     */
    limit?: number
  }

  /**
   * AdminRole upsert
   */
  export type AdminRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRole
     */
    omit?: AdminRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminRole to update in case it exists.
     */
    where: AdminRoleWhereUniqueInput
    /**
     * In case the AdminRole found by the `where` argument doesn't exist, create a new AdminRole with this data.
     */
    create: XOR<AdminRoleCreateInput, AdminRoleUncheckedCreateInput>
    /**
     * In case the AdminRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminRoleUpdateInput, AdminRoleUncheckedUpdateInput>
  }

  /**
   * AdminRole delete
   */
  export type AdminRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRole
     */
    omit?: AdminRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * Filter which AdminRole to delete.
     */
    where: AdminRoleWhereUniqueInput
  }

  /**
   * AdminRole deleteMany
   */
  export type AdminRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminRoles to delete
     */
    where?: AdminRoleWhereInput
    /**
     * Limit how many AdminRoles to delete.
     */
    limit?: number
  }

  /**
   * AdminRole.permissions
   */
  export type AdminRole$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPermission
     */
    select?: AdminPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPermission
     */
    omit?: AdminPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminPermissionInclude<ExtArgs> | null
    where?: AdminPermissionWhereInput
    orderBy?: AdminPermissionOrderByWithRelationInput | AdminPermissionOrderByWithRelationInput[]
    cursor?: AdminPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminPermissionScalarFieldEnum | AdminPermissionScalarFieldEnum[]
  }

  /**
   * AdminRole.admins
   */
  export type AdminRole$adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleMapping
     */
    select?: AdminRoleMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRoleMapping
     */
    omit?: AdminRoleMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleMappingInclude<ExtArgs> | null
    where?: AdminRoleMappingWhereInput
    orderBy?: AdminRoleMappingOrderByWithRelationInput | AdminRoleMappingOrderByWithRelationInput[]
    cursor?: AdminRoleMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminRoleMappingScalarFieldEnum | AdminRoleMappingScalarFieldEnum[]
  }

  /**
   * AdminRole without action
   */
  export type AdminRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRole
     */
    omit?: AdminRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
  }


  /**
   * Model AdminRoleMapping
   */

  export type AggregateAdminRoleMapping = {
    _count: AdminRoleMappingCountAggregateOutputType | null
    _min: AdminRoleMappingMinAggregateOutputType | null
    _max: AdminRoleMappingMaxAggregateOutputType | null
  }

  export type AdminRoleMappingMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    roleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminRoleMappingMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    roleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminRoleMappingCountAggregateOutputType = {
    id: number
    adminId: number
    roleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminRoleMappingMinAggregateInputType = {
    id?: true
    adminId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminRoleMappingMaxAggregateInputType = {
    id?: true
    adminId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminRoleMappingCountAggregateInputType = {
    id?: true
    adminId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminRoleMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminRoleMapping to aggregate.
     */
    where?: AdminRoleMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoleMappings to fetch.
     */
    orderBy?: AdminRoleMappingOrderByWithRelationInput | AdminRoleMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminRoleMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoleMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoleMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminRoleMappings
    **/
    _count?: true | AdminRoleMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminRoleMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminRoleMappingMaxAggregateInputType
  }

  export type GetAdminRoleMappingAggregateType<T extends AdminRoleMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminRoleMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminRoleMapping[P]>
      : GetScalarType<T[P], AggregateAdminRoleMapping[P]>
  }




  export type AdminRoleMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminRoleMappingWhereInput
    orderBy?: AdminRoleMappingOrderByWithAggregationInput | AdminRoleMappingOrderByWithAggregationInput[]
    by: AdminRoleMappingScalarFieldEnum[] | AdminRoleMappingScalarFieldEnum
    having?: AdminRoleMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminRoleMappingCountAggregateInputType | true
    _min?: AdminRoleMappingMinAggregateInputType
    _max?: AdminRoleMappingMaxAggregateInputType
  }

  export type AdminRoleMappingGroupByOutputType = {
    id: string
    adminId: string
    roleId: string
    createdAt: Date
    updatedAt: Date
    _count: AdminRoleMappingCountAggregateOutputType | null
    _min: AdminRoleMappingMinAggregateOutputType | null
    _max: AdminRoleMappingMaxAggregateOutputType | null
  }

  type GetAdminRoleMappingGroupByPayload<T extends AdminRoleMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminRoleMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminRoleMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminRoleMappingGroupByOutputType[P]>
            : GetScalarType<T[P], AdminRoleMappingGroupByOutputType[P]>
        }
      >
    >


  export type AdminRoleMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    role?: boolean | AdminRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminRoleMapping"]>

  export type AdminRoleMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    role?: boolean | AdminRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminRoleMapping"]>

  export type AdminRoleMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    role?: boolean | AdminRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminRoleMapping"]>

  export type AdminRoleMappingSelectScalar = {
    id?: boolean
    adminId?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminRoleMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "roleId" | "createdAt" | "updatedAt", ExtArgs["result"]["adminRoleMapping"]>
  export type AdminRoleMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    role?: boolean | AdminRoleDefaultArgs<ExtArgs>
  }
  export type AdminRoleMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    role?: boolean | AdminRoleDefaultArgs<ExtArgs>
  }
  export type AdminRoleMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    role?: boolean | AdminRoleDefaultArgs<ExtArgs>
  }

  export type $AdminRoleMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminRoleMapping"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      role: Prisma.$AdminRolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      roleId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminRoleMapping"]>
    composites: {}
  }

  type AdminRoleMappingGetPayload<S extends boolean | null | undefined | AdminRoleMappingDefaultArgs> = $Result.GetResult<Prisma.$AdminRoleMappingPayload, S>

  type AdminRoleMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminRoleMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminRoleMappingCountAggregateInputType | true
    }

  export interface AdminRoleMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminRoleMapping'], meta: { name: 'AdminRoleMapping' } }
    /**
     * Find zero or one AdminRoleMapping that matches the filter.
     * @param {AdminRoleMappingFindUniqueArgs} args - Arguments to find a AdminRoleMapping
     * @example
     * // Get one AdminRoleMapping
     * const adminRoleMapping = await prisma.adminRoleMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminRoleMappingFindUniqueArgs>(args: SelectSubset<T, AdminRoleMappingFindUniqueArgs<ExtArgs>>): Prisma__AdminRoleMappingClient<$Result.GetResult<Prisma.$AdminRoleMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminRoleMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminRoleMappingFindUniqueOrThrowArgs} args - Arguments to find a AdminRoleMapping
     * @example
     * // Get one AdminRoleMapping
     * const adminRoleMapping = await prisma.adminRoleMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminRoleMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminRoleMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminRoleMappingClient<$Result.GetResult<Prisma.$AdminRoleMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminRoleMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleMappingFindFirstArgs} args - Arguments to find a AdminRoleMapping
     * @example
     * // Get one AdminRoleMapping
     * const adminRoleMapping = await prisma.adminRoleMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminRoleMappingFindFirstArgs>(args?: SelectSubset<T, AdminRoleMappingFindFirstArgs<ExtArgs>>): Prisma__AdminRoleMappingClient<$Result.GetResult<Prisma.$AdminRoleMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminRoleMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleMappingFindFirstOrThrowArgs} args - Arguments to find a AdminRoleMapping
     * @example
     * // Get one AdminRoleMapping
     * const adminRoleMapping = await prisma.adminRoleMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminRoleMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminRoleMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminRoleMappingClient<$Result.GetResult<Prisma.$AdminRoleMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminRoleMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminRoleMappings
     * const adminRoleMappings = await prisma.adminRoleMapping.findMany()
     * 
     * // Get first 10 AdminRoleMappings
     * const adminRoleMappings = await prisma.adminRoleMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminRoleMappingWithIdOnly = await prisma.adminRoleMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminRoleMappingFindManyArgs>(args?: SelectSubset<T, AdminRoleMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRoleMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminRoleMapping.
     * @param {AdminRoleMappingCreateArgs} args - Arguments to create a AdminRoleMapping.
     * @example
     * // Create one AdminRoleMapping
     * const AdminRoleMapping = await prisma.adminRoleMapping.create({
     *   data: {
     *     // ... data to create a AdminRoleMapping
     *   }
     * })
     * 
     */
    create<T extends AdminRoleMappingCreateArgs>(args: SelectSubset<T, AdminRoleMappingCreateArgs<ExtArgs>>): Prisma__AdminRoleMappingClient<$Result.GetResult<Prisma.$AdminRoleMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminRoleMappings.
     * @param {AdminRoleMappingCreateManyArgs} args - Arguments to create many AdminRoleMappings.
     * @example
     * // Create many AdminRoleMappings
     * const adminRoleMapping = await prisma.adminRoleMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminRoleMappingCreateManyArgs>(args?: SelectSubset<T, AdminRoleMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminRoleMappings and returns the data saved in the database.
     * @param {AdminRoleMappingCreateManyAndReturnArgs} args - Arguments to create many AdminRoleMappings.
     * @example
     * // Create many AdminRoleMappings
     * const adminRoleMapping = await prisma.adminRoleMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminRoleMappings and only return the `id`
     * const adminRoleMappingWithIdOnly = await prisma.adminRoleMapping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminRoleMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminRoleMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRoleMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminRoleMapping.
     * @param {AdminRoleMappingDeleteArgs} args - Arguments to delete one AdminRoleMapping.
     * @example
     * // Delete one AdminRoleMapping
     * const AdminRoleMapping = await prisma.adminRoleMapping.delete({
     *   where: {
     *     // ... filter to delete one AdminRoleMapping
     *   }
     * })
     * 
     */
    delete<T extends AdminRoleMappingDeleteArgs>(args: SelectSubset<T, AdminRoleMappingDeleteArgs<ExtArgs>>): Prisma__AdminRoleMappingClient<$Result.GetResult<Prisma.$AdminRoleMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminRoleMapping.
     * @param {AdminRoleMappingUpdateArgs} args - Arguments to update one AdminRoleMapping.
     * @example
     * // Update one AdminRoleMapping
     * const adminRoleMapping = await prisma.adminRoleMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminRoleMappingUpdateArgs>(args: SelectSubset<T, AdminRoleMappingUpdateArgs<ExtArgs>>): Prisma__AdminRoleMappingClient<$Result.GetResult<Prisma.$AdminRoleMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminRoleMappings.
     * @param {AdminRoleMappingDeleteManyArgs} args - Arguments to filter AdminRoleMappings to delete.
     * @example
     * // Delete a few AdminRoleMappings
     * const { count } = await prisma.adminRoleMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminRoleMappingDeleteManyArgs>(args?: SelectSubset<T, AdminRoleMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminRoleMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminRoleMappings
     * const adminRoleMapping = await prisma.adminRoleMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminRoleMappingUpdateManyArgs>(args: SelectSubset<T, AdminRoleMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminRoleMappings and returns the data updated in the database.
     * @param {AdminRoleMappingUpdateManyAndReturnArgs} args - Arguments to update many AdminRoleMappings.
     * @example
     * // Update many AdminRoleMappings
     * const adminRoleMapping = await prisma.adminRoleMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminRoleMappings and only return the `id`
     * const adminRoleMappingWithIdOnly = await prisma.adminRoleMapping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminRoleMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminRoleMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRoleMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminRoleMapping.
     * @param {AdminRoleMappingUpsertArgs} args - Arguments to update or create a AdminRoleMapping.
     * @example
     * // Update or create a AdminRoleMapping
     * const adminRoleMapping = await prisma.adminRoleMapping.upsert({
     *   create: {
     *     // ... data to create a AdminRoleMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminRoleMapping we want to update
     *   }
     * })
     */
    upsert<T extends AdminRoleMappingUpsertArgs>(args: SelectSubset<T, AdminRoleMappingUpsertArgs<ExtArgs>>): Prisma__AdminRoleMappingClient<$Result.GetResult<Prisma.$AdminRoleMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminRoleMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleMappingCountArgs} args - Arguments to filter AdminRoleMappings to count.
     * @example
     * // Count the number of AdminRoleMappings
     * const count = await prisma.adminRoleMapping.count({
     *   where: {
     *     // ... the filter for the AdminRoleMappings we want to count
     *   }
     * })
    **/
    count<T extends AdminRoleMappingCountArgs>(
      args?: Subset<T, AdminRoleMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminRoleMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminRoleMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminRoleMappingAggregateArgs>(args: Subset<T, AdminRoleMappingAggregateArgs>): Prisma.PrismaPromise<GetAdminRoleMappingAggregateType<T>>

    /**
     * Group by AdminRoleMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminRoleMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminRoleMappingGroupByArgs['orderBy'] }
        : { orderBy?: AdminRoleMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminRoleMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminRoleMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminRoleMapping model
   */
  readonly fields: AdminRoleMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminRoleMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminRoleMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends AdminRoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminRoleDefaultArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminRoleMapping model
   */
  interface AdminRoleMappingFieldRefs {
    readonly id: FieldRef<"AdminRoleMapping", 'String'>
    readonly adminId: FieldRef<"AdminRoleMapping", 'String'>
    readonly roleId: FieldRef<"AdminRoleMapping", 'String'>
    readonly createdAt: FieldRef<"AdminRoleMapping", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminRoleMapping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminRoleMapping findUnique
   */
  export type AdminRoleMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleMapping
     */
    select?: AdminRoleMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRoleMapping
     */
    omit?: AdminRoleMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which AdminRoleMapping to fetch.
     */
    where: AdminRoleMappingWhereUniqueInput
  }

  /**
   * AdminRoleMapping findUniqueOrThrow
   */
  export type AdminRoleMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleMapping
     */
    select?: AdminRoleMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRoleMapping
     */
    omit?: AdminRoleMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which AdminRoleMapping to fetch.
     */
    where: AdminRoleMappingWhereUniqueInput
  }

  /**
   * AdminRoleMapping findFirst
   */
  export type AdminRoleMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleMapping
     */
    select?: AdminRoleMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRoleMapping
     */
    omit?: AdminRoleMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which AdminRoleMapping to fetch.
     */
    where?: AdminRoleMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoleMappings to fetch.
     */
    orderBy?: AdminRoleMappingOrderByWithRelationInput | AdminRoleMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminRoleMappings.
     */
    cursor?: AdminRoleMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoleMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoleMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminRoleMappings.
     */
    distinct?: AdminRoleMappingScalarFieldEnum | AdminRoleMappingScalarFieldEnum[]
  }

  /**
   * AdminRoleMapping findFirstOrThrow
   */
  export type AdminRoleMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleMapping
     */
    select?: AdminRoleMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRoleMapping
     */
    omit?: AdminRoleMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which AdminRoleMapping to fetch.
     */
    where?: AdminRoleMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoleMappings to fetch.
     */
    orderBy?: AdminRoleMappingOrderByWithRelationInput | AdminRoleMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminRoleMappings.
     */
    cursor?: AdminRoleMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoleMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoleMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminRoleMappings.
     */
    distinct?: AdminRoleMappingScalarFieldEnum | AdminRoleMappingScalarFieldEnum[]
  }

  /**
   * AdminRoleMapping findMany
   */
  export type AdminRoleMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleMapping
     */
    select?: AdminRoleMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRoleMapping
     */
    omit?: AdminRoleMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleMappingInclude<ExtArgs> | null
    /**
     * Filter, which AdminRoleMappings to fetch.
     */
    where?: AdminRoleMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoleMappings to fetch.
     */
    orderBy?: AdminRoleMappingOrderByWithRelationInput | AdminRoleMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminRoleMappings.
     */
    cursor?: AdminRoleMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoleMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoleMappings.
     */
    skip?: number
    distinct?: AdminRoleMappingScalarFieldEnum | AdminRoleMappingScalarFieldEnum[]
  }

  /**
   * AdminRoleMapping create
   */
  export type AdminRoleMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleMapping
     */
    select?: AdminRoleMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRoleMapping
     */
    omit?: AdminRoleMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminRoleMapping.
     */
    data: XOR<AdminRoleMappingCreateInput, AdminRoleMappingUncheckedCreateInput>
  }

  /**
   * AdminRoleMapping createMany
   */
  export type AdminRoleMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminRoleMappings.
     */
    data: AdminRoleMappingCreateManyInput | AdminRoleMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminRoleMapping createManyAndReturn
   */
  export type AdminRoleMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleMapping
     */
    select?: AdminRoleMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRoleMapping
     */
    omit?: AdminRoleMappingOmit<ExtArgs> | null
    /**
     * The data used to create many AdminRoleMappings.
     */
    data: AdminRoleMappingCreateManyInput | AdminRoleMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminRoleMapping update
   */
  export type AdminRoleMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleMapping
     */
    select?: AdminRoleMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRoleMapping
     */
    omit?: AdminRoleMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminRoleMapping.
     */
    data: XOR<AdminRoleMappingUpdateInput, AdminRoleMappingUncheckedUpdateInput>
    /**
     * Choose, which AdminRoleMapping to update.
     */
    where: AdminRoleMappingWhereUniqueInput
  }

  /**
   * AdminRoleMapping updateMany
   */
  export type AdminRoleMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminRoleMappings.
     */
    data: XOR<AdminRoleMappingUpdateManyMutationInput, AdminRoleMappingUncheckedUpdateManyInput>
    /**
     * Filter which AdminRoleMappings to update
     */
    where?: AdminRoleMappingWhereInput
    /**
     * Limit how many AdminRoleMappings to update.
     */
    limit?: number
  }

  /**
   * AdminRoleMapping updateManyAndReturn
   */
  export type AdminRoleMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleMapping
     */
    select?: AdminRoleMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRoleMapping
     */
    omit?: AdminRoleMappingOmit<ExtArgs> | null
    /**
     * The data used to update AdminRoleMappings.
     */
    data: XOR<AdminRoleMappingUpdateManyMutationInput, AdminRoleMappingUncheckedUpdateManyInput>
    /**
     * Filter which AdminRoleMappings to update
     */
    where?: AdminRoleMappingWhereInput
    /**
     * Limit how many AdminRoleMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminRoleMapping upsert
   */
  export type AdminRoleMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleMapping
     */
    select?: AdminRoleMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRoleMapping
     */
    omit?: AdminRoleMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminRoleMapping to update in case it exists.
     */
    where: AdminRoleMappingWhereUniqueInput
    /**
     * In case the AdminRoleMapping found by the `where` argument doesn't exist, create a new AdminRoleMapping with this data.
     */
    create: XOR<AdminRoleMappingCreateInput, AdminRoleMappingUncheckedCreateInput>
    /**
     * In case the AdminRoleMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminRoleMappingUpdateInput, AdminRoleMappingUncheckedUpdateInput>
  }

  /**
   * AdminRoleMapping delete
   */
  export type AdminRoleMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleMapping
     */
    select?: AdminRoleMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRoleMapping
     */
    omit?: AdminRoleMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleMappingInclude<ExtArgs> | null
    /**
     * Filter which AdminRoleMapping to delete.
     */
    where: AdminRoleMappingWhereUniqueInput
  }

  /**
   * AdminRoleMapping deleteMany
   */
  export type AdminRoleMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminRoleMappings to delete
     */
    where?: AdminRoleMappingWhereInput
    /**
     * Limit how many AdminRoleMappings to delete.
     */
    limit?: number
  }

  /**
   * AdminRoleMapping without action
   */
  export type AdminRoleMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleMapping
     */
    select?: AdminRoleMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminRoleMapping
     */
    omit?: AdminRoleMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleMappingInclude<ExtArgs> | null
  }


  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    body: string | null
    category: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    body: string | null
    category: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    body: number
    category: number
    description: number
    isActive: number
    variables: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type EmailTemplateMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    category?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    category?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    category?: true
    description?: true
    isActive?: true
    variables?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: string
    name: string
    subject: string
    body: string
    category: string
    description: string | null
    isActive: boolean
    variables: JsonValue
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string | null
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    category?: boolean
    description?: boolean
    isActive?: boolean
    variables?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    sentEmails?: boolean | EmailTemplate$sentEmailsArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    category?: boolean
    description?: boolean
    isActive?: boolean
    variables?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    category?: boolean
    description?: boolean
    isActive?: boolean
    variables?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    category?: boolean
    description?: boolean
    isActive?: boolean
    variables?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type EmailTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subject" | "body" | "category" | "description" | "isActive" | "variables" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["emailTemplate"]>
  export type EmailTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentEmails?: boolean | EmailTemplate$sentEmailsArgs<ExtArgs>
    _count?: boolean | EmailTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmailTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {
      sentEmails: Prisma.$SentEmailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string
      body: string
      category: string
      description: string | null
      isActive: boolean
      variables: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string | null
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }

  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailTemplateFindUniqueArgs>(args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailTemplateFindFirstArgs>(args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailTemplateFindManyArgs>(args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
     */
    create<T extends EmailTemplateCreateArgs>(args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailTemplates.
     * @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailTemplateCreateManyArgs>(args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTemplates and returns the data saved in the database.
     * @param {EmailTemplateCreateManyAndReturnArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
     */
    delete<T extends EmailTemplateDeleteArgs>(args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailTemplateUpdateArgs>(args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailTemplateDeleteManyArgs>(args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailTemplateUpdateManyArgs>(args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates and returns the data updated in the database.
     * @param {EmailTemplateUpdateManyAndReturnArgs} args - Arguments to update many EmailTemplates.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
     */
    upsert<T extends EmailTemplateUpsertArgs>(args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sentEmails<T extends EmailTemplate$sentEmailsArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplate$sentEmailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailTemplate model
   */
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'String'>
    readonly name: FieldRef<"EmailTemplate", 'String'>
    readonly subject: FieldRef<"EmailTemplate", 'String'>
    readonly body: FieldRef<"EmailTemplate", 'String'>
    readonly category: FieldRef<"EmailTemplate", 'String'>
    readonly description: FieldRef<"EmailTemplate", 'String'>
    readonly isActive: FieldRef<"EmailTemplate", 'Boolean'>
    readonly variables: FieldRef<"EmailTemplate", 'Json'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly createdBy: FieldRef<"EmailTemplate", 'String'>
    readonly updatedBy: FieldRef<"EmailTemplate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }

  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate createManyAndReturn
   */
  export type EmailTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate updateManyAndReturn
   */
  export type EmailTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }

  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to delete.
     */
    limit?: number
  }

  /**
   * EmailTemplate.sentEmails
   */
  export type EmailTemplate$sentEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SentEmail
     */
    omit?: SentEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    where?: SentEmailWhereInput
    orderBy?: SentEmailOrderByWithRelationInput | SentEmailOrderByWithRelationInput[]
    cursor?: SentEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SentEmailScalarFieldEnum | SentEmailScalarFieldEnum[]
  }

  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTemplateInclude<ExtArgs> | null
  }


  /**
   * Model SentEmail
   */

  export type AggregateSentEmail = {
    _count: SentEmailCountAggregateOutputType | null
    _min: SentEmailMinAggregateOutputType | null
    _max: SentEmailMaxAggregateOutputType | null
  }

  export type SentEmailMinAggregateOutputType = {
    id: string | null
    templateId: string | null
    recipient: string | null
    subject: string | null
    variables: string | null
    messageId: string | null
    sentBy: string | null
    sentAt: Date | null
    status: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SentEmailMaxAggregateOutputType = {
    id: string | null
    templateId: string | null
    recipient: string | null
    subject: string | null
    variables: string | null
    messageId: string | null
    sentBy: string | null
    sentAt: Date | null
    status: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SentEmailCountAggregateOutputType = {
    id: number
    templateId: number
    recipient: number
    subject: number
    variables: number
    messageId: number
    sentBy: number
    sentAt: number
    status: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SentEmailMinAggregateInputType = {
    id?: true
    templateId?: true
    recipient?: true
    subject?: true
    variables?: true
    messageId?: true
    sentBy?: true
    sentAt?: true
    status?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SentEmailMaxAggregateInputType = {
    id?: true
    templateId?: true
    recipient?: true
    subject?: true
    variables?: true
    messageId?: true
    sentBy?: true
    sentAt?: true
    status?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SentEmailCountAggregateInputType = {
    id?: true
    templateId?: true
    recipient?: true
    subject?: true
    variables?: true
    messageId?: true
    sentBy?: true
    sentAt?: true
    status?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SentEmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SentEmail to aggregate.
     */
    where?: SentEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SentEmails to fetch.
     */
    orderBy?: SentEmailOrderByWithRelationInput | SentEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SentEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SentEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SentEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SentEmails
    **/
    _count?: true | SentEmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SentEmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SentEmailMaxAggregateInputType
  }

  export type GetSentEmailAggregateType<T extends SentEmailAggregateArgs> = {
        [P in keyof T & keyof AggregateSentEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSentEmail[P]>
      : GetScalarType<T[P], AggregateSentEmail[P]>
  }




  export type SentEmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SentEmailWhereInput
    orderBy?: SentEmailOrderByWithAggregationInput | SentEmailOrderByWithAggregationInput[]
    by: SentEmailScalarFieldEnum[] | SentEmailScalarFieldEnum
    having?: SentEmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SentEmailCountAggregateInputType | true
    _min?: SentEmailMinAggregateInputType
    _max?: SentEmailMaxAggregateInputType
  }

  export type SentEmailGroupByOutputType = {
    id: string
    templateId: string
    recipient: string
    subject: string
    variables: string
    messageId: string | null
    sentBy: string
    sentAt: Date
    status: string
    category: string
    createdAt: Date
    updatedAt: Date
    _count: SentEmailCountAggregateOutputType | null
    _min: SentEmailMinAggregateOutputType | null
    _max: SentEmailMaxAggregateOutputType | null
  }

  type GetSentEmailGroupByPayload<T extends SentEmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SentEmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SentEmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SentEmailGroupByOutputType[P]>
            : GetScalarType<T[P], SentEmailGroupByOutputType[P]>
        }
      >
    >


  export type SentEmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    recipient?: boolean
    subject?: boolean
    variables?: boolean
    messageId?: boolean
    sentBy?: boolean
    sentAt?: boolean
    status?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    template?: boolean | EmailTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sentEmail"]>

  export type SentEmailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    recipient?: boolean
    subject?: boolean
    variables?: boolean
    messageId?: boolean
    sentBy?: boolean
    sentAt?: boolean
    status?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    template?: boolean | EmailTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sentEmail"]>

  export type SentEmailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    recipient?: boolean
    subject?: boolean
    variables?: boolean
    messageId?: boolean
    sentBy?: boolean
    sentAt?: boolean
    status?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    template?: boolean | EmailTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sentEmail"]>

  export type SentEmailSelectScalar = {
    id?: boolean
    templateId?: boolean
    recipient?: boolean
    subject?: boolean
    variables?: boolean
    messageId?: boolean
    sentBy?: boolean
    sentAt?: boolean
    status?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SentEmailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "templateId" | "recipient" | "subject" | "variables" | "messageId" | "sentBy" | "sentAt" | "status" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["sentEmail"]>
  export type SentEmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | EmailTemplateDefaultArgs<ExtArgs>
  }
  export type SentEmailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | EmailTemplateDefaultArgs<ExtArgs>
  }
  export type SentEmailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | EmailTemplateDefaultArgs<ExtArgs>
  }

  export type $SentEmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SentEmail"
    objects: {
      template: Prisma.$EmailTemplatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      templateId: string
      recipient: string
      subject: string
      variables: string
      messageId: string | null
      sentBy: string
      sentAt: Date
      status: string
      category: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sentEmail"]>
    composites: {}
  }

  type SentEmailGetPayload<S extends boolean | null | undefined | SentEmailDefaultArgs> = $Result.GetResult<Prisma.$SentEmailPayload, S>

  type SentEmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SentEmailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SentEmailCountAggregateInputType | true
    }

  export interface SentEmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SentEmail'], meta: { name: 'SentEmail' } }
    /**
     * Find zero or one SentEmail that matches the filter.
     * @param {SentEmailFindUniqueArgs} args - Arguments to find a SentEmail
     * @example
     * // Get one SentEmail
     * const sentEmail = await prisma.sentEmail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SentEmailFindUniqueArgs>(args: SelectSubset<T, SentEmailFindUniqueArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SentEmail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SentEmailFindUniqueOrThrowArgs} args - Arguments to find a SentEmail
     * @example
     * // Get one SentEmail
     * const sentEmail = await prisma.sentEmail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SentEmailFindUniqueOrThrowArgs>(args: SelectSubset<T, SentEmailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SentEmail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailFindFirstArgs} args - Arguments to find a SentEmail
     * @example
     * // Get one SentEmail
     * const sentEmail = await prisma.sentEmail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SentEmailFindFirstArgs>(args?: SelectSubset<T, SentEmailFindFirstArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SentEmail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailFindFirstOrThrowArgs} args - Arguments to find a SentEmail
     * @example
     * // Get one SentEmail
     * const sentEmail = await prisma.sentEmail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SentEmailFindFirstOrThrowArgs>(args?: SelectSubset<T, SentEmailFindFirstOrThrowArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SentEmails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SentEmails
     * const sentEmails = await prisma.sentEmail.findMany()
     * 
     * // Get first 10 SentEmails
     * const sentEmails = await prisma.sentEmail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sentEmailWithIdOnly = await prisma.sentEmail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SentEmailFindManyArgs>(args?: SelectSubset<T, SentEmailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SentEmail.
     * @param {SentEmailCreateArgs} args - Arguments to create a SentEmail.
     * @example
     * // Create one SentEmail
     * const SentEmail = await prisma.sentEmail.create({
     *   data: {
     *     // ... data to create a SentEmail
     *   }
     * })
     * 
     */
    create<T extends SentEmailCreateArgs>(args: SelectSubset<T, SentEmailCreateArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SentEmails.
     * @param {SentEmailCreateManyArgs} args - Arguments to create many SentEmails.
     * @example
     * // Create many SentEmails
     * const sentEmail = await prisma.sentEmail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SentEmailCreateManyArgs>(args?: SelectSubset<T, SentEmailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SentEmails and returns the data saved in the database.
     * @param {SentEmailCreateManyAndReturnArgs} args - Arguments to create many SentEmails.
     * @example
     * // Create many SentEmails
     * const sentEmail = await prisma.sentEmail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SentEmails and only return the `id`
     * const sentEmailWithIdOnly = await prisma.sentEmail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SentEmailCreateManyAndReturnArgs>(args?: SelectSubset<T, SentEmailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SentEmail.
     * @param {SentEmailDeleteArgs} args - Arguments to delete one SentEmail.
     * @example
     * // Delete one SentEmail
     * const SentEmail = await prisma.sentEmail.delete({
     *   where: {
     *     // ... filter to delete one SentEmail
     *   }
     * })
     * 
     */
    delete<T extends SentEmailDeleteArgs>(args: SelectSubset<T, SentEmailDeleteArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SentEmail.
     * @param {SentEmailUpdateArgs} args - Arguments to update one SentEmail.
     * @example
     * // Update one SentEmail
     * const sentEmail = await prisma.sentEmail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SentEmailUpdateArgs>(args: SelectSubset<T, SentEmailUpdateArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SentEmails.
     * @param {SentEmailDeleteManyArgs} args - Arguments to filter SentEmails to delete.
     * @example
     * // Delete a few SentEmails
     * const { count } = await prisma.sentEmail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SentEmailDeleteManyArgs>(args?: SelectSubset<T, SentEmailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SentEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SentEmails
     * const sentEmail = await prisma.sentEmail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SentEmailUpdateManyArgs>(args: SelectSubset<T, SentEmailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SentEmails and returns the data updated in the database.
     * @param {SentEmailUpdateManyAndReturnArgs} args - Arguments to update many SentEmails.
     * @example
     * // Update many SentEmails
     * const sentEmail = await prisma.sentEmail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SentEmails and only return the `id`
     * const sentEmailWithIdOnly = await prisma.sentEmail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SentEmailUpdateManyAndReturnArgs>(args: SelectSubset<T, SentEmailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SentEmail.
     * @param {SentEmailUpsertArgs} args - Arguments to update or create a SentEmail.
     * @example
     * // Update or create a SentEmail
     * const sentEmail = await prisma.sentEmail.upsert({
     *   create: {
     *     // ... data to create a SentEmail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SentEmail we want to update
     *   }
     * })
     */
    upsert<T extends SentEmailUpsertArgs>(args: SelectSubset<T, SentEmailUpsertArgs<ExtArgs>>): Prisma__SentEmailClient<$Result.GetResult<Prisma.$SentEmailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SentEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailCountArgs} args - Arguments to filter SentEmails to count.
     * @example
     * // Count the number of SentEmails
     * const count = await prisma.sentEmail.count({
     *   where: {
     *     // ... the filter for the SentEmails we want to count
     *   }
     * })
    **/
    count<T extends SentEmailCountArgs>(
      args?: Subset<T, SentEmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SentEmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SentEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SentEmailAggregateArgs>(args: Subset<T, SentEmailAggregateArgs>): Prisma.PrismaPromise<GetSentEmailAggregateType<T>>

    /**
     * Group by SentEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SentEmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SentEmailGroupByArgs['orderBy'] }
        : { orderBy?: SentEmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SentEmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSentEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SentEmail model
   */
  readonly fields: SentEmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SentEmail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SentEmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends EmailTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailTemplateDefaultArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SentEmail model
   */
  interface SentEmailFieldRefs {
    readonly id: FieldRef<"SentEmail", 'String'>
    readonly templateId: FieldRef<"SentEmail", 'String'>
    readonly recipient: FieldRef<"SentEmail", 'String'>
    readonly subject: FieldRef<"SentEmail", 'String'>
    readonly variables: FieldRef<"SentEmail", 'String'>
    readonly messageId: FieldRef<"SentEmail", 'String'>
    readonly sentBy: FieldRef<"SentEmail", 'String'>
    readonly sentAt: FieldRef<"SentEmail", 'DateTime'>
    readonly status: FieldRef<"SentEmail", 'String'>
    readonly category: FieldRef<"SentEmail", 'String'>
    readonly createdAt: FieldRef<"SentEmail", 'DateTime'>
    readonly updatedAt: FieldRef<"SentEmail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SentEmail findUnique
   */
  export type SentEmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SentEmail
     */
    omit?: SentEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * Filter, which SentEmail to fetch.
     */
    where: SentEmailWhereUniqueInput
  }

  /**
   * SentEmail findUniqueOrThrow
   */
  export type SentEmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SentEmail
     */
    omit?: SentEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * Filter, which SentEmail to fetch.
     */
    where: SentEmailWhereUniqueInput
  }

  /**
   * SentEmail findFirst
   */
  export type SentEmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SentEmail
     */
    omit?: SentEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * Filter, which SentEmail to fetch.
     */
    where?: SentEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SentEmails to fetch.
     */
    orderBy?: SentEmailOrderByWithRelationInput | SentEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SentEmails.
     */
    cursor?: SentEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SentEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SentEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SentEmails.
     */
    distinct?: SentEmailScalarFieldEnum | SentEmailScalarFieldEnum[]
  }

  /**
   * SentEmail findFirstOrThrow
   */
  export type SentEmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SentEmail
     */
    omit?: SentEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * Filter, which SentEmail to fetch.
     */
    where?: SentEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SentEmails to fetch.
     */
    orderBy?: SentEmailOrderByWithRelationInput | SentEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SentEmails.
     */
    cursor?: SentEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SentEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SentEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SentEmails.
     */
    distinct?: SentEmailScalarFieldEnum | SentEmailScalarFieldEnum[]
  }

  /**
   * SentEmail findMany
   */
  export type SentEmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SentEmail
     */
    omit?: SentEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * Filter, which SentEmails to fetch.
     */
    where?: SentEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SentEmails to fetch.
     */
    orderBy?: SentEmailOrderByWithRelationInput | SentEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SentEmails.
     */
    cursor?: SentEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SentEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SentEmails.
     */
    skip?: number
    distinct?: SentEmailScalarFieldEnum | SentEmailScalarFieldEnum[]
  }

  /**
   * SentEmail create
   */
  export type SentEmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SentEmail
     */
    omit?: SentEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * The data needed to create a SentEmail.
     */
    data: XOR<SentEmailCreateInput, SentEmailUncheckedCreateInput>
  }

  /**
   * SentEmail createMany
   */
  export type SentEmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SentEmails.
     */
    data: SentEmailCreateManyInput | SentEmailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SentEmail createManyAndReturn
   */
  export type SentEmailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SentEmail
     */
    omit?: SentEmailOmit<ExtArgs> | null
    /**
     * The data used to create many SentEmails.
     */
    data: SentEmailCreateManyInput | SentEmailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SentEmail update
   */
  export type SentEmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SentEmail
     */
    omit?: SentEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * The data needed to update a SentEmail.
     */
    data: XOR<SentEmailUpdateInput, SentEmailUncheckedUpdateInput>
    /**
     * Choose, which SentEmail to update.
     */
    where: SentEmailWhereUniqueInput
  }

  /**
   * SentEmail updateMany
   */
  export type SentEmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SentEmails.
     */
    data: XOR<SentEmailUpdateManyMutationInput, SentEmailUncheckedUpdateManyInput>
    /**
     * Filter which SentEmails to update
     */
    where?: SentEmailWhereInput
    /**
     * Limit how many SentEmails to update.
     */
    limit?: number
  }

  /**
   * SentEmail updateManyAndReturn
   */
  export type SentEmailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SentEmail
     */
    omit?: SentEmailOmit<ExtArgs> | null
    /**
     * The data used to update SentEmails.
     */
    data: XOR<SentEmailUpdateManyMutationInput, SentEmailUncheckedUpdateManyInput>
    /**
     * Filter which SentEmails to update
     */
    where?: SentEmailWhereInput
    /**
     * Limit how many SentEmails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SentEmail upsert
   */
  export type SentEmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SentEmail
     */
    omit?: SentEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * The filter to search for the SentEmail to update in case it exists.
     */
    where: SentEmailWhereUniqueInput
    /**
     * In case the SentEmail found by the `where` argument doesn't exist, create a new SentEmail with this data.
     */
    create: XOR<SentEmailCreateInput, SentEmailUncheckedCreateInput>
    /**
     * In case the SentEmail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SentEmailUpdateInput, SentEmailUncheckedUpdateInput>
  }

  /**
   * SentEmail delete
   */
  export type SentEmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SentEmail
     */
    omit?: SentEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
    /**
     * Filter which SentEmail to delete.
     */
    where: SentEmailWhereUniqueInput
  }

  /**
   * SentEmail deleteMany
   */
  export type SentEmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SentEmails to delete
     */
    where?: SentEmailWhereInput
    /**
     * Limit how many SentEmails to delete.
     */
    limit?: number
  }

  /**
   * SentEmail without action
   */
  export type SentEmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SentEmail
     */
    omit?: SentEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentEmailInclude<ExtArgs> | null
  }


  /**
   * Model CustomerAddress
   */

  export type AggregateCustomerAddress = {
    _count: CustomerAddressCountAggregateOutputType | null
    _avg: CustomerAddressAvgAggregateOutputType | null
    _sum: CustomerAddressSumAggregateOutputType | null
    _min: CustomerAddressMinAggregateOutputType | null
    _max: CustomerAddressMaxAggregateOutputType | null
  }

  export type CustomerAddressAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type CustomerAddressSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type CustomerAddressMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    title: string | null
    firstName: string | null
    lastName: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    phone: string | null
    notes: string | null
    latitude: number | null
    longitude: number | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerAddressMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    title: string | null
    firstName: string | null
    lastName: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    phone: string | null
    notes: string | null
    latitude: number | null
    longitude: number | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerAddressCountAggregateOutputType = {
    id: number
    customerId: number
    title: number
    firstName: number
    lastName: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    postalCode: number
    country: number
    phone: number
    notes: number
    latitude: number
    longitude: number
    isDefault: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAddressAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type CustomerAddressSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type CustomerAddressMinAggregateInputType = {
    id?: true
    customerId?: true
    title?: true
    firstName?: true
    lastName?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    phone?: true
    notes?: true
    latitude?: true
    longitude?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerAddressMaxAggregateInputType = {
    id?: true
    customerId?: true
    title?: true
    firstName?: true
    lastName?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    phone?: true
    notes?: true
    latitude?: true
    longitude?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerAddressCountAggregateInputType = {
    id?: true
    customerId?: true
    title?: true
    firstName?: true
    lastName?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    phone?: true
    notes?: true
    latitude?: true
    longitude?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAddress to aggregate.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerAddresses
    **/
    _count?: true | CustomerAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerAddressMaxAggregateInputType
  }

  export type GetCustomerAddressAggregateType<T extends CustomerAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerAddress[P]>
      : GetScalarType<T[P], AggregateCustomerAddress[P]>
  }




  export type CustomerAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAddressWhereInput
    orderBy?: CustomerAddressOrderByWithAggregationInput | CustomerAddressOrderByWithAggregationInput[]
    by: CustomerAddressScalarFieldEnum[] | CustomerAddressScalarFieldEnum
    having?: CustomerAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerAddressCountAggregateInputType | true
    _avg?: CustomerAddressAvgAggregateInputType
    _sum?: CustomerAddressSumAggregateInputType
    _min?: CustomerAddressMinAggregateInputType
    _max?: CustomerAddressMaxAggregateInputType
  }

  export type CustomerAddressGroupByOutputType = {
    id: string
    customerId: string
    title: string
    firstName: string
    lastName: string
    addressLine1: string
    addressLine2: string | null
    city: string
    state: string | null
    postalCode: string
    country: string
    phone: string | null
    notes: string | null
    latitude: number | null
    longitude: number | null
    isDefault: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerAddressCountAggregateOutputType | null
    _avg: CustomerAddressAvgAggregateOutputType | null
    _sum: CustomerAddressSumAggregateOutputType | null
    _min: CustomerAddressMinAggregateOutputType | null
    _max: CustomerAddressMaxAggregateOutputType | null
  }

  type GetCustomerAddressGroupByPayload<T extends CustomerAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerAddressGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerAddressGroupByOutputType[P]>
        }
      >
    >


  export type CustomerAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    phone?: boolean
    notes?: boolean
    latitude?: boolean
    longitude?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    phone?: boolean
    notes?: boolean
    latitude?: boolean
    longitude?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    phone?: boolean
    notes?: boolean
    latitude?: boolean
    longitude?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectScalar = {
    id?: boolean
    customerId?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    phone?: boolean
    notes?: boolean
    latitude?: boolean
    longitude?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "title" | "firstName" | "lastName" | "addressLine1" | "addressLine2" | "city" | "state" | "postalCode" | "country" | "phone" | "notes" | "latitude" | "longitude" | "isDefault" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["customerAddress"]>
  export type CustomerAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerAddress"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      title: string
      firstName: string
      lastName: string
      addressLine1: string
      addressLine2: string | null
      city: string
      state: string | null
      postalCode: string
      country: string
      phone: string | null
      notes: string | null
      latitude: number | null
      longitude: number | null
      isDefault: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerAddress"]>
    composites: {}
  }

  type CustomerAddressGetPayload<S extends boolean | null | undefined | CustomerAddressDefaultArgs> = $Result.GetResult<Prisma.$CustomerAddressPayload, S>

  type CustomerAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerAddressCountAggregateInputType | true
    }

  export interface CustomerAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerAddress'], meta: { name: 'CustomerAddress' } }
    /**
     * Find zero or one CustomerAddress that matches the filter.
     * @param {CustomerAddressFindUniqueArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerAddressFindUniqueArgs>(args: SelectSubset<T, CustomerAddressFindUniqueArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerAddressFindUniqueOrThrowArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindFirstArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerAddressFindFirstArgs>(args?: SelectSubset<T, CustomerAddressFindFirstArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindFirstOrThrowArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerAddresses
     * const customerAddresses = await prisma.customerAddress.findMany()
     * 
     * // Get first 10 CustomerAddresses
     * const customerAddresses = await prisma.customerAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerAddressFindManyArgs>(args?: SelectSubset<T, CustomerAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerAddress.
     * @param {CustomerAddressCreateArgs} args - Arguments to create a CustomerAddress.
     * @example
     * // Create one CustomerAddress
     * const CustomerAddress = await prisma.customerAddress.create({
     *   data: {
     *     // ... data to create a CustomerAddress
     *   }
     * })
     * 
     */
    create<T extends CustomerAddressCreateArgs>(args: SelectSubset<T, CustomerAddressCreateArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerAddresses.
     * @param {CustomerAddressCreateManyArgs} args - Arguments to create many CustomerAddresses.
     * @example
     * // Create many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerAddressCreateManyArgs>(args?: SelectSubset<T, CustomerAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerAddresses and returns the data saved in the database.
     * @param {CustomerAddressCreateManyAndReturnArgs} args - Arguments to create many CustomerAddresses.
     * @example
     * // Create many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerAddresses and only return the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerAddress.
     * @param {CustomerAddressDeleteArgs} args - Arguments to delete one CustomerAddress.
     * @example
     * // Delete one CustomerAddress
     * const CustomerAddress = await prisma.customerAddress.delete({
     *   where: {
     *     // ... filter to delete one CustomerAddress
     *   }
     * })
     * 
     */
    delete<T extends CustomerAddressDeleteArgs>(args: SelectSubset<T, CustomerAddressDeleteArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerAddress.
     * @param {CustomerAddressUpdateArgs} args - Arguments to update one CustomerAddress.
     * @example
     * // Update one CustomerAddress
     * const customerAddress = await prisma.customerAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerAddressUpdateArgs>(args: SelectSubset<T, CustomerAddressUpdateArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerAddresses.
     * @param {CustomerAddressDeleteManyArgs} args - Arguments to filter CustomerAddresses to delete.
     * @example
     * // Delete a few CustomerAddresses
     * const { count } = await prisma.customerAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerAddressDeleteManyArgs>(args?: SelectSubset<T, CustomerAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerAddressUpdateManyArgs>(args: SelectSubset<T, CustomerAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerAddresses and returns the data updated in the database.
     * @param {CustomerAddressUpdateManyAndReturnArgs} args - Arguments to update many CustomerAddresses.
     * @example
     * // Update many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerAddresses and only return the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerAddress.
     * @param {CustomerAddressUpsertArgs} args - Arguments to update or create a CustomerAddress.
     * @example
     * // Update or create a CustomerAddress
     * const customerAddress = await prisma.customerAddress.upsert({
     *   create: {
     *     // ... data to create a CustomerAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerAddress we want to update
     *   }
     * })
     */
    upsert<T extends CustomerAddressUpsertArgs>(args: SelectSubset<T, CustomerAddressUpsertArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressCountArgs} args - Arguments to filter CustomerAddresses to count.
     * @example
     * // Count the number of CustomerAddresses
     * const count = await prisma.customerAddress.count({
     *   where: {
     *     // ... the filter for the CustomerAddresses we want to count
     *   }
     * })
    **/
    count<T extends CustomerAddressCountArgs>(
      args?: Subset<T, CustomerAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAddressAggregateArgs>(args: Subset<T, CustomerAddressAggregateArgs>): Prisma.PrismaPromise<GetCustomerAddressAggregateType<T>>

    /**
     * Group by CustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerAddressGroupByArgs['orderBy'] }
        : { orderBy?: CustomerAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerAddress model
   */
  readonly fields: CustomerAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerAddress model
   */
  interface CustomerAddressFieldRefs {
    readonly id: FieldRef<"CustomerAddress", 'String'>
    readonly customerId: FieldRef<"CustomerAddress", 'String'>
    readonly title: FieldRef<"CustomerAddress", 'String'>
    readonly firstName: FieldRef<"CustomerAddress", 'String'>
    readonly lastName: FieldRef<"CustomerAddress", 'String'>
    readonly addressLine1: FieldRef<"CustomerAddress", 'String'>
    readonly addressLine2: FieldRef<"CustomerAddress", 'String'>
    readonly city: FieldRef<"CustomerAddress", 'String'>
    readonly state: FieldRef<"CustomerAddress", 'String'>
    readonly postalCode: FieldRef<"CustomerAddress", 'String'>
    readonly country: FieldRef<"CustomerAddress", 'String'>
    readonly phone: FieldRef<"CustomerAddress", 'String'>
    readonly notes: FieldRef<"CustomerAddress", 'String'>
    readonly latitude: FieldRef<"CustomerAddress", 'Float'>
    readonly longitude: FieldRef<"CustomerAddress", 'Float'>
    readonly isDefault: FieldRef<"CustomerAddress", 'Boolean'>
    readonly isActive: FieldRef<"CustomerAddress", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerAddress findUnique
   */
  export type CustomerAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress findUniqueOrThrow
   */
  export type CustomerAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress findFirst
   */
  export type CustomerAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAddresses.
     */
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress findFirstOrThrow
   */
  export type CustomerAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAddresses.
     */
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress findMany
   */
  export type CustomerAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddresses to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress create
   */
  export type CustomerAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerAddress.
     */
    data: XOR<CustomerAddressCreateInput, CustomerAddressUncheckedCreateInput>
  }

  /**
   * CustomerAddress createMany
   */
  export type CustomerAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerAddresses.
     */
    data: CustomerAddressCreateManyInput | CustomerAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerAddress createManyAndReturn
   */
  export type CustomerAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerAddresses.
     */
    data: CustomerAddressCreateManyInput | CustomerAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerAddress update
   */
  export type CustomerAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerAddress.
     */
    data: XOR<CustomerAddressUpdateInput, CustomerAddressUncheckedUpdateInput>
    /**
     * Choose, which CustomerAddress to update.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress updateMany
   */
  export type CustomerAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerAddresses.
     */
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyInput>
    /**
     * Filter which CustomerAddresses to update
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to update.
     */
    limit?: number
  }

  /**
   * CustomerAddress updateManyAndReturn
   */
  export type CustomerAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * The data used to update CustomerAddresses.
     */
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyInput>
    /**
     * Filter which CustomerAddresses to update
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerAddress upsert
   */
  export type CustomerAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerAddress to update in case it exists.
     */
    where: CustomerAddressWhereUniqueInput
    /**
     * In case the CustomerAddress found by the `where` argument doesn't exist, create a new CustomerAddress with this data.
     */
    create: XOR<CustomerAddressCreateInput, CustomerAddressUncheckedCreateInput>
    /**
     * In case the CustomerAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerAddressUpdateInput, CustomerAddressUncheckedUpdateInput>
  }

  /**
   * CustomerAddress delete
   */
  export type CustomerAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter which CustomerAddress to delete.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress deleteMany
   */
  export type CustomerAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAddresses to delete
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to delete.
     */
    limit?: number
  }

  /**
   * CustomerAddress without action
   */
  export type CustomerAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
  }


  /**
   * Model RefundRequest
   */

  export type AggregateRefundRequest = {
    _count: RefundRequestCountAggregateOutputType | null
    _avg: RefundRequestAvgAggregateOutputType | null
    _sum: RefundRequestSumAggregateOutputType | null
    _min: RefundRequestMinAggregateOutputType | null
    _max: RefundRequestMaxAggregateOutputType | null
  }

  export type RefundRequestAvgAggregateOutputType = {
    refundAmount: number | null
    approvedAmount: number | null
  }

  export type RefundRequestSumAggregateOutputType = {
    refundAmount: number | null
    approvedAmount: number | null
  }

  export type RefundRequestMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    customerId: string | null
    businessId: string | null
    status: $Enums.RefundRequestStatus | null
    reason: $Enums.RefundReason | null
    otherReason: string | null
    refundAmount: number | null
    approvedAmount: number | null
    adminNotes: string | null
    customerNotes: string | null
    businessNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    refundedAt: Date | null
  }

  export type RefundRequestMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    customerId: string | null
    businessId: string | null
    status: $Enums.RefundRequestStatus | null
    reason: $Enums.RefundReason | null
    otherReason: string | null
    refundAmount: number | null
    approvedAmount: number | null
    adminNotes: string | null
    customerNotes: string | null
    businessNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    refundedAt: Date | null
  }

  export type RefundRequestCountAggregateOutputType = {
    id: number
    orderId: number
    customerId: number
    businessId: number
    status: number
    reason: number
    otherReason: number
    requestedItems: number
    refundAmount: number
    approvedAmount: number
    evidenceUrls: number
    adminNotes: number
    customerNotes: number
    businessNotes: number
    createdAt: number
    updatedAt: number
    reviewedAt: number
    reviewedBy: number
    refundedAt: number
    _all: number
  }


  export type RefundRequestAvgAggregateInputType = {
    refundAmount?: true
    approvedAmount?: true
  }

  export type RefundRequestSumAggregateInputType = {
    refundAmount?: true
    approvedAmount?: true
  }

  export type RefundRequestMinAggregateInputType = {
    id?: true
    orderId?: true
    customerId?: true
    businessId?: true
    status?: true
    reason?: true
    otherReason?: true
    refundAmount?: true
    approvedAmount?: true
    adminNotes?: true
    customerNotes?: true
    businessNotes?: true
    createdAt?: true
    updatedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    refundedAt?: true
  }

  export type RefundRequestMaxAggregateInputType = {
    id?: true
    orderId?: true
    customerId?: true
    businessId?: true
    status?: true
    reason?: true
    otherReason?: true
    refundAmount?: true
    approvedAmount?: true
    adminNotes?: true
    customerNotes?: true
    businessNotes?: true
    createdAt?: true
    updatedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    refundedAt?: true
  }

  export type RefundRequestCountAggregateInputType = {
    id?: true
    orderId?: true
    customerId?: true
    businessId?: true
    status?: true
    reason?: true
    otherReason?: true
    requestedItems?: true
    refundAmount?: true
    approvedAmount?: true
    evidenceUrls?: true
    adminNotes?: true
    customerNotes?: true
    businessNotes?: true
    createdAt?: true
    updatedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    refundedAt?: true
    _all?: true
  }

  export type RefundRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefundRequest to aggregate.
     */
    where?: RefundRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundRequests to fetch.
     */
    orderBy?: RefundRequestOrderByWithRelationInput | RefundRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefundRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefundRequests
    **/
    _count?: true | RefundRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefundRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefundRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefundRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefundRequestMaxAggregateInputType
  }

  export type GetRefundRequestAggregateType<T extends RefundRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRefundRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefundRequest[P]>
      : GetScalarType<T[P], AggregateRefundRequest[P]>
  }




  export type RefundRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundRequestWhereInput
    orderBy?: RefundRequestOrderByWithAggregationInput | RefundRequestOrderByWithAggregationInput[]
    by: RefundRequestScalarFieldEnum[] | RefundRequestScalarFieldEnum
    having?: RefundRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefundRequestCountAggregateInputType | true
    _avg?: RefundRequestAvgAggregateInputType
    _sum?: RefundRequestSumAggregateInputType
    _min?: RefundRequestMinAggregateInputType
    _max?: RefundRequestMaxAggregateInputType
  }

  export type RefundRequestGroupByOutputType = {
    id: string
    orderId: string
    customerId: string
    businessId: string
    status: $Enums.RefundRequestStatus
    reason: $Enums.RefundReason
    otherReason: string | null
    requestedItems: JsonValue | null
    refundAmount: number | null
    approvedAmount: number | null
    evidenceUrls: string[]
    adminNotes: string | null
    customerNotes: string | null
    businessNotes: string | null
    createdAt: Date
    updatedAt: Date
    reviewedAt: Date | null
    reviewedBy: string | null
    refundedAt: Date | null
    _count: RefundRequestCountAggregateOutputType | null
    _avg: RefundRequestAvgAggregateOutputType | null
    _sum: RefundRequestSumAggregateOutputType | null
    _min: RefundRequestMinAggregateOutputType | null
    _max: RefundRequestMaxAggregateOutputType | null
  }

  type GetRefundRequestGroupByPayload<T extends RefundRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefundRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefundRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefundRequestGroupByOutputType[P]>
            : GetScalarType<T[P], RefundRequestGroupByOutputType[P]>
        }
      >
    >


  export type RefundRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    customerId?: boolean
    businessId?: boolean
    status?: boolean
    reason?: boolean
    otherReason?: boolean
    requestedItems?: boolean
    refundAmount?: boolean
    approvedAmount?: boolean
    evidenceUrls?: boolean
    adminNotes?: boolean
    customerNotes?: boolean
    businessNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    refundedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refundRequest"]>

  export type RefundRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    customerId?: boolean
    businessId?: boolean
    status?: boolean
    reason?: boolean
    otherReason?: boolean
    requestedItems?: boolean
    refundAmount?: boolean
    approvedAmount?: boolean
    evidenceUrls?: boolean
    adminNotes?: boolean
    customerNotes?: boolean
    businessNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    refundedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refundRequest"]>

  export type RefundRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    customerId?: boolean
    businessId?: boolean
    status?: boolean
    reason?: boolean
    otherReason?: boolean
    requestedItems?: boolean
    refundAmount?: boolean
    approvedAmount?: boolean
    evidenceUrls?: boolean
    adminNotes?: boolean
    customerNotes?: boolean
    businessNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    refundedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refundRequest"]>

  export type RefundRequestSelectScalar = {
    id?: boolean
    orderId?: boolean
    customerId?: boolean
    businessId?: boolean
    status?: boolean
    reason?: boolean
    otherReason?: boolean
    requestedItems?: boolean
    refundAmount?: boolean
    approvedAmount?: boolean
    evidenceUrls?: boolean
    adminNotes?: boolean
    customerNotes?: boolean
    businessNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    refundedAt?: boolean
  }

  export type RefundRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "customerId" | "businessId" | "status" | "reason" | "otherReason" | "requestedItems" | "refundAmount" | "approvedAmount" | "evidenceUrls" | "adminNotes" | "customerNotes" | "businessNotes" | "createdAt" | "updatedAt" | "reviewedAt" | "reviewedBy" | "refundedAt", ExtArgs["result"]["refundRequest"]>
  export type RefundRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type RefundRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type RefundRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $RefundRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefundRequest"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
      business: Prisma.$BusinessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      customerId: string
      businessId: string
      status: $Enums.RefundRequestStatus
      reason: $Enums.RefundReason
      otherReason: string | null
      requestedItems: Prisma.JsonValue | null
      refundAmount: number | null
      approvedAmount: number | null
      evidenceUrls: string[]
      adminNotes: string | null
      customerNotes: string | null
      businessNotes: string | null
      createdAt: Date
      updatedAt: Date
      reviewedAt: Date | null
      reviewedBy: string | null
      refundedAt: Date | null
    }, ExtArgs["result"]["refundRequest"]>
    composites: {}
  }

  type RefundRequestGetPayload<S extends boolean | null | undefined | RefundRequestDefaultArgs> = $Result.GetResult<Prisma.$RefundRequestPayload, S>

  type RefundRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefundRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefundRequestCountAggregateInputType | true
    }

  export interface RefundRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefundRequest'], meta: { name: 'RefundRequest' } }
    /**
     * Find zero or one RefundRequest that matches the filter.
     * @param {RefundRequestFindUniqueArgs} args - Arguments to find a RefundRequest
     * @example
     * // Get one RefundRequest
     * const refundRequest = await prisma.refundRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefundRequestFindUniqueArgs>(args: SelectSubset<T, RefundRequestFindUniqueArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefundRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefundRequestFindUniqueOrThrowArgs} args - Arguments to find a RefundRequest
     * @example
     * // Get one RefundRequest
     * const refundRequest = await prisma.refundRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefundRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, RefundRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefundRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestFindFirstArgs} args - Arguments to find a RefundRequest
     * @example
     * // Get one RefundRequest
     * const refundRequest = await prisma.refundRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefundRequestFindFirstArgs>(args?: SelectSubset<T, RefundRequestFindFirstArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefundRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestFindFirstOrThrowArgs} args - Arguments to find a RefundRequest
     * @example
     * // Get one RefundRequest
     * const refundRequest = await prisma.refundRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefundRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, RefundRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefundRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefundRequests
     * const refundRequests = await prisma.refundRequest.findMany()
     * 
     * // Get first 10 RefundRequests
     * const refundRequests = await prisma.refundRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refundRequestWithIdOnly = await prisma.refundRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefundRequestFindManyArgs>(args?: SelectSubset<T, RefundRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefundRequest.
     * @param {RefundRequestCreateArgs} args - Arguments to create a RefundRequest.
     * @example
     * // Create one RefundRequest
     * const RefundRequest = await prisma.refundRequest.create({
     *   data: {
     *     // ... data to create a RefundRequest
     *   }
     * })
     * 
     */
    create<T extends RefundRequestCreateArgs>(args: SelectSubset<T, RefundRequestCreateArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefundRequests.
     * @param {RefundRequestCreateManyArgs} args - Arguments to create many RefundRequests.
     * @example
     * // Create many RefundRequests
     * const refundRequest = await prisma.refundRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefundRequestCreateManyArgs>(args?: SelectSubset<T, RefundRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefundRequests and returns the data saved in the database.
     * @param {RefundRequestCreateManyAndReturnArgs} args - Arguments to create many RefundRequests.
     * @example
     * // Create many RefundRequests
     * const refundRequest = await prisma.refundRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefundRequests and only return the `id`
     * const refundRequestWithIdOnly = await prisma.refundRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefundRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, RefundRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefundRequest.
     * @param {RefundRequestDeleteArgs} args - Arguments to delete one RefundRequest.
     * @example
     * // Delete one RefundRequest
     * const RefundRequest = await prisma.refundRequest.delete({
     *   where: {
     *     // ... filter to delete one RefundRequest
     *   }
     * })
     * 
     */
    delete<T extends RefundRequestDeleteArgs>(args: SelectSubset<T, RefundRequestDeleteArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefundRequest.
     * @param {RefundRequestUpdateArgs} args - Arguments to update one RefundRequest.
     * @example
     * // Update one RefundRequest
     * const refundRequest = await prisma.refundRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefundRequestUpdateArgs>(args: SelectSubset<T, RefundRequestUpdateArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefundRequests.
     * @param {RefundRequestDeleteManyArgs} args - Arguments to filter RefundRequests to delete.
     * @example
     * // Delete a few RefundRequests
     * const { count } = await prisma.refundRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefundRequestDeleteManyArgs>(args?: SelectSubset<T, RefundRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefundRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefundRequests
     * const refundRequest = await prisma.refundRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefundRequestUpdateManyArgs>(args: SelectSubset<T, RefundRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefundRequests and returns the data updated in the database.
     * @param {RefundRequestUpdateManyAndReturnArgs} args - Arguments to update many RefundRequests.
     * @example
     * // Update many RefundRequests
     * const refundRequest = await prisma.refundRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefundRequests and only return the `id`
     * const refundRequestWithIdOnly = await prisma.refundRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefundRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, RefundRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefundRequest.
     * @param {RefundRequestUpsertArgs} args - Arguments to update or create a RefundRequest.
     * @example
     * // Update or create a RefundRequest
     * const refundRequest = await prisma.refundRequest.upsert({
     *   create: {
     *     // ... data to create a RefundRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefundRequest we want to update
     *   }
     * })
     */
    upsert<T extends RefundRequestUpsertArgs>(args: SelectSubset<T, RefundRequestUpsertArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefundRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestCountArgs} args - Arguments to filter RefundRequests to count.
     * @example
     * // Count the number of RefundRequests
     * const count = await prisma.refundRequest.count({
     *   where: {
     *     // ... the filter for the RefundRequests we want to count
     *   }
     * })
    **/
    count<T extends RefundRequestCountArgs>(
      args?: Subset<T, RefundRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefundRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefundRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefundRequestAggregateArgs>(args: Subset<T, RefundRequestAggregateArgs>): Prisma.PrismaPromise<GetRefundRequestAggregateType<T>>

    /**
     * Group by RefundRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefundRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefundRequestGroupByArgs['orderBy'] }
        : { orderBy?: RefundRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefundRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefundRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefundRequest model
   */
  readonly fields: RefundRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefundRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefundRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefundRequest model
   */
  interface RefundRequestFieldRefs {
    readonly id: FieldRef<"RefundRequest", 'String'>
    readonly orderId: FieldRef<"RefundRequest", 'String'>
    readonly customerId: FieldRef<"RefundRequest", 'String'>
    readonly businessId: FieldRef<"RefundRequest", 'String'>
    readonly status: FieldRef<"RefundRequest", 'RefundRequestStatus'>
    readonly reason: FieldRef<"RefundRequest", 'RefundReason'>
    readonly otherReason: FieldRef<"RefundRequest", 'String'>
    readonly requestedItems: FieldRef<"RefundRequest", 'Json'>
    readonly refundAmount: FieldRef<"RefundRequest", 'Float'>
    readonly approvedAmount: FieldRef<"RefundRequest", 'Float'>
    readonly evidenceUrls: FieldRef<"RefundRequest", 'String[]'>
    readonly adminNotes: FieldRef<"RefundRequest", 'String'>
    readonly customerNotes: FieldRef<"RefundRequest", 'String'>
    readonly businessNotes: FieldRef<"RefundRequest", 'String'>
    readonly createdAt: FieldRef<"RefundRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"RefundRequest", 'DateTime'>
    readonly reviewedAt: FieldRef<"RefundRequest", 'DateTime'>
    readonly reviewedBy: FieldRef<"RefundRequest", 'String'>
    readonly refundedAt: FieldRef<"RefundRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefundRequest findUnique
   */
  export type RefundRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequest to fetch.
     */
    where: RefundRequestWhereUniqueInput
  }

  /**
   * RefundRequest findUniqueOrThrow
   */
  export type RefundRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequest to fetch.
     */
    where: RefundRequestWhereUniqueInput
  }

  /**
   * RefundRequest findFirst
   */
  export type RefundRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequest to fetch.
     */
    where?: RefundRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundRequests to fetch.
     */
    orderBy?: RefundRequestOrderByWithRelationInput | RefundRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefundRequests.
     */
    cursor?: RefundRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefundRequests.
     */
    distinct?: RefundRequestScalarFieldEnum | RefundRequestScalarFieldEnum[]
  }

  /**
   * RefundRequest findFirstOrThrow
   */
  export type RefundRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequest to fetch.
     */
    where?: RefundRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundRequests to fetch.
     */
    orderBy?: RefundRequestOrderByWithRelationInput | RefundRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefundRequests.
     */
    cursor?: RefundRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefundRequests.
     */
    distinct?: RefundRequestScalarFieldEnum | RefundRequestScalarFieldEnum[]
  }

  /**
   * RefundRequest findMany
   */
  export type RefundRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequests to fetch.
     */
    where?: RefundRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundRequests to fetch.
     */
    orderBy?: RefundRequestOrderByWithRelationInput | RefundRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefundRequests.
     */
    cursor?: RefundRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundRequests.
     */
    skip?: number
    distinct?: RefundRequestScalarFieldEnum | RefundRequestScalarFieldEnum[]
  }

  /**
   * RefundRequest create
   */
  export type RefundRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a RefundRequest.
     */
    data: XOR<RefundRequestCreateInput, RefundRequestUncheckedCreateInput>
  }

  /**
   * RefundRequest createMany
   */
  export type RefundRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefundRequests.
     */
    data: RefundRequestCreateManyInput | RefundRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefundRequest createManyAndReturn
   */
  export type RefundRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * The data used to create many RefundRequests.
     */
    data: RefundRequestCreateManyInput | RefundRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefundRequest update
   */
  export type RefundRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a RefundRequest.
     */
    data: XOR<RefundRequestUpdateInput, RefundRequestUncheckedUpdateInput>
    /**
     * Choose, which RefundRequest to update.
     */
    where: RefundRequestWhereUniqueInput
  }

  /**
   * RefundRequest updateMany
   */
  export type RefundRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefundRequests.
     */
    data: XOR<RefundRequestUpdateManyMutationInput, RefundRequestUncheckedUpdateManyInput>
    /**
     * Filter which RefundRequests to update
     */
    where?: RefundRequestWhereInput
    /**
     * Limit how many RefundRequests to update.
     */
    limit?: number
  }

  /**
   * RefundRequest updateManyAndReturn
   */
  export type RefundRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * The data used to update RefundRequests.
     */
    data: XOR<RefundRequestUpdateManyMutationInput, RefundRequestUncheckedUpdateManyInput>
    /**
     * Filter which RefundRequests to update
     */
    where?: RefundRequestWhereInput
    /**
     * Limit how many RefundRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefundRequest upsert
   */
  export type RefundRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the RefundRequest to update in case it exists.
     */
    where: RefundRequestWhereUniqueInput
    /**
     * In case the RefundRequest found by the `where` argument doesn't exist, create a new RefundRequest with this data.
     */
    create: XOR<RefundRequestCreateInput, RefundRequestUncheckedCreateInput>
    /**
     * In case the RefundRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefundRequestUpdateInput, RefundRequestUncheckedUpdateInput>
  }

  /**
   * RefundRequest delete
   */
  export type RefundRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * Filter which RefundRequest to delete.
     */
    where: RefundRequestWhereUniqueInput
  }

  /**
   * RefundRequest deleteMany
   */
  export type RefundRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefundRequests to delete
     */
    where?: RefundRequestWhereInput
    /**
     * Limit how many RefundRequests to delete.
     */
    limit?: number
  }

  /**
   * RefundRequest without action
   */
  export type RefundRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
  }


  /**
   * Model CancellationRequest
   */

  export type AggregateCancellationRequest = {
    _count: CancellationRequestCountAggregateOutputType | null
    _avg: CancellationRequestAvgAggregateOutputType | null
    _sum: CancellationRequestSumAggregateOutputType | null
    _min: CancellationRequestMinAggregateOutputType | null
    _max: CancellationRequestMaxAggregateOutputType | null
  }

  export type CancellationRequestAvgAggregateOutputType = {
    cancellationFee: number | null
  }

  export type CancellationRequestSumAggregateOutputType = {
    cancellationFee: number | null
  }

  export type CancellationRequestMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    customerId: string | null
    businessId: string | null
    status: $Enums.CancellationRequestStatus | null
    reason: $Enums.CancellationReason | null
    otherReason: string | null
    cancellationFee: number | null
    autoProcessed: boolean | null
    customerNotes: string | null
    businessNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    cancelledAt: Date | null
  }

  export type CancellationRequestMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    customerId: string | null
    businessId: string | null
    status: $Enums.CancellationRequestStatus | null
    reason: $Enums.CancellationReason | null
    otherReason: string | null
    cancellationFee: number | null
    autoProcessed: boolean | null
    customerNotes: string | null
    businessNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    cancelledAt: Date | null
  }

  export type CancellationRequestCountAggregateOutputType = {
    id: number
    orderId: number
    customerId: number
    businessId: number
    status: number
    reason: number
    otherReason: number
    cancellationFee: number
    autoProcessed: number
    customerNotes: number
    businessNotes: number
    createdAt: number
    updatedAt: number
    reviewedAt: number
    reviewedBy: number
    cancelledAt: number
    _all: number
  }


  export type CancellationRequestAvgAggregateInputType = {
    cancellationFee?: true
  }

  export type CancellationRequestSumAggregateInputType = {
    cancellationFee?: true
  }

  export type CancellationRequestMinAggregateInputType = {
    id?: true
    orderId?: true
    customerId?: true
    businessId?: true
    status?: true
    reason?: true
    otherReason?: true
    cancellationFee?: true
    autoProcessed?: true
    customerNotes?: true
    businessNotes?: true
    createdAt?: true
    updatedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    cancelledAt?: true
  }

  export type CancellationRequestMaxAggregateInputType = {
    id?: true
    orderId?: true
    customerId?: true
    businessId?: true
    status?: true
    reason?: true
    otherReason?: true
    cancellationFee?: true
    autoProcessed?: true
    customerNotes?: true
    businessNotes?: true
    createdAt?: true
    updatedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    cancelledAt?: true
  }

  export type CancellationRequestCountAggregateInputType = {
    id?: true
    orderId?: true
    customerId?: true
    businessId?: true
    status?: true
    reason?: true
    otherReason?: true
    cancellationFee?: true
    autoProcessed?: true
    customerNotes?: true
    businessNotes?: true
    createdAt?: true
    updatedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    cancelledAt?: true
    _all?: true
  }

  export type CancellationRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CancellationRequest to aggregate.
     */
    where?: CancellationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CancellationRequests to fetch.
     */
    orderBy?: CancellationRequestOrderByWithRelationInput | CancellationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CancellationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CancellationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CancellationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CancellationRequests
    **/
    _count?: true | CancellationRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CancellationRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CancellationRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CancellationRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CancellationRequestMaxAggregateInputType
  }

  export type GetCancellationRequestAggregateType<T extends CancellationRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCancellationRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCancellationRequest[P]>
      : GetScalarType<T[P], AggregateCancellationRequest[P]>
  }




  export type CancellationRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CancellationRequestWhereInput
    orderBy?: CancellationRequestOrderByWithAggregationInput | CancellationRequestOrderByWithAggregationInput[]
    by: CancellationRequestScalarFieldEnum[] | CancellationRequestScalarFieldEnum
    having?: CancellationRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CancellationRequestCountAggregateInputType | true
    _avg?: CancellationRequestAvgAggregateInputType
    _sum?: CancellationRequestSumAggregateInputType
    _min?: CancellationRequestMinAggregateInputType
    _max?: CancellationRequestMaxAggregateInputType
  }

  export type CancellationRequestGroupByOutputType = {
    id: string
    orderId: string
    customerId: string
    businessId: string
    status: $Enums.CancellationRequestStatus
    reason: $Enums.CancellationReason
    otherReason: string | null
    cancellationFee: number | null
    autoProcessed: boolean
    customerNotes: string | null
    businessNotes: string | null
    createdAt: Date
    updatedAt: Date
    reviewedAt: Date | null
    reviewedBy: string | null
    cancelledAt: Date | null
    _count: CancellationRequestCountAggregateOutputType | null
    _avg: CancellationRequestAvgAggregateOutputType | null
    _sum: CancellationRequestSumAggregateOutputType | null
    _min: CancellationRequestMinAggregateOutputType | null
    _max: CancellationRequestMaxAggregateOutputType | null
  }

  type GetCancellationRequestGroupByPayload<T extends CancellationRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CancellationRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CancellationRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CancellationRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CancellationRequestGroupByOutputType[P]>
        }
      >
    >


  export type CancellationRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    customerId?: boolean
    businessId?: boolean
    status?: boolean
    reason?: boolean
    otherReason?: boolean
    cancellationFee?: boolean
    autoProcessed?: boolean
    customerNotes?: boolean
    businessNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    cancelledAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cancellationRequest"]>

  export type CancellationRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    customerId?: boolean
    businessId?: boolean
    status?: boolean
    reason?: boolean
    otherReason?: boolean
    cancellationFee?: boolean
    autoProcessed?: boolean
    customerNotes?: boolean
    businessNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    cancelledAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cancellationRequest"]>

  export type CancellationRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    customerId?: boolean
    businessId?: boolean
    status?: boolean
    reason?: boolean
    otherReason?: boolean
    cancellationFee?: boolean
    autoProcessed?: boolean
    customerNotes?: boolean
    businessNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    cancelledAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cancellationRequest"]>

  export type CancellationRequestSelectScalar = {
    id?: boolean
    orderId?: boolean
    customerId?: boolean
    businessId?: boolean
    status?: boolean
    reason?: boolean
    otherReason?: boolean
    cancellationFee?: boolean
    autoProcessed?: boolean
    customerNotes?: boolean
    businessNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    cancelledAt?: boolean
  }

  export type CancellationRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "customerId" | "businessId" | "status" | "reason" | "otherReason" | "cancellationFee" | "autoProcessed" | "customerNotes" | "businessNotes" | "createdAt" | "updatedAt" | "reviewedAt" | "reviewedBy" | "cancelledAt", ExtArgs["result"]["cancellationRequest"]>
  export type CancellationRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type CancellationRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type CancellationRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $CancellationRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CancellationRequest"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
      business: Prisma.$BusinessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      customerId: string
      businessId: string
      status: $Enums.CancellationRequestStatus
      reason: $Enums.CancellationReason
      otherReason: string | null
      cancellationFee: number | null
      autoProcessed: boolean
      customerNotes: string | null
      businessNotes: string | null
      createdAt: Date
      updatedAt: Date
      reviewedAt: Date | null
      reviewedBy: string | null
      cancelledAt: Date | null
    }, ExtArgs["result"]["cancellationRequest"]>
    composites: {}
  }

  type CancellationRequestGetPayload<S extends boolean | null | undefined | CancellationRequestDefaultArgs> = $Result.GetResult<Prisma.$CancellationRequestPayload, S>

  type CancellationRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CancellationRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CancellationRequestCountAggregateInputType | true
    }

  export interface CancellationRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CancellationRequest'], meta: { name: 'CancellationRequest' } }
    /**
     * Find zero or one CancellationRequest that matches the filter.
     * @param {CancellationRequestFindUniqueArgs} args - Arguments to find a CancellationRequest
     * @example
     * // Get one CancellationRequest
     * const cancellationRequest = await prisma.cancellationRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CancellationRequestFindUniqueArgs>(args: SelectSubset<T, CancellationRequestFindUniqueArgs<ExtArgs>>): Prisma__CancellationRequestClient<$Result.GetResult<Prisma.$CancellationRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CancellationRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CancellationRequestFindUniqueOrThrowArgs} args - Arguments to find a CancellationRequest
     * @example
     * // Get one CancellationRequest
     * const cancellationRequest = await prisma.cancellationRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CancellationRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, CancellationRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CancellationRequestClient<$Result.GetResult<Prisma.$CancellationRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CancellationRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationRequestFindFirstArgs} args - Arguments to find a CancellationRequest
     * @example
     * // Get one CancellationRequest
     * const cancellationRequest = await prisma.cancellationRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CancellationRequestFindFirstArgs>(args?: SelectSubset<T, CancellationRequestFindFirstArgs<ExtArgs>>): Prisma__CancellationRequestClient<$Result.GetResult<Prisma.$CancellationRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CancellationRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationRequestFindFirstOrThrowArgs} args - Arguments to find a CancellationRequest
     * @example
     * // Get one CancellationRequest
     * const cancellationRequest = await prisma.cancellationRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CancellationRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, CancellationRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CancellationRequestClient<$Result.GetResult<Prisma.$CancellationRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CancellationRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CancellationRequests
     * const cancellationRequests = await prisma.cancellationRequest.findMany()
     * 
     * // Get first 10 CancellationRequests
     * const cancellationRequests = await prisma.cancellationRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cancellationRequestWithIdOnly = await prisma.cancellationRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CancellationRequestFindManyArgs>(args?: SelectSubset<T, CancellationRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CancellationRequest.
     * @param {CancellationRequestCreateArgs} args - Arguments to create a CancellationRequest.
     * @example
     * // Create one CancellationRequest
     * const CancellationRequest = await prisma.cancellationRequest.create({
     *   data: {
     *     // ... data to create a CancellationRequest
     *   }
     * })
     * 
     */
    create<T extends CancellationRequestCreateArgs>(args: SelectSubset<T, CancellationRequestCreateArgs<ExtArgs>>): Prisma__CancellationRequestClient<$Result.GetResult<Prisma.$CancellationRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CancellationRequests.
     * @param {CancellationRequestCreateManyArgs} args - Arguments to create many CancellationRequests.
     * @example
     * // Create many CancellationRequests
     * const cancellationRequest = await prisma.cancellationRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CancellationRequestCreateManyArgs>(args?: SelectSubset<T, CancellationRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CancellationRequests and returns the data saved in the database.
     * @param {CancellationRequestCreateManyAndReturnArgs} args - Arguments to create many CancellationRequests.
     * @example
     * // Create many CancellationRequests
     * const cancellationRequest = await prisma.cancellationRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CancellationRequests and only return the `id`
     * const cancellationRequestWithIdOnly = await prisma.cancellationRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CancellationRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, CancellationRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CancellationRequest.
     * @param {CancellationRequestDeleteArgs} args - Arguments to delete one CancellationRequest.
     * @example
     * // Delete one CancellationRequest
     * const CancellationRequest = await prisma.cancellationRequest.delete({
     *   where: {
     *     // ... filter to delete one CancellationRequest
     *   }
     * })
     * 
     */
    delete<T extends CancellationRequestDeleteArgs>(args: SelectSubset<T, CancellationRequestDeleteArgs<ExtArgs>>): Prisma__CancellationRequestClient<$Result.GetResult<Prisma.$CancellationRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CancellationRequest.
     * @param {CancellationRequestUpdateArgs} args - Arguments to update one CancellationRequest.
     * @example
     * // Update one CancellationRequest
     * const cancellationRequest = await prisma.cancellationRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CancellationRequestUpdateArgs>(args: SelectSubset<T, CancellationRequestUpdateArgs<ExtArgs>>): Prisma__CancellationRequestClient<$Result.GetResult<Prisma.$CancellationRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CancellationRequests.
     * @param {CancellationRequestDeleteManyArgs} args - Arguments to filter CancellationRequests to delete.
     * @example
     * // Delete a few CancellationRequests
     * const { count } = await prisma.cancellationRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CancellationRequestDeleteManyArgs>(args?: SelectSubset<T, CancellationRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CancellationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CancellationRequests
     * const cancellationRequest = await prisma.cancellationRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CancellationRequestUpdateManyArgs>(args: SelectSubset<T, CancellationRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CancellationRequests and returns the data updated in the database.
     * @param {CancellationRequestUpdateManyAndReturnArgs} args - Arguments to update many CancellationRequests.
     * @example
     * // Update many CancellationRequests
     * const cancellationRequest = await prisma.cancellationRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CancellationRequests and only return the `id`
     * const cancellationRequestWithIdOnly = await prisma.cancellationRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CancellationRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, CancellationRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CancellationRequest.
     * @param {CancellationRequestUpsertArgs} args - Arguments to update or create a CancellationRequest.
     * @example
     * // Update or create a CancellationRequest
     * const cancellationRequest = await prisma.cancellationRequest.upsert({
     *   create: {
     *     // ... data to create a CancellationRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CancellationRequest we want to update
     *   }
     * })
     */
    upsert<T extends CancellationRequestUpsertArgs>(args: SelectSubset<T, CancellationRequestUpsertArgs<ExtArgs>>): Prisma__CancellationRequestClient<$Result.GetResult<Prisma.$CancellationRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CancellationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationRequestCountArgs} args - Arguments to filter CancellationRequests to count.
     * @example
     * // Count the number of CancellationRequests
     * const count = await prisma.cancellationRequest.count({
     *   where: {
     *     // ... the filter for the CancellationRequests we want to count
     *   }
     * })
    **/
    count<T extends CancellationRequestCountArgs>(
      args?: Subset<T, CancellationRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CancellationRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CancellationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CancellationRequestAggregateArgs>(args: Subset<T, CancellationRequestAggregateArgs>): Prisma.PrismaPromise<GetCancellationRequestAggregateType<T>>

    /**
     * Group by CancellationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CancellationRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CancellationRequestGroupByArgs['orderBy'] }
        : { orderBy?: CancellationRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CancellationRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCancellationRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CancellationRequest model
   */
  readonly fields: CancellationRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CancellationRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CancellationRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CancellationRequest model
   */
  interface CancellationRequestFieldRefs {
    readonly id: FieldRef<"CancellationRequest", 'String'>
    readonly orderId: FieldRef<"CancellationRequest", 'String'>
    readonly customerId: FieldRef<"CancellationRequest", 'String'>
    readonly businessId: FieldRef<"CancellationRequest", 'String'>
    readonly status: FieldRef<"CancellationRequest", 'CancellationRequestStatus'>
    readonly reason: FieldRef<"CancellationRequest", 'CancellationReason'>
    readonly otherReason: FieldRef<"CancellationRequest", 'String'>
    readonly cancellationFee: FieldRef<"CancellationRequest", 'Float'>
    readonly autoProcessed: FieldRef<"CancellationRequest", 'Boolean'>
    readonly customerNotes: FieldRef<"CancellationRequest", 'String'>
    readonly businessNotes: FieldRef<"CancellationRequest", 'String'>
    readonly createdAt: FieldRef<"CancellationRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"CancellationRequest", 'DateTime'>
    readonly reviewedAt: FieldRef<"CancellationRequest", 'DateTime'>
    readonly reviewedBy: FieldRef<"CancellationRequest", 'String'>
    readonly cancelledAt: FieldRef<"CancellationRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CancellationRequest findUnique
   */
  export type CancellationRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestInclude<ExtArgs> | null
    /**
     * Filter, which CancellationRequest to fetch.
     */
    where: CancellationRequestWhereUniqueInput
  }

  /**
   * CancellationRequest findUniqueOrThrow
   */
  export type CancellationRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestInclude<ExtArgs> | null
    /**
     * Filter, which CancellationRequest to fetch.
     */
    where: CancellationRequestWhereUniqueInput
  }

  /**
   * CancellationRequest findFirst
   */
  export type CancellationRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestInclude<ExtArgs> | null
    /**
     * Filter, which CancellationRequest to fetch.
     */
    where?: CancellationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CancellationRequests to fetch.
     */
    orderBy?: CancellationRequestOrderByWithRelationInput | CancellationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CancellationRequests.
     */
    cursor?: CancellationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CancellationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CancellationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CancellationRequests.
     */
    distinct?: CancellationRequestScalarFieldEnum | CancellationRequestScalarFieldEnum[]
  }

  /**
   * CancellationRequest findFirstOrThrow
   */
  export type CancellationRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestInclude<ExtArgs> | null
    /**
     * Filter, which CancellationRequest to fetch.
     */
    where?: CancellationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CancellationRequests to fetch.
     */
    orderBy?: CancellationRequestOrderByWithRelationInput | CancellationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CancellationRequests.
     */
    cursor?: CancellationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CancellationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CancellationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CancellationRequests.
     */
    distinct?: CancellationRequestScalarFieldEnum | CancellationRequestScalarFieldEnum[]
  }

  /**
   * CancellationRequest findMany
   */
  export type CancellationRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestInclude<ExtArgs> | null
    /**
     * Filter, which CancellationRequests to fetch.
     */
    where?: CancellationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CancellationRequests to fetch.
     */
    orderBy?: CancellationRequestOrderByWithRelationInput | CancellationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CancellationRequests.
     */
    cursor?: CancellationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CancellationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CancellationRequests.
     */
    skip?: number
    distinct?: CancellationRequestScalarFieldEnum | CancellationRequestScalarFieldEnum[]
  }

  /**
   * CancellationRequest create
   */
  export type CancellationRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a CancellationRequest.
     */
    data: XOR<CancellationRequestCreateInput, CancellationRequestUncheckedCreateInput>
  }

  /**
   * CancellationRequest createMany
   */
  export type CancellationRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CancellationRequests.
     */
    data: CancellationRequestCreateManyInput | CancellationRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CancellationRequest createManyAndReturn
   */
  export type CancellationRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * The data used to create many CancellationRequests.
     */
    data: CancellationRequestCreateManyInput | CancellationRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CancellationRequest update
   */
  export type CancellationRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a CancellationRequest.
     */
    data: XOR<CancellationRequestUpdateInput, CancellationRequestUncheckedUpdateInput>
    /**
     * Choose, which CancellationRequest to update.
     */
    where: CancellationRequestWhereUniqueInput
  }

  /**
   * CancellationRequest updateMany
   */
  export type CancellationRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CancellationRequests.
     */
    data: XOR<CancellationRequestUpdateManyMutationInput, CancellationRequestUncheckedUpdateManyInput>
    /**
     * Filter which CancellationRequests to update
     */
    where?: CancellationRequestWhereInput
    /**
     * Limit how many CancellationRequests to update.
     */
    limit?: number
  }

  /**
   * CancellationRequest updateManyAndReturn
   */
  export type CancellationRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * The data used to update CancellationRequests.
     */
    data: XOR<CancellationRequestUpdateManyMutationInput, CancellationRequestUncheckedUpdateManyInput>
    /**
     * Filter which CancellationRequests to update
     */
    where?: CancellationRequestWhereInput
    /**
     * Limit how many CancellationRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CancellationRequest upsert
   */
  export type CancellationRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the CancellationRequest to update in case it exists.
     */
    where: CancellationRequestWhereUniqueInput
    /**
     * In case the CancellationRequest found by the `where` argument doesn't exist, create a new CancellationRequest with this data.
     */
    create: XOR<CancellationRequestCreateInput, CancellationRequestUncheckedCreateInput>
    /**
     * In case the CancellationRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CancellationRequestUpdateInput, CancellationRequestUncheckedUpdateInput>
  }

  /**
   * CancellationRequest delete
   */
  export type CancellationRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestInclude<ExtArgs> | null
    /**
     * Filter which CancellationRequest to delete.
     */
    where: CancellationRequestWhereUniqueInput
  }

  /**
   * CancellationRequest deleteMany
   */
  export type CancellationRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CancellationRequests to delete
     */
    where?: CancellationRequestWhereInput
    /**
     * Limit how many CancellationRequests to delete.
     */
    limit?: number
  }

  /**
   * CancellationRequest without action
   */
  export type CancellationRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationRequest
     */
    select?: CancellationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationRequest
     */
    omit?: CancellationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationRequestInclude<ExtArgs> | null
  }


  /**
   * Model RefundPolicy
   */

  export type AggregateRefundPolicy = {
    _count: RefundPolicyCountAggregateOutputType | null
    _avg: RefundPolicyAvgAggregateOutputType | null
    _sum: RefundPolicySumAggregateOutputType | null
    _min: RefundPolicyMinAggregateOutputType | null
    _max: RefundPolicyMaxAggregateOutputType | null
  }

  export type RefundPolicyAvgAggregateOutputType = {
    autoApproveTimeline: number | null
    timeLimit: number | null
  }

  export type RefundPolicySumAggregateOutputType = {
    autoApproveTimeline: number | null
    timeLimit: number | null
  }

  export type RefundPolicyMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    description: string | null
    autoApproveTimeline: number | null
    timeLimit: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefundPolicyMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    description: string | null
    autoApproveTimeline: number | null
    timeLimit: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefundPolicyCountAggregateOutputType = {
    id: number
    businessId: number
    name: number
    description: number
    autoApproveTimeline: number
    timeLimit: number
    orderStatusRules: number
    productRules: number
    cancellationFees: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RefundPolicyAvgAggregateInputType = {
    autoApproveTimeline?: true
    timeLimit?: true
  }

  export type RefundPolicySumAggregateInputType = {
    autoApproveTimeline?: true
    timeLimit?: true
  }

  export type RefundPolicyMinAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    autoApproveTimeline?: true
    timeLimit?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefundPolicyMaxAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    autoApproveTimeline?: true
    timeLimit?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefundPolicyCountAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    description?: true
    autoApproveTimeline?: true
    timeLimit?: true
    orderStatusRules?: true
    productRules?: true
    cancellationFees?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RefundPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefundPolicy to aggregate.
     */
    where?: RefundPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundPolicies to fetch.
     */
    orderBy?: RefundPolicyOrderByWithRelationInput | RefundPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefundPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefundPolicies
    **/
    _count?: true | RefundPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefundPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefundPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefundPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefundPolicyMaxAggregateInputType
  }

  export type GetRefundPolicyAggregateType<T extends RefundPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateRefundPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefundPolicy[P]>
      : GetScalarType<T[P], AggregateRefundPolicy[P]>
  }




  export type RefundPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundPolicyWhereInput
    orderBy?: RefundPolicyOrderByWithAggregationInput | RefundPolicyOrderByWithAggregationInput[]
    by: RefundPolicyScalarFieldEnum[] | RefundPolicyScalarFieldEnum
    having?: RefundPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefundPolicyCountAggregateInputType | true
    _avg?: RefundPolicyAvgAggregateInputType
    _sum?: RefundPolicySumAggregateInputType
    _min?: RefundPolicyMinAggregateInputType
    _max?: RefundPolicyMaxAggregateInputType
  }

  export type RefundPolicyGroupByOutputType = {
    id: string
    businessId: string
    name: string
    description: string | null
    autoApproveTimeline: number | null
    timeLimit: number | null
    orderStatusRules: JsonValue | null
    productRules: JsonValue | null
    cancellationFees: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RefundPolicyCountAggregateOutputType | null
    _avg: RefundPolicyAvgAggregateOutputType | null
    _sum: RefundPolicySumAggregateOutputType | null
    _min: RefundPolicyMinAggregateOutputType | null
    _max: RefundPolicyMaxAggregateOutputType | null
  }

  type GetRefundPolicyGroupByPayload<T extends RefundPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefundPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefundPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefundPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], RefundPolicyGroupByOutputType[P]>
        }
      >
    >


  export type RefundPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    autoApproveTimeline?: boolean
    timeLimit?: boolean
    orderStatusRules?: boolean
    productRules?: boolean
    cancellationFees?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refundPolicy"]>

  export type RefundPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    autoApproveTimeline?: boolean
    timeLimit?: boolean
    orderStatusRules?: boolean
    productRules?: boolean
    cancellationFees?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refundPolicy"]>

  export type RefundPolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    autoApproveTimeline?: boolean
    timeLimit?: boolean
    orderStatusRules?: boolean
    productRules?: boolean
    cancellationFees?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refundPolicy"]>

  export type RefundPolicySelectScalar = {
    id?: boolean
    businessId?: boolean
    name?: boolean
    description?: boolean
    autoApproveTimeline?: boolean
    timeLimit?: boolean
    orderStatusRules?: boolean
    productRules?: boolean
    cancellationFees?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RefundPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessId" | "name" | "description" | "autoApproveTimeline" | "timeLimit" | "orderStatusRules" | "productRules" | "cancellationFees" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["refundPolicy"]>
  export type RefundPolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type RefundPolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type RefundPolicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $RefundPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefundPolicy"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      name: string
      description: string | null
      autoApproveTimeline: number | null
      timeLimit: number | null
      orderStatusRules: Prisma.JsonValue | null
      productRules: Prisma.JsonValue | null
      cancellationFees: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["refundPolicy"]>
    composites: {}
  }

  type RefundPolicyGetPayload<S extends boolean | null | undefined | RefundPolicyDefaultArgs> = $Result.GetResult<Prisma.$RefundPolicyPayload, S>

  type RefundPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefundPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefundPolicyCountAggregateInputType | true
    }

  export interface RefundPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefundPolicy'], meta: { name: 'RefundPolicy' } }
    /**
     * Find zero or one RefundPolicy that matches the filter.
     * @param {RefundPolicyFindUniqueArgs} args - Arguments to find a RefundPolicy
     * @example
     * // Get one RefundPolicy
     * const refundPolicy = await prisma.refundPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefundPolicyFindUniqueArgs>(args: SelectSubset<T, RefundPolicyFindUniqueArgs<ExtArgs>>): Prisma__RefundPolicyClient<$Result.GetResult<Prisma.$RefundPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefundPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefundPolicyFindUniqueOrThrowArgs} args - Arguments to find a RefundPolicy
     * @example
     * // Get one RefundPolicy
     * const refundPolicy = await prisma.refundPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefundPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, RefundPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefundPolicyClient<$Result.GetResult<Prisma.$RefundPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefundPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundPolicyFindFirstArgs} args - Arguments to find a RefundPolicy
     * @example
     * // Get one RefundPolicy
     * const refundPolicy = await prisma.refundPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefundPolicyFindFirstArgs>(args?: SelectSubset<T, RefundPolicyFindFirstArgs<ExtArgs>>): Prisma__RefundPolicyClient<$Result.GetResult<Prisma.$RefundPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefundPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundPolicyFindFirstOrThrowArgs} args - Arguments to find a RefundPolicy
     * @example
     * // Get one RefundPolicy
     * const refundPolicy = await prisma.refundPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefundPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, RefundPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefundPolicyClient<$Result.GetResult<Prisma.$RefundPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefundPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefundPolicies
     * const refundPolicies = await prisma.refundPolicy.findMany()
     * 
     * // Get first 10 RefundPolicies
     * const refundPolicies = await prisma.refundPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refundPolicyWithIdOnly = await prisma.refundPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefundPolicyFindManyArgs>(args?: SelectSubset<T, RefundPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefundPolicy.
     * @param {RefundPolicyCreateArgs} args - Arguments to create a RefundPolicy.
     * @example
     * // Create one RefundPolicy
     * const RefundPolicy = await prisma.refundPolicy.create({
     *   data: {
     *     // ... data to create a RefundPolicy
     *   }
     * })
     * 
     */
    create<T extends RefundPolicyCreateArgs>(args: SelectSubset<T, RefundPolicyCreateArgs<ExtArgs>>): Prisma__RefundPolicyClient<$Result.GetResult<Prisma.$RefundPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefundPolicies.
     * @param {RefundPolicyCreateManyArgs} args - Arguments to create many RefundPolicies.
     * @example
     * // Create many RefundPolicies
     * const refundPolicy = await prisma.refundPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefundPolicyCreateManyArgs>(args?: SelectSubset<T, RefundPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefundPolicies and returns the data saved in the database.
     * @param {RefundPolicyCreateManyAndReturnArgs} args - Arguments to create many RefundPolicies.
     * @example
     * // Create many RefundPolicies
     * const refundPolicy = await prisma.refundPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefundPolicies and only return the `id`
     * const refundPolicyWithIdOnly = await prisma.refundPolicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefundPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, RefundPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefundPolicy.
     * @param {RefundPolicyDeleteArgs} args - Arguments to delete one RefundPolicy.
     * @example
     * // Delete one RefundPolicy
     * const RefundPolicy = await prisma.refundPolicy.delete({
     *   where: {
     *     // ... filter to delete one RefundPolicy
     *   }
     * })
     * 
     */
    delete<T extends RefundPolicyDeleteArgs>(args: SelectSubset<T, RefundPolicyDeleteArgs<ExtArgs>>): Prisma__RefundPolicyClient<$Result.GetResult<Prisma.$RefundPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefundPolicy.
     * @param {RefundPolicyUpdateArgs} args - Arguments to update one RefundPolicy.
     * @example
     * // Update one RefundPolicy
     * const refundPolicy = await prisma.refundPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefundPolicyUpdateArgs>(args: SelectSubset<T, RefundPolicyUpdateArgs<ExtArgs>>): Prisma__RefundPolicyClient<$Result.GetResult<Prisma.$RefundPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefundPolicies.
     * @param {RefundPolicyDeleteManyArgs} args - Arguments to filter RefundPolicies to delete.
     * @example
     * // Delete a few RefundPolicies
     * const { count } = await prisma.refundPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefundPolicyDeleteManyArgs>(args?: SelectSubset<T, RefundPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefundPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefundPolicies
     * const refundPolicy = await prisma.refundPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefundPolicyUpdateManyArgs>(args: SelectSubset<T, RefundPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefundPolicies and returns the data updated in the database.
     * @param {RefundPolicyUpdateManyAndReturnArgs} args - Arguments to update many RefundPolicies.
     * @example
     * // Update many RefundPolicies
     * const refundPolicy = await prisma.refundPolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefundPolicies and only return the `id`
     * const refundPolicyWithIdOnly = await prisma.refundPolicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefundPolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, RefundPolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefundPolicy.
     * @param {RefundPolicyUpsertArgs} args - Arguments to update or create a RefundPolicy.
     * @example
     * // Update or create a RefundPolicy
     * const refundPolicy = await prisma.refundPolicy.upsert({
     *   create: {
     *     // ... data to create a RefundPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefundPolicy we want to update
     *   }
     * })
     */
    upsert<T extends RefundPolicyUpsertArgs>(args: SelectSubset<T, RefundPolicyUpsertArgs<ExtArgs>>): Prisma__RefundPolicyClient<$Result.GetResult<Prisma.$RefundPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefundPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundPolicyCountArgs} args - Arguments to filter RefundPolicies to count.
     * @example
     * // Count the number of RefundPolicies
     * const count = await prisma.refundPolicy.count({
     *   where: {
     *     // ... the filter for the RefundPolicies we want to count
     *   }
     * })
    **/
    count<T extends RefundPolicyCountArgs>(
      args?: Subset<T, RefundPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefundPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefundPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefundPolicyAggregateArgs>(args: Subset<T, RefundPolicyAggregateArgs>): Prisma.PrismaPromise<GetRefundPolicyAggregateType<T>>

    /**
     * Group by RefundPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefundPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefundPolicyGroupByArgs['orderBy'] }
        : { orderBy?: RefundPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefundPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefundPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefundPolicy model
   */
  readonly fields: RefundPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefundPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefundPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefundPolicy model
   */
  interface RefundPolicyFieldRefs {
    readonly id: FieldRef<"RefundPolicy", 'String'>
    readonly businessId: FieldRef<"RefundPolicy", 'String'>
    readonly name: FieldRef<"RefundPolicy", 'String'>
    readonly description: FieldRef<"RefundPolicy", 'String'>
    readonly autoApproveTimeline: FieldRef<"RefundPolicy", 'Int'>
    readonly timeLimit: FieldRef<"RefundPolicy", 'Int'>
    readonly orderStatusRules: FieldRef<"RefundPolicy", 'Json'>
    readonly productRules: FieldRef<"RefundPolicy", 'Json'>
    readonly cancellationFees: FieldRef<"RefundPolicy", 'Json'>
    readonly isActive: FieldRef<"RefundPolicy", 'Boolean'>
    readonly createdAt: FieldRef<"RefundPolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"RefundPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefundPolicy findUnique
   */
  export type RefundPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundPolicy
     */
    select?: RefundPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundPolicy
     */
    omit?: RefundPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundPolicyInclude<ExtArgs> | null
    /**
     * Filter, which RefundPolicy to fetch.
     */
    where: RefundPolicyWhereUniqueInput
  }

  /**
   * RefundPolicy findUniqueOrThrow
   */
  export type RefundPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundPolicy
     */
    select?: RefundPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundPolicy
     */
    omit?: RefundPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundPolicyInclude<ExtArgs> | null
    /**
     * Filter, which RefundPolicy to fetch.
     */
    where: RefundPolicyWhereUniqueInput
  }

  /**
   * RefundPolicy findFirst
   */
  export type RefundPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundPolicy
     */
    select?: RefundPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundPolicy
     */
    omit?: RefundPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundPolicyInclude<ExtArgs> | null
    /**
     * Filter, which RefundPolicy to fetch.
     */
    where?: RefundPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundPolicies to fetch.
     */
    orderBy?: RefundPolicyOrderByWithRelationInput | RefundPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefundPolicies.
     */
    cursor?: RefundPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefundPolicies.
     */
    distinct?: RefundPolicyScalarFieldEnum | RefundPolicyScalarFieldEnum[]
  }

  /**
   * RefundPolicy findFirstOrThrow
   */
  export type RefundPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundPolicy
     */
    select?: RefundPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundPolicy
     */
    omit?: RefundPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundPolicyInclude<ExtArgs> | null
    /**
     * Filter, which RefundPolicy to fetch.
     */
    where?: RefundPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundPolicies to fetch.
     */
    orderBy?: RefundPolicyOrderByWithRelationInput | RefundPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefundPolicies.
     */
    cursor?: RefundPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefundPolicies.
     */
    distinct?: RefundPolicyScalarFieldEnum | RefundPolicyScalarFieldEnum[]
  }

  /**
   * RefundPolicy findMany
   */
  export type RefundPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundPolicy
     */
    select?: RefundPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundPolicy
     */
    omit?: RefundPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundPolicyInclude<ExtArgs> | null
    /**
     * Filter, which RefundPolicies to fetch.
     */
    where?: RefundPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundPolicies to fetch.
     */
    orderBy?: RefundPolicyOrderByWithRelationInput | RefundPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefundPolicies.
     */
    cursor?: RefundPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundPolicies.
     */
    skip?: number
    distinct?: RefundPolicyScalarFieldEnum | RefundPolicyScalarFieldEnum[]
  }

  /**
   * RefundPolicy create
   */
  export type RefundPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundPolicy
     */
    select?: RefundPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundPolicy
     */
    omit?: RefundPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundPolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a RefundPolicy.
     */
    data: XOR<RefundPolicyCreateInput, RefundPolicyUncheckedCreateInput>
  }

  /**
   * RefundPolicy createMany
   */
  export type RefundPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefundPolicies.
     */
    data: RefundPolicyCreateManyInput | RefundPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefundPolicy createManyAndReturn
   */
  export type RefundPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundPolicy
     */
    select?: RefundPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefundPolicy
     */
    omit?: RefundPolicyOmit<ExtArgs> | null
    /**
     * The data used to create many RefundPolicies.
     */
    data: RefundPolicyCreateManyInput | RefundPolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundPolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefundPolicy update
   */
  export type RefundPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundPolicy
     */
    select?: RefundPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundPolicy
     */
    omit?: RefundPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundPolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a RefundPolicy.
     */
    data: XOR<RefundPolicyUpdateInput, RefundPolicyUncheckedUpdateInput>
    /**
     * Choose, which RefundPolicy to update.
     */
    where: RefundPolicyWhereUniqueInput
  }

  /**
   * RefundPolicy updateMany
   */
  export type RefundPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefundPolicies.
     */
    data: XOR<RefundPolicyUpdateManyMutationInput, RefundPolicyUncheckedUpdateManyInput>
    /**
     * Filter which RefundPolicies to update
     */
    where?: RefundPolicyWhereInput
    /**
     * Limit how many RefundPolicies to update.
     */
    limit?: number
  }

  /**
   * RefundPolicy updateManyAndReturn
   */
  export type RefundPolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundPolicy
     */
    select?: RefundPolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefundPolicy
     */
    omit?: RefundPolicyOmit<ExtArgs> | null
    /**
     * The data used to update RefundPolicies.
     */
    data: XOR<RefundPolicyUpdateManyMutationInput, RefundPolicyUncheckedUpdateManyInput>
    /**
     * Filter which RefundPolicies to update
     */
    where?: RefundPolicyWhereInput
    /**
     * Limit how many RefundPolicies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundPolicyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefundPolicy upsert
   */
  export type RefundPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundPolicy
     */
    select?: RefundPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundPolicy
     */
    omit?: RefundPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundPolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the RefundPolicy to update in case it exists.
     */
    where: RefundPolicyWhereUniqueInput
    /**
     * In case the RefundPolicy found by the `where` argument doesn't exist, create a new RefundPolicy with this data.
     */
    create: XOR<RefundPolicyCreateInput, RefundPolicyUncheckedCreateInput>
    /**
     * In case the RefundPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefundPolicyUpdateInput, RefundPolicyUncheckedUpdateInput>
  }

  /**
   * RefundPolicy delete
   */
  export type RefundPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundPolicy
     */
    select?: RefundPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundPolicy
     */
    omit?: RefundPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundPolicyInclude<ExtArgs> | null
    /**
     * Filter which RefundPolicy to delete.
     */
    where: RefundPolicyWhereUniqueInput
  }

  /**
   * RefundPolicy deleteMany
   */
  export type RefundPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefundPolicies to delete
     */
    where?: RefundPolicyWhereInput
    /**
     * Limit how many RefundPolicies to delete.
     */
    limit?: number
  }

  /**
   * RefundPolicy without action
   */
  export type RefundPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundPolicy
     */
    select?: RefundPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundPolicy
     */
    omit?: RefundPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundPolicyInclude<ExtArgs> | null
  }


  /**
   * Model SavedPaymentMethod
   */

  export type AggregateSavedPaymentMethod = {
    _count: SavedPaymentMethodCountAggregateOutputType | null
    _avg: SavedPaymentMethodAvgAggregateOutputType | null
    _sum: SavedPaymentMethodSumAggregateOutputType | null
    _min: SavedPaymentMethodMinAggregateOutputType | null
    _max: SavedPaymentMethodMaxAggregateOutputType | null
  }

  export type SavedPaymentMethodAvgAggregateOutputType = {
    cardExpMonth: number | null
    cardExpYear: number | null
  }

  export type SavedPaymentMethodSumAggregateOutputType = {
    cardExpMonth: number | null
    cardExpYear: number | null
  }

  export type SavedPaymentMethodMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    type: $Enums.PaymentMethod | null
    provider: $Enums.PaymentProvider | null
    isDefault: boolean | null
    nickName: string | null
    cardBrand: $Enums.CardBrand | null
    cardLast4: string | null
    cardExpMonth: number | null
    cardExpYear: number | null
    cardHolderName: string | null
    bankName: string | null
    bankAccountLast4: string | null
    externalId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SavedPaymentMethodMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    type: $Enums.PaymentMethod | null
    provider: $Enums.PaymentProvider | null
    isDefault: boolean | null
    nickName: string | null
    cardBrand: $Enums.CardBrand | null
    cardLast4: string | null
    cardExpMonth: number | null
    cardExpYear: number | null
    cardHolderName: string | null
    bankName: string | null
    bankAccountLast4: string | null
    externalId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SavedPaymentMethodCountAggregateOutputType = {
    id: number
    customerId: number
    type: number
    provider: number
    isDefault: number
    nickName: number
    cardBrand: number
    cardLast4: number
    cardExpMonth: number
    cardExpYear: number
    cardHolderName: number
    bankName: number
    bankAccountLast4: number
    externalId: number
    isActive: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SavedPaymentMethodAvgAggregateInputType = {
    cardExpMonth?: true
    cardExpYear?: true
  }

  export type SavedPaymentMethodSumAggregateInputType = {
    cardExpMonth?: true
    cardExpYear?: true
  }

  export type SavedPaymentMethodMinAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    provider?: true
    isDefault?: true
    nickName?: true
    cardBrand?: true
    cardLast4?: true
    cardExpMonth?: true
    cardExpYear?: true
    cardHolderName?: true
    bankName?: true
    bankAccountLast4?: true
    externalId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SavedPaymentMethodMaxAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    provider?: true
    isDefault?: true
    nickName?: true
    cardBrand?: true
    cardLast4?: true
    cardExpMonth?: true
    cardExpYear?: true
    cardHolderName?: true
    bankName?: true
    bankAccountLast4?: true
    externalId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SavedPaymentMethodCountAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    provider?: true
    isDefault?: true
    nickName?: true
    cardBrand?: true
    cardLast4?: true
    cardExpMonth?: true
    cardExpYear?: true
    cardHolderName?: true
    bankName?: true
    bankAccountLast4?: true
    externalId?: true
    isActive?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SavedPaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedPaymentMethod to aggregate.
     */
    where?: SavedPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedPaymentMethods to fetch.
     */
    orderBy?: SavedPaymentMethodOrderByWithRelationInput | SavedPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedPaymentMethods
    **/
    _count?: true | SavedPaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SavedPaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SavedPaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedPaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedPaymentMethodMaxAggregateInputType
  }

  export type GetSavedPaymentMethodAggregateType<T extends SavedPaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedPaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedPaymentMethod[P]>
      : GetScalarType<T[P], AggregateSavedPaymentMethod[P]>
  }




  export type SavedPaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedPaymentMethodWhereInput
    orderBy?: SavedPaymentMethodOrderByWithAggregationInput | SavedPaymentMethodOrderByWithAggregationInput[]
    by: SavedPaymentMethodScalarFieldEnum[] | SavedPaymentMethodScalarFieldEnum
    having?: SavedPaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedPaymentMethodCountAggregateInputType | true
    _avg?: SavedPaymentMethodAvgAggregateInputType
    _sum?: SavedPaymentMethodSumAggregateInputType
    _min?: SavedPaymentMethodMinAggregateInputType
    _max?: SavedPaymentMethodMaxAggregateInputType
  }

  export type SavedPaymentMethodGroupByOutputType = {
    id: string
    customerId: string
    type: $Enums.PaymentMethod
    provider: $Enums.PaymentProvider
    isDefault: boolean
    nickName: string | null
    cardBrand: $Enums.CardBrand | null
    cardLast4: string | null
    cardExpMonth: number | null
    cardExpYear: number | null
    cardHolderName: string | null
    bankName: string | null
    bankAccountLast4: string | null
    externalId: string | null
    isActive: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SavedPaymentMethodCountAggregateOutputType | null
    _avg: SavedPaymentMethodAvgAggregateOutputType | null
    _sum: SavedPaymentMethodSumAggregateOutputType | null
    _min: SavedPaymentMethodMinAggregateOutputType | null
    _max: SavedPaymentMethodMaxAggregateOutputType | null
  }

  type GetSavedPaymentMethodGroupByPayload<T extends SavedPaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedPaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedPaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedPaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], SavedPaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type SavedPaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    type?: boolean
    provider?: boolean
    isDefault?: boolean
    nickName?: boolean
    cardBrand?: boolean
    cardLast4?: boolean
    cardExpMonth?: boolean
    cardExpYear?: boolean
    cardHolderName?: boolean
    bankName?: boolean
    bankAccountLast4?: boolean
    externalId?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    subscriptions?: boolean | SavedPaymentMethod$subscriptionsArgs<ExtArgs>
    _count?: boolean | SavedPaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedPaymentMethod"]>

  export type SavedPaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    type?: boolean
    provider?: boolean
    isDefault?: boolean
    nickName?: boolean
    cardBrand?: boolean
    cardLast4?: boolean
    cardExpMonth?: boolean
    cardExpYear?: boolean
    cardHolderName?: boolean
    bankName?: boolean
    bankAccountLast4?: boolean
    externalId?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedPaymentMethod"]>

  export type SavedPaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    type?: boolean
    provider?: boolean
    isDefault?: boolean
    nickName?: boolean
    cardBrand?: boolean
    cardLast4?: boolean
    cardExpMonth?: boolean
    cardExpYear?: boolean
    cardHolderName?: boolean
    bankName?: boolean
    bankAccountLast4?: boolean
    externalId?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedPaymentMethod"]>

  export type SavedPaymentMethodSelectScalar = {
    id?: boolean
    customerId?: boolean
    type?: boolean
    provider?: boolean
    isDefault?: boolean
    nickName?: boolean
    cardBrand?: boolean
    cardLast4?: boolean
    cardExpMonth?: boolean
    cardExpYear?: boolean
    cardHolderName?: boolean
    bankName?: boolean
    bankAccountLast4?: boolean
    externalId?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SavedPaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "type" | "provider" | "isDefault" | "nickName" | "cardBrand" | "cardLast4" | "cardExpMonth" | "cardExpYear" | "cardHolderName" | "bankName" | "bankAccountLast4" | "externalId" | "isActive" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["savedPaymentMethod"]>
  export type SavedPaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    subscriptions?: boolean | SavedPaymentMethod$subscriptionsArgs<ExtArgs>
    _count?: boolean | SavedPaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SavedPaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type SavedPaymentMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $SavedPaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedPaymentMethod"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      type: $Enums.PaymentMethod
      provider: $Enums.PaymentProvider
      isDefault: boolean
      nickName: string | null
      cardBrand: $Enums.CardBrand | null
      cardLast4: string | null
      cardExpMonth: number | null
      cardExpYear: number | null
      cardHolderName: string | null
      bankName: string | null
      bankAccountLast4: string | null
      externalId: string | null
      isActive: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["savedPaymentMethod"]>
    composites: {}
  }

  type SavedPaymentMethodGetPayload<S extends boolean | null | undefined | SavedPaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$SavedPaymentMethodPayload, S>

  type SavedPaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SavedPaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SavedPaymentMethodCountAggregateInputType | true
    }

  export interface SavedPaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedPaymentMethod'], meta: { name: 'SavedPaymentMethod' } }
    /**
     * Find zero or one SavedPaymentMethod that matches the filter.
     * @param {SavedPaymentMethodFindUniqueArgs} args - Arguments to find a SavedPaymentMethod
     * @example
     * // Get one SavedPaymentMethod
     * const savedPaymentMethod = await prisma.savedPaymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedPaymentMethodFindUniqueArgs>(args: SelectSubset<T, SavedPaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__SavedPaymentMethodClient<$Result.GetResult<Prisma.$SavedPaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SavedPaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SavedPaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a SavedPaymentMethod
     * @example
     * // Get one SavedPaymentMethod
     * const savedPaymentMethod = await prisma.savedPaymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedPaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedPaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedPaymentMethodClient<$Result.GetResult<Prisma.$SavedPaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedPaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPaymentMethodFindFirstArgs} args - Arguments to find a SavedPaymentMethod
     * @example
     * // Get one SavedPaymentMethod
     * const savedPaymentMethod = await prisma.savedPaymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedPaymentMethodFindFirstArgs>(args?: SelectSubset<T, SavedPaymentMethodFindFirstArgs<ExtArgs>>): Prisma__SavedPaymentMethodClient<$Result.GetResult<Prisma.$SavedPaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedPaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPaymentMethodFindFirstOrThrowArgs} args - Arguments to find a SavedPaymentMethod
     * @example
     * // Get one SavedPaymentMethod
     * const savedPaymentMethod = await prisma.savedPaymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedPaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedPaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedPaymentMethodClient<$Result.GetResult<Prisma.$SavedPaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SavedPaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedPaymentMethods
     * const savedPaymentMethods = await prisma.savedPaymentMethod.findMany()
     * 
     * // Get first 10 SavedPaymentMethods
     * const savedPaymentMethods = await prisma.savedPaymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedPaymentMethodWithIdOnly = await prisma.savedPaymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedPaymentMethodFindManyArgs>(args?: SelectSubset<T, SavedPaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedPaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SavedPaymentMethod.
     * @param {SavedPaymentMethodCreateArgs} args - Arguments to create a SavedPaymentMethod.
     * @example
     * // Create one SavedPaymentMethod
     * const SavedPaymentMethod = await prisma.savedPaymentMethod.create({
     *   data: {
     *     // ... data to create a SavedPaymentMethod
     *   }
     * })
     * 
     */
    create<T extends SavedPaymentMethodCreateArgs>(args: SelectSubset<T, SavedPaymentMethodCreateArgs<ExtArgs>>): Prisma__SavedPaymentMethodClient<$Result.GetResult<Prisma.$SavedPaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SavedPaymentMethods.
     * @param {SavedPaymentMethodCreateManyArgs} args - Arguments to create many SavedPaymentMethods.
     * @example
     * // Create many SavedPaymentMethods
     * const savedPaymentMethod = await prisma.savedPaymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedPaymentMethodCreateManyArgs>(args?: SelectSubset<T, SavedPaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedPaymentMethods and returns the data saved in the database.
     * @param {SavedPaymentMethodCreateManyAndReturnArgs} args - Arguments to create many SavedPaymentMethods.
     * @example
     * // Create many SavedPaymentMethods
     * const savedPaymentMethod = await prisma.savedPaymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedPaymentMethods and only return the `id`
     * const savedPaymentMethodWithIdOnly = await prisma.savedPaymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedPaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedPaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedPaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SavedPaymentMethod.
     * @param {SavedPaymentMethodDeleteArgs} args - Arguments to delete one SavedPaymentMethod.
     * @example
     * // Delete one SavedPaymentMethod
     * const SavedPaymentMethod = await prisma.savedPaymentMethod.delete({
     *   where: {
     *     // ... filter to delete one SavedPaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends SavedPaymentMethodDeleteArgs>(args: SelectSubset<T, SavedPaymentMethodDeleteArgs<ExtArgs>>): Prisma__SavedPaymentMethodClient<$Result.GetResult<Prisma.$SavedPaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SavedPaymentMethod.
     * @param {SavedPaymentMethodUpdateArgs} args - Arguments to update one SavedPaymentMethod.
     * @example
     * // Update one SavedPaymentMethod
     * const savedPaymentMethod = await prisma.savedPaymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedPaymentMethodUpdateArgs>(args: SelectSubset<T, SavedPaymentMethodUpdateArgs<ExtArgs>>): Prisma__SavedPaymentMethodClient<$Result.GetResult<Prisma.$SavedPaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SavedPaymentMethods.
     * @param {SavedPaymentMethodDeleteManyArgs} args - Arguments to filter SavedPaymentMethods to delete.
     * @example
     * // Delete a few SavedPaymentMethods
     * const { count } = await prisma.savedPaymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedPaymentMethodDeleteManyArgs>(args?: SelectSubset<T, SavedPaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedPaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedPaymentMethods
     * const savedPaymentMethod = await prisma.savedPaymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedPaymentMethodUpdateManyArgs>(args: SelectSubset<T, SavedPaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedPaymentMethods and returns the data updated in the database.
     * @param {SavedPaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many SavedPaymentMethods.
     * @example
     * // Update many SavedPaymentMethods
     * const savedPaymentMethod = await prisma.savedPaymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SavedPaymentMethods and only return the `id`
     * const savedPaymentMethodWithIdOnly = await prisma.savedPaymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SavedPaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, SavedPaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedPaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SavedPaymentMethod.
     * @param {SavedPaymentMethodUpsertArgs} args - Arguments to update or create a SavedPaymentMethod.
     * @example
     * // Update or create a SavedPaymentMethod
     * const savedPaymentMethod = await prisma.savedPaymentMethod.upsert({
     *   create: {
     *     // ... data to create a SavedPaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedPaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends SavedPaymentMethodUpsertArgs>(args: SelectSubset<T, SavedPaymentMethodUpsertArgs<ExtArgs>>): Prisma__SavedPaymentMethodClient<$Result.GetResult<Prisma.$SavedPaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SavedPaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPaymentMethodCountArgs} args - Arguments to filter SavedPaymentMethods to count.
     * @example
     * // Count the number of SavedPaymentMethods
     * const count = await prisma.savedPaymentMethod.count({
     *   where: {
     *     // ... the filter for the SavedPaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends SavedPaymentMethodCountArgs>(
      args?: Subset<T, SavedPaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedPaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedPaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedPaymentMethodAggregateArgs>(args: Subset<T, SavedPaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetSavedPaymentMethodAggregateType<T>>

    /**
     * Group by SavedPaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedPaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedPaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: SavedPaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedPaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedPaymentMethod model
   */
  readonly fields: SavedPaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedPaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedPaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscriptions<T extends SavedPaymentMethod$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SavedPaymentMethod$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedPaymentMethod model
   */
  interface SavedPaymentMethodFieldRefs {
    readonly id: FieldRef<"SavedPaymentMethod", 'String'>
    readonly customerId: FieldRef<"SavedPaymentMethod", 'String'>
    readonly type: FieldRef<"SavedPaymentMethod", 'PaymentMethod'>
    readonly provider: FieldRef<"SavedPaymentMethod", 'PaymentProvider'>
    readonly isDefault: FieldRef<"SavedPaymentMethod", 'Boolean'>
    readonly nickName: FieldRef<"SavedPaymentMethod", 'String'>
    readonly cardBrand: FieldRef<"SavedPaymentMethod", 'CardBrand'>
    readonly cardLast4: FieldRef<"SavedPaymentMethod", 'String'>
    readonly cardExpMonth: FieldRef<"SavedPaymentMethod", 'Int'>
    readonly cardExpYear: FieldRef<"SavedPaymentMethod", 'Int'>
    readonly cardHolderName: FieldRef<"SavedPaymentMethod", 'String'>
    readonly bankName: FieldRef<"SavedPaymentMethod", 'String'>
    readonly bankAccountLast4: FieldRef<"SavedPaymentMethod", 'String'>
    readonly externalId: FieldRef<"SavedPaymentMethod", 'String'>
    readonly isActive: FieldRef<"SavedPaymentMethod", 'Boolean'>
    readonly metadata: FieldRef<"SavedPaymentMethod", 'Json'>
    readonly createdAt: FieldRef<"SavedPaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"SavedPaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavedPaymentMethod findUnique
   */
  export type SavedPaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethod
     */
    select?: SavedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedPaymentMethod
     */
    omit?: SavedPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which SavedPaymentMethod to fetch.
     */
    where: SavedPaymentMethodWhereUniqueInput
  }

  /**
   * SavedPaymentMethod findUniqueOrThrow
   */
  export type SavedPaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethod
     */
    select?: SavedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedPaymentMethod
     */
    omit?: SavedPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which SavedPaymentMethod to fetch.
     */
    where: SavedPaymentMethodWhereUniqueInput
  }

  /**
   * SavedPaymentMethod findFirst
   */
  export type SavedPaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethod
     */
    select?: SavedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedPaymentMethod
     */
    omit?: SavedPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which SavedPaymentMethod to fetch.
     */
    where?: SavedPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedPaymentMethods to fetch.
     */
    orderBy?: SavedPaymentMethodOrderByWithRelationInput | SavedPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedPaymentMethods.
     */
    cursor?: SavedPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedPaymentMethods.
     */
    distinct?: SavedPaymentMethodScalarFieldEnum | SavedPaymentMethodScalarFieldEnum[]
  }

  /**
   * SavedPaymentMethod findFirstOrThrow
   */
  export type SavedPaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethod
     */
    select?: SavedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedPaymentMethod
     */
    omit?: SavedPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which SavedPaymentMethod to fetch.
     */
    where?: SavedPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedPaymentMethods to fetch.
     */
    orderBy?: SavedPaymentMethodOrderByWithRelationInput | SavedPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedPaymentMethods.
     */
    cursor?: SavedPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedPaymentMethods.
     */
    distinct?: SavedPaymentMethodScalarFieldEnum | SavedPaymentMethodScalarFieldEnum[]
  }

  /**
   * SavedPaymentMethod findMany
   */
  export type SavedPaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethod
     */
    select?: SavedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedPaymentMethod
     */
    omit?: SavedPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which SavedPaymentMethods to fetch.
     */
    where?: SavedPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedPaymentMethods to fetch.
     */
    orderBy?: SavedPaymentMethodOrderByWithRelationInput | SavedPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedPaymentMethods.
     */
    cursor?: SavedPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedPaymentMethods.
     */
    skip?: number
    distinct?: SavedPaymentMethodScalarFieldEnum | SavedPaymentMethodScalarFieldEnum[]
  }

  /**
   * SavedPaymentMethod create
   */
  export type SavedPaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethod
     */
    select?: SavedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedPaymentMethod
     */
    omit?: SavedPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedPaymentMethod.
     */
    data: XOR<SavedPaymentMethodCreateInput, SavedPaymentMethodUncheckedCreateInput>
  }

  /**
   * SavedPaymentMethod createMany
   */
  export type SavedPaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedPaymentMethods.
     */
    data: SavedPaymentMethodCreateManyInput | SavedPaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedPaymentMethod createManyAndReturn
   */
  export type SavedPaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethod
     */
    select?: SavedPaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedPaymentMethod
     */
    omit?: SavedPaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many SavedPaymentMethods.
     */
    data: SavedPaymentMethodCreateManyInput | SavedPaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPaymentMethodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedPaymentMethod update
   */
  export type SavedPaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethod
     */
    select?: SavedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedPaymentMethod
     */
    omit?: SavedPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedPaymentMethod.
     */
    data: XOR<SavedPaymentMethodUpdateInput, SavedPaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which SavedPaymentMethod to update.
     */
    where: SavedPaymentMethodWhereUniqueInput
  }

  /**
   * SavedPaymentMethod updateMany
   */
  export type SavedPaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedPaymentMethods.
     */
    data: XOR<SavedPaymentMethodUpdateManyMutationInput, SavedPaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which SavedPaymentMethods to update
     */
    where?: SavedPaymentMethodWhereInput
    /**
     * Limit how many SavedPaymentMethods to update.
     */
    limit?: number
  }

  /**
   * SavedPaymentMethod updateManyAndReturn
   */
  export type SavedPaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethod
     */
    select?: SavedPaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedPaymentMethod
     */
    omit?: SavedPaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update SavedPaymentMethods.
     */
    data: XOR<SavedPaymentMethodUpdateManyMutationInput, SavedPaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which SavedPaymentMethods to update
     */
    where?: SavedPaymentMethodWhereInput
    /**
     * Limit how many SavedPaymentMethods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPaymentMethodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedPaymentMethod upsert
   */
  export type SavedPaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethod
     */
    select?: SavedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedPaymentMethod
     */
    omit?: SavedPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedPaymentMethod to update in case it exists.
     */
    where: SavedPaymentMethodWhereUniqueInput
    /**
     * In case the SavedPaymentMethod found by the `where` argument doesn't exist, create a new SavedPaymentMethod with this data.
     */
    create: XOR<SavedPaymentMethodCreateInput, SavedPaymentMethodUncheckedCreateInput>
    /**
     * In case the SavedPaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedPaymentMethodUpdateInput, SavedPaymentMethodUncheckedUpdateInput>
  }

  /**
   * SavedPaymentMethod delete
   */
  export type SavedPaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethod
     */
    select?: SavedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedPaymentMethod
     */
    omit?: SavedPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which SavedPaymentMethod to delete.
     */
    where: SavedPaymentMethodWhereUniqueInput
  }

  /**
   * SavedPaymentMethod deleteMany
   */
  export type SavedPaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedPaymentMethods to delete
     */
    where?: SavedPaymentMethodWhereInput
    /**
     * Limit how many SavedPaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * SavedPaymentMethod.subscriptions
   */
  export type SavedPaymentMethod$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * SavedPaymentMethod without action
   */
  export type SavedPaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethod
     */
    select?: SavedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedPaymentMethod
     */
    omit?: SavedPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionPlan
   */

  export type AggregateSubscriptionPlan = {
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  export type SubscriptionPlanAvgAggregateOutputType = {
    price: number | null
    intervalCount: number | null
    trialPeriodDays: number | null
  }

  export type SubscriptionPlanSumAggregateOutputType = {
    price: number | null
    intervalCount: number | null
    trialPeriodDays: number | null
  }

  export type SubscriptionPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    currency: string | null
    interval: $Enums.SubscriptionInterval | null
    intervalCount: number | null
    trialPeriodDays: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    businessId: string | null
  }

  export type SubscriptionPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    currency: string | null
    interval: $Enums.SubscriptionInterval | null
    intervalCount: number | null
    trialPeriodDays: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    businessId: string | null
  }

  export type SubscriptionPlanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    currency: number
    interval: number
    intervalCount: number
    trialPeriodDays: number
    features: number
    isActive: number
    createdAt: number
    updatedAt: number
    businessId: number
    _all: number
  }


  export type SubscriptionPlanAvgAggregateInputType = {
    price?: true
    intervalCount?: true
    trialPeriodDays?: true
  }

  export type SubscriptionPlanSumAggregateInputType = {
    price?: true
    intervalCount?: true
    trialPeriodDays?: true
  }

  export type SubscriptionPlanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    intervalCount?: true
    trialPeriodDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    businessId?: true
  }

  export type SubscriptionPlanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    intervalCount?: true
    trialPeriodDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    businessId?: true
  }

  export type SubscriptionPlanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    intervalCount?: true
    trialPeriodDays?: true
    features?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    businessId?: true
    _all?: true
  }

  export type SubscriptionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlan to aggregate.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPlans
    **/
    _count?: true | SubscriptionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type GetSubscriptionPlanAggregateType<T extends SubscriptionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
      : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
  }




  export type SubscriptionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlanWhereInput
    orderBy?: SubscriptionPlanOrderByWithAggregationInput | SubscriptionPlanOrderByWithAggregationInput[]
    by: SubscriptionPlanScalarFieldEnum[] | SubscriptionPlanScalarFieldEnum
    having?: SubscriptionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPlanCountAggregateInputType | true
    _avg?: SubscriptionPlanAvgAggregateInputType
    _sum?: SubscriptionPlanSumAggregateInputType
    _min?: SubscriptionPlanMinAggregateInputType
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type SubscriptionPlanGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: number
    currency: string
    interval: $Enums.SubscriptionInterval
    intervalCount: number
    trialPeriodDays: number | null
    features: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    businessId: string | null
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  type GetSubscriptionPlanGroupByPayload<T extends SubscriptionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialPeriodDays?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessId?: boolean
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    business?: boolean | SubscriptionPlan$businessArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialPeriodDays?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessId?: boolean
    business?: boolean | SubscriptionPlan$businessArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialPeriodDays?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessId?: boolean
    business?: boolean | SubscriptionPlan$businessArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialPeriodDays?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessId?: boolean
  }

  export type SubscriptionPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "currency" | "interval" | "intervalCount" | "trialPeriodDays" | "features" | "isActive" | "createdAt" | "updatedAt" | "businessId", ExtArgs["result"]["subscriptionPlan"]>
  export type SubscriptionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    business?: boolean | SubscriptionPlan$businessArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | SubscriptionPlan$businessArgs<ExtArgs>
  }
  export type SubscriptionPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | SubscriptionPlan$businessArgs<ExtArgs>
  }

  export type $SubscriptionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPlan"
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      business: Prisma.$BusinessPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: number
      currency: string
      interval: $Enums.SubscriptionInterval
      intervalCount: number
      trialPeriodDays: number | null
      features: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      businessId: string | null
    }, ExtArgs["result"]["subscriptionPlan"]>
    composites: {}
  }

  type SubscriptionPlanGetPayload<S extends boolean | null | undefined | SubscriptionPlanDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPlanPayload, S>

  type SubscriptionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionPlanCountAggregateInputType | true
    }

  export interface SubscriptionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPlan'], meta: { name: 'SubscriptionPlan' } }
    /**
     * Find zero or one SubscriptionPlan that matches the filter.
     * @param {SubscriptionPlanFindUniqueArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPlanFindUniqueArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionPlanFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPlanFindFirstArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
     * 
     * // Get first 10 SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPlanFindManyArgs>(args?: SelectSubset<T, SubscriptionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionPlan.
     * @param {SubscriptionPlanCreateArgs} args - Arguments to create a SubscriptionPlan.
     * @example
     * // Create one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.create({
     *   data: {
     *     // ... data to create a SubscriptionPlan
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPlanCreateArgs>(args: SelectSubset<T, SubscriptionPlanCreateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionPlans.
     * @param {SubscriptionPlanCreateManyArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPlanCreateManyArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPlans and returns the data saved in the database.
     * @param {SubscriptionPlanCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionPlan.
     * @param {SubscriptionPlanDeleteArgs} args - Arguments to delete one SubscriptionPlan.
     * @example
     * // Delete one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPlan
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPlanDeleteArgs>(args: SelectSubset<T, SubscriptionPlanDeleteArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionPlan.
     * @param {SubscriptionPlanUpdateArgs} args - Arguments to update one SubscriptionPlan.
     * @example
     * // Update one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPlanUpdateArgs>(args: SelectSubset<T, SubscriptionPlanUpdateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionPlans.
     * @param {SubscriptionPlanDeleteManyArgs} args - Arguments to filter SubscriptionPlans to delete.
     * @example
     * // Delete a few SubscriptionPlans
     * const { count } = await prisma.subscriptionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPlanDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPlanUpdateManyArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans and returns the data updated in the database.
     * @param {SubscriptionPlanUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionPlans.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionPlan.
     * @param {SubscriptionPlanUpsertArgs} args - Arguments to update or create a SubscriptionPlan.
     * @example
     * // Update or create a SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPlan we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPlanUpsertArgs>(args: SelectSubset<T, SubscriptionPlanUpsertArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanCountArgs} args - Arguments to filter SubscriptionPlans to count.
     * @example
     * // Count the number of SubscriptionPlans
     * const count = await prisma.subscriptionPlan.count({
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPlanCountArgs>(
      args?: Subset<T, SubscriptionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPlanAggregateArgs>(args: Subset<T, SubscriptionPlanAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPlanAggregateType<T>>

    /**
     * Group by SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPlanGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPlan model
   */
  readonly fields: SubscriptionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends SubscriptionPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    business<T extends SubscriptionPlan$businessArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPlan model
   */
  interface SubscriptionPlanFieldRefs {
    readonly id: FieldRef<"SubscriptionPlan", 'String'>
    readonly name: FieldRef<"SubscriptionPlan", 'String'>
    readonly description: FieldRef<"SubscriptionPlan", 'String'>
    readonly price: FieldRef<"SubscriptionPlan", 'Float'>
    readonly currency: FieldRef<"SubscriptionPlan", 'String'>
    readonly interval: FieldRef<"SubscriptionPlan", 'SubscriptionInterval'>
    readonly intervalCount: FieldRef<"SubscriptionPlan", 'Int'>
    readonly trialPeriodDays: FieldRef<"SubscriptionPlan", 'Int'>
    readonly features: FieldRef<"SubscriptionPlan", 'Json'>
    readonly isActive: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly createdAt: FieldRef<"SubscriptionPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionPlan", 'DateTime'>
    readonly businessId: FieldRef<"SubscriptionPlan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPlan findUnique
   */
  export type SubscriptionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findUniqueOrThrow
   */
  export type SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findFirst
   */
  export type SubscriptionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findFirstOrThrow
   */
  export type SubscriptionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findMany
   */
  export type SubscriptionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan create
   */
  export type SubscriptionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
  }

  /**
   * SubscriptionPlan createMany
   */
  export type SubscriptionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan createManyAndReturn
   */
  export type SubscriptionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionPlan update
   */
  export type SubscriptionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPlan to update.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan updateMany
   */
  export type SubscriptionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to update.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan updateManyAndReturn
   */
  export type SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionPlan upsert
   */
  export type SubscriptionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPlan to update in case it exists.
     */
    where: SubscriptionPlanWhereUniqueInput
    /**
     * In case the SubscriptionPlan found by the `where` argument doesn't exist, create a new SubscriptionPlan with this data.
     */
    create: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
    /**
     * In case the SubscriptionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
  }

  /**
   * SubscriptionPlan delete
   */
  export type SubscriptionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPlan to delete.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan deleteMany
   */
  export type SubscriptionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlans to delete
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan.subscriptions
   */
  export type SubscriptionPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan.business
   */
  export type SubscriptionPlan$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * SubscriptionPlan without action
   */
  export type SubscriptionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    quantity: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    quantity: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    planId: string | null
    status: $Enums.SubscriptionStatus | null
    startDate: Date | null
    endDate: Date | null
    trialEndDate: Date | null
    canceledAt: Date | null
    pausedAt: Date | null
    resumeAt: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    nextBillingDate: Date | null
    savedPaymentMethodId: string | null
    quantity: number | null
    autoRenew: boolean | null
    cancelAtPeriodEnd: boolean | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    businessId: string | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    planId: string | null
    status: $Enums.SubscriptionStatus | null
    startDate: Date | null
    endDate: Date | null
    trialEndDate: Date | null
    canceledAt: Date | null
    pausedAt: Date | null
    resumeAt: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    nextBillingDate: Date | null
    savedPaymentMethodId: string | null
    quantity: number | null
    autoRenew: boolean | null
    cancelAtPeriodEnd: boolean | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    businessId: string | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    customerId: number
    planId: number
    status: number
    startDate: number
    endDate: number
    trialEndDate: number
    canceledAt: number
    pausedAt: number
    resumeAt: number
    currentPeriodStart: number
    currentPeriodEnd: number
    nextBillingDate: number
    savedPaymentMethodId: number
    quantity: number
    autoRenew: number
    cancelAtPeriodEnd: number
    metadata: number
    externalId: number
    createdAt: number
    updatedAt: number
    businessId: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    quantity?: true
  }

  export type SubscriptionSumAggregateInputType = {
    quantity?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    customerId?: true
    planId?: true
    status?: true
    startDate?: true
    endDate?: true
    trialEndDate?: true
    canceledAt?: true
    pausedAt?: true
    resumeAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    nextBillingDate?: true
    savedPaymentMethodId?: true
    quantity?: true
    autoRenew?: true
    cancelAtPeriodEnd?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    businessId?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    customerId?: true
    planId?: true
    status?: true
    startDate?: true
    endDate?: true
    trialEndDate?: true
    canceledAt?: true
    pausedAt?: true
    resumeAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    nextBillingDate?: true
    savedPaymentMethodId?: true
    quantity?: true
    autoRenew?: true
    cancelAtPeriodEnd?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    businessId?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    customerId?: true
    planId?: true
    status?: true
    startDate?: true
    endDate?: true
    trialEndDate?: true
    canceledAt?: true
    pausedAt?: true
    resumeAt?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    nextBillingDate?: true
    savedPaymentMethodId?: true
    quantity?: true
    autoRenew?: true
    cancelAtPeriodEnd?: true
    metadata?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    businessId?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    customerId: string
    planId: string
    status: $Enums.SubscriptionStatus
    startDate: Date
    endDate: Date | null
    trialEndDate: Date | null
    canceledAt: Date | null
    pausedAt: Date | null
    resumeAt: Date | null
    currentPeriodStart: Date
    currentPeriodEnd: Date
    nextBillingDate: Date | null
    savedPaymentMethodId: string | null
    quantity: number
    autoRenew: boolean
    cancelAtPeriodEnd: boolean
    metadata: JsonValue | null
    externalId: string | null
    createdAt: Date
    updatedAt: Date
    businessId: string | null
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    planId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    trialEndDate?: boolean
    canceledAt?: boolean
    pausedAt?: boolean
    resumeAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    nextBillingDate?: boolean
    savedPaymentMethodId?: boolean
    quantity?: boolean
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    savedPaymentMethod?: boolean | Subscription$savedPaymentMethodArgs<ExtArgs>
    recurringPayments?: boolean | Subscription$recurringPaymentsArgs<ExtArgs>
    business?: boolean | Subscription$businessArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    planId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    trialEndDate?: boolean
    canceledAt?: boolean
    pausedAt?: boolean
    resumeAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    nextBillingDate?: boolean
    savedPaymentMethodId?: boolean
    quantity?: boolean
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    savedPaymentMethod?: boolean | Subscription$savedPaymentMethodArgs<ExtArgs>
    business?: boolean | Subscription$businessArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    planId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    trialEndDate?: boolean
    canceledAt?: boolean
    pausedAt?: boolean
    resumeAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    nextBillingDate?: boolean
    savedPaymentMethodId?: boolean
    quantity?: boolean
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    savedPaymentMethod?: boolean | Subscription$savedPaymentMethodArgs<ExtArgs>
    business?: boolean | Subscription$businessArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    customerId?: boolean
    planId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    trialEndDate?: boolean
    canceledAt?: boolean
    pausedAt?: boolean
    resumeAt?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    nextBillingDate?: boolean
    savedPaymentMethodId?: boolean
    quantity?: boolean
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessId?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "planId" | "status" | "startDate" | "endDate" | "trialEndDate" | "canceledAt" | "pausedAt" | "resumeAt" | "currentPeriodStart" | "currentPeriodEnd" | "nextBillingDate" | "savedPaymentMethodId" | "quantity" | "autoRenew" | "cancelAtPeriodEnd" | "metadata" | "externalId" | "createdAt" | "updatedAt" | "businessId", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    savedPaymentMethod?: boolean | Subscription$savedPaymentMethodArgs<ExtArgs>
    recurringPayments?: boolean | Subscription$recurringPaymentsArgs<ExtArgs>
    business?: boolean | Subscription$businessArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    savedPaymentMethod?: boolean | Subscription$savedPaymentMethodArgs<ExtArgs>
    business?: boolean | Subscription$businessArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    savedPaymentMethod?: boolean | Subscription$savedPaymentMethodArgs<ExtArgs>
    business?: boolean | Subscription$businessArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
      savedPaymentMethod: Prisma.$SavedPaymentMethodPayload<ExtArgs> | null
      recurringPayments: Prisma.$RecurringPaymentPayload<ExtArgs>[]
      business: Prisma.$BusinessPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      planId: string
      status: $Enums.SubscriptionStatus
      startDate: Date
      endDate: Date | null
      trialEndDate: Date | null
      canceledAt: Date | null
      pausedAt: Date | null
      resumeAt: Date | null
      currentPeriodStart: Date
      currentPeriodEnd: Date
      nextBillingDate: Date | null
      savedPaymentMethodId: string | null
      quantity: number
      autoRenew: boolean
      cancelAtPeriodEnd: boolean
      metadata: Prisma.JsonValue | null
      externalId: string | null
      createdAt: Date
      updatedAt: Date
      businessId: string | null
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    savedPaymentMethod<T extends Subscription$savedPaymentMethodArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$savedPaymentMethodArgs<ExtArgs>>): Prisma__SavedPaymentMethodClient<$Result.GetResult<Prisma.$SavedPaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recurringPayments<T extends Subscription$recurringPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$recurringPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    business<T extends Subscription$businessArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly customerId: FieldRef<"Subscription", 'String'>
    readonly planId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly startDate: FieldRef<"Subscription", 'DateTime'>
    readonly endDate: FieldRef<"Subscription", 'DateTime'>
    readonly trialEndDate: FieldRef<"Subscription", 'DateTime'>
    readonly canceledAt: FieldRef<"Subscription", 'DateTime'>
    readonly pausedAt: FieldRef<"Subscription", 'DateTime'>
    readonly resumeAt: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly nextBillingDate: FieldRef<"Subscription", 'DateTime'>
    readonly savedPaymentMethodId: FieldRef<"Subscription", 'String'>
    readonly quantity: FieldRef<"Subscription", 'Int'>
    readonly autoRenew: FieldRef<"Subscription", 'Boolean'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly metadata: FieldRef<"Subscription", 'Json'>
    readonly externalId: FieldRef<"Subscription", 'String'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
    readonly businessId: FieldRef<"Subscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.savedPaymentMethod
   */
  export type Subscription$savedPaymentMethodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedPaymentMethod
     */
    select?: SavedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedPaymentMethod
     */
    omit?: SavedPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPaymentMethodInclude<ExtArgs> | null
    where?: SavedPaymentMethodWhereInput
  }

  /**
   * Subscription.recurringPayments
   */
  export type Subscription$recurringPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPayment
     */
    select?: RecurringPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPayment
     */
    omit?: RecurringPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPaymentInclude<ExtArgs> | null
    where?: RecurringPaymentWhereInput
    orderBy?: RecurringPaymentOrderByWithRelationInput | RecurringPaymentOrderByWithRelationInput[]
    cursor?: RecurringPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringPaymentScalarFieldEnum | RecurringPaymentScalarFieldEnum[]
  }

  /**
   * Subscription.business
   */
  export type Subscription$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model RecurringPayment
   */

  export type AggregateRecurringPayment = {
    _count: RecurringPaymentCountAggregateOutputType | null
    _avg: RecurringPaymentAvgAggregateOutputType | null
    _sum: RecurringPaymentSumAggregateOutputType | null
    _min: RecurringPaymentMinAggregateOutputType | null
    _max: RecurringPaymentMaxAggregateOutputType | null
  }

  export type RecurringPaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type RecurringPaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type RecurringPaymentMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    amount: number | null
    status: $Enums.PaymentStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentDate: Date | null
    dueDate: Date | null
    description: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringPaymentMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    amount: number | null
    status: $Enums.PaymentStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentDate: Date | null
    dueDate: Date | null
    description: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringPaymentCountAggregateOutputType = {
    id: number
    subscriptionId: number
    amount: number
    status: number
    paymentMethod: number
    paymentDate: number
    dueDate: number
    description: number
    externalId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecurringPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type RecurringPaymentSumAggregateInputType = {
    amount?: true
  }

  export type RecurringPaymentMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    paymentDate?: true
    dueDate?: true
    description?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringPaymentMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    paymentDate?: true
    dueDate?: true
    description?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringPaymentCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    paymentDate?: true
    dueDate?: true
    description?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecurringPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringPayment to aggregate.
     */
    where?: RecurringPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringPayments to fetch.
     */
    orderBy?: RecurringPaymentOrderByWithRelationInput | RecurringPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringPayments
    **/
    _count?: true | RecurringPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurringPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurringPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringPaymentMaxAggregateInputType
  }

  export type GetRecurringPaymentAggregateType<T extends RecurringPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringPayment[P]>
      : GetScalarType<T[P], AggregateRecurringPayment[P]>
  }




  export type RecurringPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringPaymentWhereInput
    orderBy?: RecurringPaymentOrderByWithAggregationInput | RecurringPaymentOrderByWithAggregationInput[]
    by: RecurringPaymentScalarFieldEnum[] | RecurringPaymentScalarFieldEnum
    having?: RecurringPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringPaymentCountAggregateInputType | true
    _avg?: RecurringPaymentAvgAggregateInputType
    _sum?: RecurringPaymentSumAggregateInputType
    _min?: RecurringPaymentMinAggregateInputType
    _max?: RecurringPaymentMaxAggregateInputType
  }

  export type RecurringPaymentGroupByOutputType = {
    id: string
    subscriptionId: string
    amount: number
    status: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date
    dueDate: Date
    description: string | null
    externalId: string | null
    createdAt: Date
    updatedAt: Date
    _count: RecurringPaymentCountAggregateOutputType | null
    _avg: RecurringPaymentAvgAggregateOutputType | null
    _sum: RecurringPaymentSumAggregateOutputType | null
    _min: RecurringPaymentMinAggregateOutputType | null
    _max: RecurringPaymentMaxAggregateOutputType | null
  }

  type GetRecurringPaymentGroupByPayload<T extends RecurringPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringPaymentGroupByOutputType[P]>
        }
      >
    >


  export type RecurringPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    dueDate?: boolean
    description?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringPayment"]>

  export type RecurringPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    dueDate?: boolean
    description?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringPayment"]>

  export type RecurringPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    dueDate?: boolean
    description?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringPayment"]>

  export type RecurringPaymentSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    dueDate?: boolean
    description?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecurringPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "amount" | "status" | "paymentMethod" | "paymentDate" | "dueDate" | "description" | "externalId" | "createdAt" | "updatedAt", ExtArgs["result"]["recurringPayment"]>
  export type RecurringPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type RecurringPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type RecurringPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $RecurringPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringPayment"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      amount: number
      status: $Enums.PaymentStatus
      paymentMethod: $Enums.PaymentMethod
      paymentDate: Date
      dueDate: Date
      description: string | null
      externalId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recurringPayment"]>
    composites: {}
  }

  type RecurringPaymentGetPayload<S extends boolean | null | undefined | RecurringPaymentDefaultArgs> = $Result.GetResult<Prisma.$RecurringPaymentPayload, S>

  type RecurringPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecurringPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecurringPaymentCountAggregateInputType | true
    }

  export interface RecurringPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringPayment'], meta: { name: 'RecurringPayment' } }
    /**
     * Find zero or one RecurringPayment that matches the filter.
     * @param {RecurringPaymentFindUniqueArgs} args - Arguments to find a RecurringPayment
     * @example
     * // Get one RecurringPayment
     * const recurringPayment = await prisma.recurringPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringPaymentFindUniqueArgs>(args: SelectSubset<T, RecurringPaymentFindUniqueArgs<ExtArgs>>): Prisma__RecurringPaymentClient<$Result.GetResult<Prisma.$RecurringPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecurringPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecurringPaymentFindUniqueOrThrowArgs} args - Arguments to find a RecurringPayment
     * @example
     * // Get one RecurringPayment
     * const recurringPayment = await prisma.recurringPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringPaymentClient<$Result.GetResult<Prisma.$RecurringPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringPaymentFindFirstArgs} args - Arguments to find a RecurringPayment
     * @example
     * // Get one RecurringPayment
     * const recurringPayment = await prisma.recurringPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringPaymentFindFirstArgs>(args?: SelectSubset<T, RecurringPaymentFindFirstArgs<ExtArgs>>): Prisma__RecurringPaymentClient<$Result.GetResult<Prisma.$RecurringPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringPaymentFindFirstOrThrowArgs} args - Arguments to find a RecurringPayment
     * @example
     * // Get one RecurringPayment
     * const recurringPayment = await prisma.recurringPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringPaymentClient<$Result.GetResult<Prisma.$RecurringPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringPayments
     * const recurringPayments = await prisma.recurringPayment.findMany()
     * 
     * // Get first 10 RecurringPayments
     * const recurringPayments = await prisma.recurringPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurringPaymentWithIdOnly = await prisma.recurringPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurringPaymentFindManyArgs>(args?: SelectSubset<T, RecurringPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecurringPayment.
     * @param {RecurringPaymentCreateArgs} args - Arguments to create a RecurringPayment.
     * @example
     * // Create one RecurringPayment
     * const RecurringPayment = await prisma.recurringPayment.create({
     *   data: {
     *     // ... data to create a RecurringPayment
     *   }
     * })
     * 
     */
    create<T extends RecurringPaymentCreateArgs>(args: SelectSubset<T, RecurringPaymentCreateArgs<ExtArgs>>): Prisma__RecurringPaymentClient<$Result.GetResult<Prisma.$RecurringPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecurringPayments.
     * @param {RecurringPaymentCreateManyArgs} args - Arguments to create many RecurringPayments.
     * @example
     * // Create many RecurringPayments
     * const recurringPayment = await prisma.recurringPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringPaymentCreateManyArgs>(args?: SelectSubset<T, RecurringPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecurringPayments and returns the data saved in the database.
     * @param {RecurringPaymentCreateManyAndReturnArgs} args - Arguments to create many RecurringPayments.
     * @example
     * // Create many RecurringPayments
     * const recurringPayment = await prisma.recurringPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecurringPayments and only return the `id`
     * const recurringPaymentWithIdOnly = await prisma.recurringPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecurringPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, RecurringPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecurringPayment.
     * @param {RecurringPaymentDeleteArgs} args - Arguments to delete one RecurringPayment.
     * @example
     * // Delete one RecurringPayment
     * const RecurringPayment = await prisma.recurringPayment.delete({
     *   where: {
     *     // ... filter to delete one RecurringPayment
     *   }
     * })
     * 
     */
    delete<T extends RecurringPaymentDeleteArgs>(args: SelectSubset<T, RecurringPaymentDeleteArgs<ExtArgs>>): Prisma__RecurringPaymentClient<$Result.GetResult<Prisma.$RecurringPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecurringPayment.
     * @param {RecurringPaymentUpdateArgs} args - Arguments to update one RecurringPayment.
     * @example
     * // Update one RecurringPayment
     * const recurringPayment = await prisma.recurringPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringPaymentUpdateArgs>(args: SelectSubset<T, RecurringPaymentUpdateArgs<ExtArgs>>): Prisma__RecurringPaymentClient<$Result.GetResult<Prisma.$RecurringPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecurringPayments.
     * @param {RecurringPaymentDeleteManyArgs} args - Arguments to filter RecurringPayments to delete.
     * @example
     * // Delete a few RecurringPayments
     * const { count } = await prisma.recurringPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringPaymentDeleteManyArgs>(args?: SelectSubset<T, RecurringPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringPayments
     * const recurringPayment = await prisma.recurringPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringPaymentUpdateManyArgs>(args: SelectSubset<T, RecurringPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringPayments and returns the data updated in the database.
     * @param {RecurringPaymentUpdateManyAndReturnArgs} args - Arguments to update many RecurringPayments.
     * @example
     * // Update many RecurringPayments
     * const recurringPayment = await prisma.recurringPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecurringPayments and only return the `id`
     * const recurringPaymentWithIdOnly = await prisma.recurringPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecurringPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, RecurringPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecurringPayment.
     * @param {RecurringPaymentUpsertArgs} args - Arguments to update or create a RecurringPayment.
     * @example
     * // Update or create a RecurringPayment
     * const recurringPayment = await prisma.recurringPayment.upsert({
     *   create: {
     *     // ... data to create a RecurringPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringPayment we want to update
     *   }
     * })
     */
    upsert<T extends RecurringPaymentUpsertArgs>(args: SelectSubset<T, RecurringPaymentUpsertArgs<ExtArgs>>): Prisma__RecurringPaymentClient<$Result.GetResult<Prisma.$RecurringPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecurringPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringPaymentCountArgs} args - Arguments to filter RecurringPayments to count.
     * @example
     * // Count the number of RecurringPayments
     * const count = await prisma.recurringPayment.count({
     *   where: {
     *     // ... the filter for the RecurringPayments we want to count
     *   }
     * })
    **/
    count<T extends RecurringPaymentCountArgs>(
      args?: Subset<T, RecurringPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringPaymentAggregateArgs>(args: Subset<T, RecurringPaymentAggregateArgs>): Prisma.PrismaPromise<GetRecurringPaymentAggregateType<T>>

    /**
     * Group by RecurringPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringPaymentGroupByArgs['orderBy'] }
        : { orderBy?: RecurringPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringPayment model
   */
  readonly fields: RecurringPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringPayment model
   */
  interface RecurringPaymentFieldRefs {
    readonly id: FieldRef<"RecurringPayment", 'String'>
    readonly subscriptionId: FieldRef<"RecurringPayment", 'String'>
    readonly amount: FieldRef<"RecurringPayment", 'Float'>
    readonly status: FieldRef<"RecurringPayment", 'PaymentStatus'>
    readonly paymentMethod: FieldRef<"RecurringPayment", 'PaymentMethod'>
    readonly paymentDate: FieldRef<"RecurringPayment", 'DateTime'>
    readonly dueDate: FieldRef<"RecurringPayment", 'DateTime'>
    readonly description: FieldRef<"RecurringPayment", 'String'>
    readonly externalId: FieldRef<"RecurringPayment", 'String'>
    readonly createdAt: FieldRef<"RecurringPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"RecurringPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecurringPayment findUnique
   */
  export type RecurringPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPayment
     */
    select?: RecurringPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPayment
     */
    omit?: RecurringPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPaymentInclude<ExtArgs> | null
    /**
     * Filter, which RecurringPayment to fetch.
     */
    where: RecurringPaymentWhereUniqueInput
  }

  /**
   * RecurringPayment findUniqueOrThrow
   */
  export type RecurringPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPayment
     */
    select?: RecurringPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPayment
     */
    omit?: RecurringPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPaymentInclude<ExtArgs> | null
    /**
     * Filter, which RecurringPayment to fetch.
     */
    where: RecurringPaymentWhereUniqueInput
  }

  /**
   * RecurringPayment findFirst
   */
  export type RecurringPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPayment
     */
    select?: RecurringPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPayment
     */
    omit?: RecurringPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPaymentInclude<ExtArgs> | null
    /**
     * Filter, which RecurringPayment to fetch.
     */
    where?: RecurringPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringPayments to fetch.
     */
    orderBy?: RecurringPaymentOrderByWithRelationInput | RecurringPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringPayments.
     */
    cursor?: RecurringPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringPayments.
     */
    distinct?: RecurringPaymentScalarFieldEnum | RecurringPaymentScalarFieldEnum[]
  }

  /**
   * RecurringPayment findFirstOrThrow
   */
  export type RecurringPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPayment
     */
    select?: RecurringPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPayment
     */
    omit?: RecurringPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPaymentInclude<ExtArgs> | null
    /**
     * Filter, which RecurringPayment to fetch.
     */
    where?: RecurringPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringPayments to fetch.
     */
    orderBy?: RecurringPaymentOrderByWithRelationInput | RecurringPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringPayments.
     */
    cursor?: RecurringPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringPayments.
     */
    distinct?: RecurringPaymentScalarFieldEnum | RecurringPaymentScalarFieldEnum[]
  }

  /**
   * RecurringPayment findMany
   */
  export type RecurringPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPayment
     */
    select?: RecurringPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPayment
     */
    omit?: RecurringPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPaymentInclude<ExtArgs> | null
    /**
     * Filter, which RecurringPayments to fetch.
     */
    where?: RecurringPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringPayments to fetch.
     */
    orderBy?: RecurringPaymentOrderByWithRelationInput | RecurringPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringPayments.
     */
    cursor?: RecurringPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringPayments.
     */
    skip?: number
    distinct?: RecurringPaymentScalarFieldEnum | RecurringPaymentScalarFieldEnum[]
  }

  /**
   * RecurringPayment create
   */
  export type RecurringPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPayment
     */
    select?: RecurringPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPayment
     */
    omit?: RecurringPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurringPayment.
     */
    data: XOR<RecurringPaymentCreateInput, RecurringPaymentUncheckedCreateInput>
  }

  /**
   * RecurringPayment createMany
   */
  export type RecurringPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringPayments.
     */
    data: RecurringPaymentCreateManyInput | RecurringPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecurringPayment createManyAndReturn
   */
  export type RecurringPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPayment
     */
    select?: RecurringPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPayment
     */
    omit?: RecurringPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many RecurringPayments.
     */
    data: RecurringPaymentCreateManyInput | RecurringPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringPayment update
   */
  export type RecurringPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPayment
     */
    select?: RecurringPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPayment
     */
    omit?: RecurringPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurringPayment.
     */
    data: XOR<RecurringPaymentUpdateInput, RecurringPaymentUncheckedUpdateInput>
    /**
     * Choose, which RecurringPayment to update.
     */
    where: RecurringPaymentWhereUniqueInput
  }

  /**
   * RecurringPayment updateMany
   */
  export type RecurringPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringPayments.
     */
    data: XOR<RecurringPaymentUpdateManyMutationInput, RecurringPaymentUncheckedUpdateManyInput>
    /**
     * Filter which RecurringPayments to update
     */
    where?: RecurringPaymentWhereInput
    /**
     * Limit how many RecurringPayments to update.
     */
    limit?: number
  }

  /**
   * RecurringPayment updateManyAndReturn
   */
  export type RecurringPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPayment
     */
    select?: RecurringPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPayment
     */
    omit?: RecurringPaymentOmit<ExtArgs> | null
    /**
     * The data used to update RecurringPayments.
     */
    data: XOR<RecurringPaymentUpdateManyMutationInput, RecurringPaymentUncheckedUpdateManyInput>
    /**
     * Filter which RecurringPayments to update
     */
    where?: RecurringPaymentWhereInput
    /**
     * Limit how many RecurringPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringPayment upsert
   */
  export type RecurringPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPayment
     */
    select?: RecurringPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPayment
     */
    omit?: RecurringPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurringPayment to update in case it exists.
     */
    where: RecurringPaymentWhereUniqueInput
    /**
     * In case the RecurringPayment found by the `where` argument doesn't exist, create a new RecurringPayment with this data.
     */
    create: XOR<RecurringPaymentCreateInput, RecurringPaymentUncheckedCreateInput>
    /**
     * In case the RecurringPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringPaymentUpdateInput, RecurringPaymentUncheckedUpdateInput>
  }

  /**
   * RecurringPayment delete
   */
  export type RecurringPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPayment
     */
    select?: RecurringPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPayment
     */
    omit?: RecurringPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPaymentInclude<ExtArgs> | null
    /**
     * Filter which RecurringPayment to delete.
     */
    where: RecurringPaymentWhereUniqueInput
  }

  /**
   * RecurringPayment deleteMany
   */
  export type RecurringPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringPayments to delete
     */
    where?: RecurringPaymentWhereInput
    /**
     * Limit how many RecurringPayments to delete.
     */
    limit?: number
  }

  /**
   * RecurringPayment without action
   */
  export type RecurringPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPayment
     */
    select?: RecurringPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPayment
     */
    omit?: RecurringPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPaymentInclude<ExtArgs> | null
  }


  /**
   * Model DashboardMetric
   */

  export type AggregateDashboardMetric = {
    _count: DashboardMetricCountAggregateOutputType | null
    _avg: DashboardMetricAvgAggregateOutputType | null
    _sum: DashboardMetricSumAggregateOutputType | null
    _min: DashboardMetricMinAggregateOutputType | null
    _max: DashboardMetricMaxAggregateOutputType | null
  }

  export type DashboardMetricAvgAggregateOutputType = {
    id: number | null
  }

  export type DashboardMetricSumAggregateOutputType = {
    id: number | null
  }

  export type DashboardMetricMinAggregateOutputType = {
    id: number | null
    lastUpdated: Date | null
  }

  export type DashboardMetricMaxAggregateOutputType = {
    id: number | null
    lastUpdated: Date | null
  }

  export type DashboardMetricCountAggregateOutputType = {
    id: number
    metrics: number
    lastUpdated: number
    _all: number
  }


  export type DashboardMetricAvgAggregateInputType = {
    id?: true
  }

  export type DashboardMetricSumAggregateInputType = {
    id?: true
  }

  export type DashboardMetricMinAggregateInputType = {
    id?: true
    lastUpdated?: true
  }

  export type DashboardMetricMaxAggregateInputType = {
    id?: true
    lastUpdated?: true
  }

  export type DashboardMetricCountAggregateInputType = {
    id?: true
    metrics?: true
    lastUpdated?: true
    _all?: true
  }

  export type DashboardMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardMetric to aggregate.
     */
    where?: DashboardMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardMetrics to fetch.
     */
    orderBy?: DashboardMetricOrderByWithRelationInput | DashboardMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardMetrics
    **/
    _count?: true | DashboardMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DashboardMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DashboardMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardMetricMaxAggregateInputType
  }

  export type GetDashboardMetricAggregateType<T extends DashboardMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardMetric[P]>
      : GetScalarType<T[P], AggregateDashboardMetric[P]>
  }




  export type DashboardMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardMetricWhereInput
    orderBy?: DashboardMetricOrderByWithAggregationInput | DashboardMetricOrderByWithAggregationInput[]
    by: DashboardMetricScalarFieldEnum[] | DashboardMetricScalarFieldEnum
    having?: DashboardMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardMetricCountAggregateInputType | true
    _avg?: DashboardMetricAvgAggregateInputType
    _sum?: DashboardMetricSumAggregateInputType
    _min?: DashboardMetricMinAggregateInputType
    _max?: DashboardMetricMaxAggregateInputType
  }

  export type DashboardMetricGroupByOutputType = {
    id: number
    metrics: JsonValue
    lastUpdated: Date
    _count: DashboardMetricCountAggregateOutputType | null
    _avg: DashboardMetricAvgAggregateOutputType | null
    _sum: DashboardMetricSumAggregateOutputType | null
    _min: DashboardMetricMinAggregateOutputType | null
    _max: DashboardMetricMaxAggregateOutputType | null
  }

  type GetDashboardMetricGroupByPayload<T extends DashboardMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardMetricGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardMetricGroupByOutputType[P]>
        }
      >
    >


  export type DashboardMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metrics?: boolean
    lastUpdated?: boolean
  }, ExtArgs["result"]["dashboardMetric"]>

  export type DashboardMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metrics?: boolean
    lastUpdated?: boolean
  }, ExtArgs["result"]["dashboardMetric"]>

  export type DashboardMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metrics?: boolean
    lastUpdated?: boolean
  }, ExtArgs["result"]["dashboardMetric"]>

  export type DashboardMetricSelectScalar = {
    id?: boolean
    metrics?: boolean
    lastUpdated?: boolean
  }

  export type DashboardMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "metrics" | "lastUpdated", ExtArgs["result"]["dashboardMetric"]>

  export type $DashboardMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DashboardMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      metrics: Prisma.JsonValue
      lastUpdated: Date
    }, ExtArgs["result"]["dashboardMetric"]>
    composites: {}
  }

  type DashboardMetricGetPayload<S extends boolean | null | undefined | DashboardMetricDefaultArgs> = $Result.GetResult<Prisma.$DashboardMetricPayload, S>

  type DashboardMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DashboardMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DashboardMetricCountAggregateInputType | true
    }

  export interface DashboardMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DashboardMetric'], meta: { name: 'DashboardMetric' } }
    /**
     * Find zero or one DashboardMetric that matches the filter.
     * @param {DashboardMetricFindUniqueArgs} args - Arguments to find a DashboardMetric
     * @example
     * // Get one DashboardMetric
     * const dashboardMetric = await prisma.dashboardMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardMetricFindUniqueArgs>(args: SelectSubset<T, DashboardMetricFindUniqueArgs<ExtArgs>>): Prisma__DashboardMetricClient<$Result.GetResult<Prisma.$DashboardMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DashboardMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DashboardMetricFindUniqueOrThrowArgs} args - Arguments to find a DashboardMetric
     * @example
     * // Get one DashboardMetric
     * const dashboardMetric = await prisma.dashboardMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardMetricClient<$Result.GetResult<Prisma.$DashboardMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardMetricFindFirstArgs} args - Arguments to find a DashboardMetric
     * @example
     * // Get one DashboardMetric
     * const dashboardMetric = await prisma.dashboardMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardMetricFindFirstArgs>(args?: SelectSubset<T, DashboardMetricFindFirstArgs<ExtArgs>>): Prisma__DashboardMetricClient<$Result.GetResult<Prisma.$DashboardMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardMetricFindFirstOrThrowArgs} args - Arguments to find a DashboardMetric
     * @example
     * // Get one DashboardMetric
     * const dashboardMetric = await prisma.dashboardMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardMetricClient<$Result.GetResult<Prisma.$DashboardMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DashboardMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardMetrics
     * const dashboardMetrics = await prisma.dashboardMetric.findMany()
     * 
     * // Get first 10 DashboardMetrics
     * const dashboardMetrics = await prisma.dashboardMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardMetricWithIdOnly = await prisma.dashboardMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardMetricFindManyArgs>(args?: SelectSubset<T, DashboardMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DashboardMetric.
     * @param {DashboardMetricCreateArgs} args - Arguments to create a DashboardMetric.
     * @example
     * // Create one DashboardMetric
     * const DashboardMetric = await prisma.dashboardMetric.create({
     *   data: {
     *     // ... data to create a DashboardMetric
     *   }
     * })
     * 
     */
    create<T extends DashboardMetricCreateArgs>(args: SelectSubset<T, DashboardMetricCreateArgs<ExtArgs>>): Prisma__DashboardMetricClient<$Result.GetResult<Prisma.$DashboardMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DashboardMetrics.
     * @param {DashboardMetricCreateManyArgs} args - Arguments to create many DashboardMetrics.
     * @example
     * // Create many DashboardMetrics
     * const dashboardMetric = await prisma.dashboardMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardMetricCreateManyArgs>(args?: SelectSubset<T, DashboardMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DashboardMetrics and returns the data saved in the database.
     * @param {DashboardMetricCreateManyAndReturnArgs} args - Arguments to create many DashboardMetrics.
     * @example
     * // Create many DashboardMetrics
     * const dashboardMetric = await prisma.dashboardMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DashboardMetrics and only return the `id`
     * const dashboardMetricWithIdOnly = await prisma.dashboardMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DashboardMetric.
     * @param {DashboardMetricDeleteArgs} args - Arguments to delete one DashboardMetric.
     * @example
     * // Delete one DashboardMetric
     * const DashboardMetric = await prisma.dashboardMetric.delete({
     *   where: {
     *     // ... filter to delete one DashboardMetric
     *   }
     * })
     * 
     */
    delete<T extends DashboardMetricDeleteArgs>(args: SelectSubset<T, DashboardMetricDeleteArgs<ExtArgs>>): Prisma__DashboardMetricClient<$Result.GetResult<Prisma.$DashboardMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DashboardMetric.
     * @param {DashboardMetricUpdateArgs} args - Arguments to update one DashboardMetric.
     * @example
     * // Update one DashboardMetric
     * const dashboardMetric = await prisma.dashboardMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardMetricUpdateArgs>(args: SelectSubset<T, DashboardMetricUpdateArgs<ExtArgs>>): Prisma__DashboardMetricClient<$Result.GetResult<Prisma.$DashboardMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DashboardMetrics.
     * @param {DashboardMetricDeleteManyArgs} args - Arguments to filter DashboardMetrics to delete.
     * @example
     * // Delete a few DashboardMetrics
     * const { count } = await prisma.dashboardMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardMetricDeleteManyArgs>(args?: SelectSubset<T, DashboardMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardMetrics
     * const dashboardMetric = await prisma.dashboardMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardMetricUpdateManyArgs>(args: SelectSubset<T, DashboardMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardMetrics and returns the data updated in the database.
     * @param {DashboardMetricUpdateManyAndReturnArgs} args - Arguments to update many DashboardMetrics.
     * @example
     * // Update many DashboardMetrics
     * const dashboardMetric = await prisma.dashboardMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DashboardMetrics and only return the `id`
     * const dashboardMetricWithIdOnly = await prisma.dashboardMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DashboardMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, DashboardMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DashboardMetric.
     * @param {DashboardMetricUpsertArgs} args - Arguments to update or create a DashboardMetric.
     * @example
     * // Update or create a DashboardMetric
     * const dashboardMetric = await prisma.dashboardMetric.upsert({
     *   create: {
     *     // ... data to create a DashboardMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardMetric we want to update
     *   }
     * })
     */
    upsert<T extends DashboardMetricUpsertArgs>(args: SelectSubset<T, DashboardMetricUpsertArgs<ExtArgs>>): Prisma__DashboardMetricClient<$Result.GetResult<Prisma.$DashboardMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DashboardMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardMetricCountArgs} args - Arguments to filter DashboardMetrics to count.
     * @example
     * // Count the number of DashboardMetrics
     * const count = await prisma.dashboardMetric.count({
     *   where: {
     *     // ... the filter for the DashboardMetrics we want to count
     *   }
     * })
    **/
    count<T extends DashboardMetricCountArgs>(
      args?: Subset<T, DashboardMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardMetricAggregateArgs>(args: Subset<T, DashboardMetricAggregateArgs>): Prisma.PrismaPromise<GetDashboardMetricAggregateType<T>>

    /**
     * Group by DashboardMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardMetricGroupByArgs['orderBy'] }
        : { orderBy?: DashboardMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DashboardMetric model
   */
  readonly fields: DashboardMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DashboardMetric model
   */
  interface DashboardMetricFieldRefs {
    readonly id: FieldRef<"DashboardMetric", 'Int'>
    readonly metrics: FieldRef<"DashboardMetric", 'Json'>
    readonly lastUpdated: FieldRef<"DashboardMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DashboardMetric findUnique
   */
  export type DashboardMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetric
     */
    select?: DashboardMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardMetric
     */
    omit?: DashboardMetricOmit<ExtArgs> | null
    /**
     * Filter, which DashboardMetric to fetch.
     */
    where: DashboardMetricWhereUniqueInput
  }

  /**
   * DashboardMetric findUniqueOrThrow
   */
  export type DashboardMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetric
     */
    select?: DashboardMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardMetric
     */
    omit?: DashboardMetricOmit<ExtArgs> | null
    /**
     * Filter, which DashboardMetric to fetch.
     */
    where: DashboardMetricWhereUniqueInput
  }

  /**
   * DashboardMetric findFirst
   */
  export type DashboardMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetric
     */
    select?: DashboardMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardMetric
     */
    omit?: DashboardMetricOmit<ExtArgs> | null
    /**
     * Filter, which DashboardMetric to fetch.
     */
    where?: DashboardMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardMetrics to fetch.
     */
    orderBy?: DashboardMetricOrderByWithRelationInput | DashboardMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardMetrics.
     */
    cursor?: DashboardMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardMetrics.
     */
    distinct?: DashboardMetricScalarFieldEnum | DashboardMetricScalarFieldEnum[]
  }

  /**
   * DashboardMetric findFirstOrThrow
   */
  export type DashboardMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetric
     */
    select?: DashboardMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardMetric
     */
    omit?: DashboardMetricOmit<ExtArgs> | null
    /**
     * Filter, which DashboardMetric to fetch.
     */
    where?: DashboardMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardMetrics to fetch.
     */
    orderBy?: DashboardMetricOrderByWithRelationInput | DashboardMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardMetrics.
     */
    cursor?: DashboardMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardMetrics.
     */
    distinct?: DashboardMetricScalarFieldEnum | DashboardMetricScalarFieldEnum[]
  }

  /**
   * DashboardMetric findMany
   */
  export type DashboardMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetric
     */
    select?: DashboardMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardMetric
     */
    omit?: DashboardMetricOmit<ExtArgs> | null
    /**
     * Filter, which DashboardMetrics to fetch.
     */
    where?: DashboardMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardMetrics to fetch.
     */
    orderBy?: DashboardMetricOrderByWithRelationInput | DashboardMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardMetrics.
     */
    cursor?: DashboardMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardMetrics.
     */
    skip?: number
    distinct?: DashboardMetricScalarFieldEnum | DashboardMetricScalarFieldEnum[]
  }

  /**
   * DashboardMetric create
   */
  export type DashboardMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetric
     */
    select?: DashboardMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardMetric
     */
    omit?: DashboardMetricOmit<ExtArgs> | null
    /**
     * The data needed to create a DashboardMetric.
     */
    data: XOR<DashboardMetricCreateInput, DashboardMetricUncheckedCreateInput>
  }

  /**
   * DashboardMetric createMany
   */
  export type DashboardMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DashboardMetrics.
     */
    data: DashboardMetricCreateManyInput | DashboardMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DashboardMetric createManyAndReturn
   */
  export type DashboardMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetric
     */
    select?: DashboardMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardMetric
     */
    omit?: DashboardMetricOmit<ExtArgs> | null
    /**
     * The data used to create many DashboardMetrics.
     */
    data: DashboardMetricCreateManyInput | DashboardMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DashboardMetric update
   */
  export type DashboardMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetric
     */
    select?: DashboardMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardMetric
     */
    omit?: DashboardMetricOmit<ExtArgs> | null
    /**
     * The data needed to update a DashboardMetric.
     */
    data: XOR<DashboardMetricUpdateInput, DashboardMetricUncheckedUpdateInput>
    /**
     * Choose, which DashboardMetric to update.
     */
    where: DashboardMetricWhereUniqueInput
  }

  /**
   * DashboardMetric updateMany
   */
  export type DashboardMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DashboardMetrics.
     */
    data: XOR<DashboardMetricUpdateManyMutationInput, DashboardMetricUncheckedUpdateManyInput>
    /**
     * Filter which DashboardMetrics to update
     */
    where?: DashboardMetricWhereInput
    /**
     * Limit how many DashboardMetrics to update.
     */
    limit?: number
  }

  /**
   * DashboardMetric updateManyAndReturn
   */
  export type DashboardMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetric
     */
    select?: DashboardMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardMetric
     */
    omit?: DashboardMetricOmit<ExtArgs> | null
    /**
     * The data used to update DashboardMetrics.
     */
    data: XOR<DashboardMetricUpdateManyMutationInput, DashboardMetricUncheckedUpdateManyInput>
    /**
     * Filter which DashboardMetrics to update
     */
    where?: DashboardMetricWhereInput
    /**
     * Limit how many DashboardMetrics to update.
     */
    limit?: number
  }

  /**
   * DashboardMetric upsert
   */
  export type DashboardMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetric
     */
    select?: DashboardMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardMetric
     */
    omit?: DashboardMetricOmit<ExtArgs> | null
    /**
     * The filter to search for the DashboardMetric to update in case it exists.
     */
    where: DashboardMetricWhereUniqueInput
    /**
     * In case the DashboardMetric found by the `where` argument doesn't exist, create a new DashboardMetric with this data.
     */
    create: XOR<DashboardMetricCreateInput, DashboardMetricUncheckedCreateInput>
    /**
     * In case the DashboardMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardMetricUpdateInput, DashboardMetricUncheckedUpdateInput>
  }

  /**
   * DashboardMetric delete
   */
  export type DashboardMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetric
     */
    select?: DashboardMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardMetric
     */
    omit?: DashboardMetricOmit<ExtArgs> | null
    /**
     * Filter which DashboardMetric to delete.
     */
    where: DashboardMetricWhereUniqueInput
  }

  /**
   * DashboardMetric deleteMany
   */
  export type DashboardMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardMetrics to delete
     */
    where?: DashboardMetricWhereInput
    /**
     * Limit how many DashboardMetrics to delete.
     */
    limit?: number
  }

  /**
   * DashboardMetric without action
   */
  export type DashboardMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetric
     */
    select?: DashboardMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardMetric
     */
    omit?: DashboardMetricOmit<ExtArgs> | null
  }


  /**
   * Model EmailSettings
   */

  export type AggregateEmailSettings = {
    _count: EmailSettingsCountAggregateOutputType | null
    _avg: EmailSettingsAvgAggregateOutputType | null
    _sum: EmailSettingsSumAggregateOutputType | null
    _min: EmailSettingsMinAggregateOutputType | null
    _max: EmailSettingsMaxAggregateOutputType | null
  }

  export type EmailSettingsAvgAggregateOutputType = {
    id: number | null
  }

  export type EmailSettingsSumAggregateOutputType = {
    id: number | null
  }

  export type EmailSettingsMinAggregateOutputType = {
    id: number | null
    lastUpdated: Date | null
  }

  export type EmailSettingsMaxAggregateOutputType = {
    id: number | null
    lastUpdated: Date | null
  }

  export type EmailSettingsCountAggregateOutputType = {
    id: number
    settings: number
    lastUpdated: number
    _all: number
  }


  export type EmailSettingsAvgAggregateInputType = {
    id?: true
  }

  export type EmailSettingsSumAggregateInputType = {
    id?: true
  }

  export type EmailSettingsMinAggregateInputType = {
    id?: true
    lastUpdated?: true
  }

  export type EmailSettingsMaxAggregateInputType = {
    id?: true
    lastUpdated?: true
  }

  export type EmailSettingsCountAggregateInputType = {
    id?: true
    settings?: true
    lastUpdated?: true
    _all?: true
  }

  export type EmailSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailSettings to aggregate.
     */
    where?: EmailSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSettings to fetch.
     */
    orderBy?: EmailSettingsOrderByWithRelationInput | EmailSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailSettings
    **/
    _count?: true | EmailSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailSettingsMaxAggregateInputType
  }

  export type GetEmailSettingsAggregateType<T extends EmailSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailSettings[P]>
      : GetScalarType<T[P], AggregateEmailSettings[P]>
  }




  export type EmailSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailSettingsWhereInput
    orderBy?: EmailSettingsOrderByWithAggregationInput | EmailSettingsOrderByWithAggregationInput[]
    by: EmailSettingsScalarFieldEnum[] | EmailSettingsScalarFieldEnum
    having?: EmailSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailSettingsCountAggregateInputType | true
    _avg?: EmailSettingsAvgAggregateInputType
    _sum?: EmailSettingsSumAggregateInputType
    _min?: EmailSettingsMinAggregateInputType
    _max?: EmailSettingsMaxAggregateInputType
  }

  export type EmailSettingsGroupByOutputType = {
    id: number
    settings: JsonValue
    lastUpdated: Date
    _count: EmailSettingsCountAggregateOutputType | null
    _avg: EmailSettingsAvgAggregateOutputType | null
    _sum: EmailSettingsSumAggregateOutputType | null
    _min: EmailSettingsMinAggregateOutputType | null
    _max: EmailSettingsMaxAggregateOutputType | null
  }

  type GetEmailSettingsGroupByPayload<T extends EmailSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], EmailSettingsGroupByOutputType[P]>
        }
      >
    >


  export type EmailSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settings?: boolean
    lastUpdated?: boolean
  }, ExtArgs["result"]["emailSettings"]>

  export type EmailSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settings?: boolean
    lastUpdated?: boolean
  }, ExtArgs["result"]["emailSettings"]>

  export type EmailSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settings?: boolean
    lastUpdated?: boolean
  }, ExtArgs["result"]["emailSettings"]>

  export type EmailSettingsSelectScalar = {
    id?: boolean
    settings?: boolean
    lastUpdated?: boolean
  }

  export type EmailSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "settings" | "lastUpdated", ExtArgs["result"]["emailSettings"]>

  export type $EmailSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      settings: Prisma.JsonValue
      lastUpdated: Date
    }, ExtArgs["result"]["emailSettings"]>
    composites: {}
  }

  type EmailSettingsGetPayload<S extends boolean | null | undefined | EmailSettingsDefaultArgs> = $Result.GetResult<Prisma.$EmailSettingsPayload, S>

  type EmailSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailSettingsCountAggregateInputType | true
    }

  export interface EmailSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailSettings'], meta: { name: 'EmailSettings' } }
    /**
     * Find zero or one EmailSettings that matches the filter.
     * @param {EmailSettingsFindUniqueArgs} args - Arguments to find a EmailSettings
     * @example
     * // Get one EmailSettings
     * const emailSettings = await prisma.emailSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailSettingsFindUniqueArgs>(args: SelectSubset<T, EmailSettingsFindUniqueArgs<ExtArgs>>): Prisma__EmailSettingsClient<$Result.GetResult<Prisma.$EmailSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailSettingsFindUniqueOrThrowArgs} args - Arguments to find a EmailSettings
     * @example
     * // Get one EmailSettings
     * const emailSettings = await prisma.emailSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailSettingsClient<$Result.GetResult<Prisma.$EmailSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSettingsFindFirstArgs} args - Arguments to find a EmailSettings
     * @example
     * // Get one EmailSettings
     * const emailSettings = await prisma.emailSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailSettingsFindFirstArgs>(args?: SelectSubset<T, EmailSettingsFindFirstArgs<ExtArgs>>): Prisma__EmailSettingsClient<$Result.GetResult<Prisma.$EmailSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSettingsFindFirstOrThrowArgs} args - Arguments to find a EmailSettings
     * @example
     * // Get one EmailSettings
     * const emailSettings = await prisma.emailSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailSettingsClient<$Result.GetResult<Prisma.$EmailSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailSettings
     * const emailSettings = await prisma.emailSettings.findMany()
     * 
     * // Get first 10 EmailSettings
     * const emailSettings = await prisma.emailSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailSettingsWithIdOnly = await prisma.emailSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailSettingsFindManyArgs>(args?: SelectSubset<T, EmailSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailSettings.
     * @param {EmailSettingsCreateArgs} args - Arguments to create a EmailSettings.
     * @example
     * // Create one EmailSettings
     * const EmailSettings = await prisma.emailSettings.create({
     *   data: {
     *     // ... data to create a EmailSettings
     *   }
     * })
     * 
     */
    create<T extends EmailSettingsCreateArgs>(args: SelectSubset<T, EmailSettingsCreateArgs<ExtArgs>>): Prisma__EmailSettingsClient<$Result.GetResult<Prisma.$EmailSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailSettings.
     * @param {EmailSettingsCreateManyArgs} args - Arguments to create many EmailSettings.
     * @example
     * // Create many EmailSettings
     * const emailSettings = await prisma.emailSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailSettingsCreateManyArgs>(args?: SelectSubset<T, EmailSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailSettings and returns the data saved in the database.
     * @param {EmailSettingsCreateManyAndReturnArgs} args - Arguments to create many EmailSettings.
     * @example
     * // Create many EmailSettings
     * const emailSettings = await prisma.emailSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailSettings and only return the `id`
     * const emailSettingsWithIdOnly = await prisma.emailSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailSettings.
     * @param {EmailSettingsDeleteArgs} args - Arguments to delete one EmailSettings.
     * @example
     * // Delete one EmailSettings
     * const EmailSettings = await prisma.emailSettings.delete({
     *   where: {
     *     // ... filter to delete one EmailSettings
     *   }
     * })
     * 
     */
    delete<T extends EmailSettingsDeleteArgs>(args: SelectSubset<T, EmailSettingsDeleteArgs<ExtArgs>>): Prisma__EmailSettingsClient<$Result.GetResult<Prisma.$EmailSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailSettings.
     * @param {EmailSettingsUpdateArgs} args - Arguments to update one EmailSettings.
     * @example
     * // Update one EmailSettings
     * const emailSettings = await prisma.emailSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailSettingsUpdateArgs>(args: SelectSubset<T, EmailSettingsUpdateArgs<ExtArgs>>): Prisma__EmailSettingsClient<$Result.GetResult<Prisma.$EmailSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailSettings.
     * @param {EmailSettingsDeleteManyArgs} args - Arguments to filter EmailSettings to delete.
     * @example
     * // Delete a few EmailSettings
     * const { count } = await prisma.emailSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailSettingsDeleteManyArgs>(args?: SelectSubset<T, EmailSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailSettings
     * const emailSettings = await prisma.emailSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailSettingsUpdateManyArgs>(args: SelectSubset<T, EmailSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailSettings and returns the data updated in the database.
     * @param {EmailSettingsUpdateManyAndReturnArgs} args - Arguments to update many EmailSettings.
     * @example
     * // Update many EmailSettings
     * const emailSettings = await prisma.emailSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailSettings and only return the `id`
     * const emailSettingsWithIdOnly = await prisma.emailSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailSettings.
     * @param {EmailSettingsUpsertArgs} args - Arguments to update or create a EmailSettings.
     * @example
     * // Update or create a EmailSettings
     * const emailSettings = await prisma.emailSettings.upsert({
     *   create: {
     *     // ... data to create a EmailSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailSettings we want to update
     *   }
     * })
     */
    upsert<T extends EmailSettingsUpsertArgs>(args: SelectSubset<T, EmailSettingsUpsertArgs<ExtArgs>>): Prisma__EmailSettingsClient<$Result.GetResult<Prisma.$EmailSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSettingsCountArgs} args - Arguments to filter EmailSettings to count.
     * @example
     * // Count the number of EmailSettings
     * const count = await prisma.emailSettings.count({
     *   where: {
     *     // ... the filter for the EmailSettings we want to count
     *   }
     * })
    **/
    count<T extends EmailSettingsCountArgs>(
      args?: Subset<T, EmailSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailSettingsAggregateArgs>(args: Subset<T, EmailSettingsAggregateArgs>): Prisma.PrismaPromise<GetEmailSettingsAggregateType<T>>

    /**
     * Group by EmailSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailSettingsGroupByArgs['orderBy'] }
        : { orderBy?: EmailSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailSettings model
   */
  readonly fields: EmailSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailSettings model
   */
  interface EmailSettingsFieldRefs {
    readonly id: FieldRef<"EmailSettings", 'Int'>
    readonly settings: FieldRef<"EmailSettings", 'Json'>
    readonly lastUpdated: FieldRef<"EmailSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailSettings findUnique
   */
  export type EmailSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSettings
     */
    select?: EmailSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSettings
     */
    omit?: EmailSettingsOmit<ExtArgs> | null
    /**
     * Filter, which EmailSettings to fetch.
     */
    where: EmailSettingsWhereUniqueInput
  }

  /**
   * EmailSettings findUniqueOrThrow
   */
  export type EmailSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSettings
     */
    select?: EmailSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSettings
     */
    omit?: EmailSettingsOmit<ExtArgs> | null
    /**
     * Filter, which EmailSettings to fetch.
     */
    where: EmailSettingsWhereUniqueInput
  }

  /**
   * EmailSettings findFirst
   */
  export type EmailSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSettings
     */
    select?: EmailSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSettings
     */
    omit?: EmailSettingsOmit<ExtArgs> | null
    /**
     * Filter, which EmailSettings to fetch.
     */
    where?: EmailSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSettings to fetch.
     */
    orderBy?: EmailSettingsOrderByWithRelationInput | EmailSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailSettings.
     */
    cursor?: EmailSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailSettings.
     */
    distinct?: EmailSettingsScalarFieldEnum | EmailSettingsScalarFieldEnum[]
  }

  /**
   * EmailSettings findFirstOrThrow
   */
  export type EmailSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSettings
     */
    select?: EmailSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSettings
     */
    omit?: EmailSettingsOmit<ExtArgs> | null
    /**
     * Filter, which EmailSettings to fetch.
     */
    where?: EmailSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSettings to fetch.
     */
    orderBy?: EmailSettingsOrderByWithRelationInput | EmailSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailSettings.
     */
    cursor?: EmailSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailSettings.
     */
    distinct?: EmailSettingsScalarFieldEnum | EmailSettingsScalarFieldEnum[]
  }

  /**
   * EmailSettings findMany
   */
  export type EmailSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSettings
     */
    select?: EmailSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSettings
     */
    omit?: EmailSettingsOmit<ExtArgs> | null
    /**
     * Filter, which EmailSettings to fetch.
     */
    where?: EmailSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailSettings to fetch.
     */
    orderBy?: EmailSettingsOrderByWithRelationInput | EmailSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailSettings.
     */
    cursor?: EmailSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailSettings.
     */
    skip?: number
    distinct?: EmailSettingsScalarFieldEnum | EmailSettingsScalarFieldEnum[]
  }

  /**
   * EmailSettings create
   */
  export type EmailSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSettings
     */
    select?: EmailSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSettings
     */
    omit?: EmailSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a EmailSettings.
     */
    data: XOR<EmailSettingsCreateInput, EmailSettingsUncheckedCreateInput>
  }

  /**
   * EmailSettings createMany
   */
  export type EmailSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailSettings.
     */
    data: EmailSettingsCreateManyInput | EmailSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailSettings createManyAndReturn
   */
  export type EmailSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSettings
     */
    select?: EmailSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSettings
     */
    omit?: EmailSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many EmailSettings.
     */
    data: EmailSettingsCreateManyInput | EmailSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailSettings update
   */
  export type EmailSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSettings
     */
    select?: EmailSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSettings
     */
    omit?: EmailSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a EmailSettings.
     */
    data: XOR<EmailSettingsUpdateInput, EmailSettingsUncheckedUpdateInput>
    /**
     * Choose, which EmailSettings to update.
     */
    where: EmailSettingsWhereUniqueInput
  }

  /**
   * EmailSettings updateMany
   */
  export type EmailSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailSettings.
     */
    data: XOR<EmailSettingsUpdateManyMutationInput, EmailSettingsUncheckedUpdateManyInput>
    /**
     * Filter which EmailSettings to update
     */
    where?: EmailSettingsWhereInput
    /**
     * Limit how many EmailSettings to update.
     */
    limit?: number
  }

  /**
   * EmailSettings updateManyAndReturn
   */
  export type EmailSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSettings
     */
    select?: EmailSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSettings
     */
    omit?: EmailSettingsOmit<ExtArgs> | null
    /**
     * The data used to update EmailSettings.
     */
    data: XOR<EmailSettingsUpdateManyMutationInput, EmailSettingsUncheckedUpdateManyInput>
    /**
     * Filter which EmailSettings to update
     */
    where?: EmailSettingsWhereInput
    /**
     * Limit how many EmailSettings to update.
     */
    limit?: number
  }

  /**
   * EmailSettings upsert
   */
  export type EmailSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSettings
     */
    select?: EmailSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSettings
     */
    omit?: EmailSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the EmailSettings to update in case it exists.
     */
    where: EmailSettingsWhereUniqueInput
    /**
     * In case the EmailSettings found by the `where` argument doesn't exist, create a new EmailSettings with this data.
     */
    create: XOR<EmailSettingsCreateInput, EmailSettingsUncheckedCreateInput>
    /**
     * In case the EmailSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailSettingsUpdateInput, EmailSettingsUncheckedUpdateInput>
  }

  /**
   * EmailSettings delete
   */
  export type EmailSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSettings
     */
    select?: EmailSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSettings
     */
    omit?: EmailSettingsOmit<ExtArgs> | null
    /**
     * Filter which EmailSettings to delete.
     */
    where: EmailSettingsWhereUniqueInput
  }

  /**
   * EmailSettings deleteMany
   */
  export type EmailSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailSettings to delete
     */
    where?: EmailSettingsWhereInput
    /**
     * Limit how many EmailSettings to delete.
     */
    limit?: number
  }

  /**
   * EmailSettings without action
   */
  export type EmailSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailSettings
     */
    select?: EmailSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailSettings
     */
    omit?: EmailSettingsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    department: 'department',
    level: 'level',
    permissions: 'permissions',
    title: 'title',
    phone: 'phone',
    profileImage: 'profileImage',
    lastLogin: 'lastLogin',
    loginAttempts: 'loginAttempts',
    isSuperAdmin: 'isSuperAdmin',
    ipRestrictions: 'ipRestrictions'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const CourierScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    vehicleType: 'vehicleType',
    phone: 'phone',
    zoneId: 'zoneId',
    ratings: 'ratings',
    currentLatitude: 'currentLatitude',
    currentLongitude: 'currentLongitude',
    lastLocationUpdate: 'lastLocationUpdate',
    availableFrom: 'availableFrom',
    availableTo: 'availableTo',
    documentsVerified: 'documentsVerified',
    backgroundChecked: 'backgroundChecked',
    maxDeliveriesPerDay: 'maxDeliveriesPerDay',
    maxDistance: 'maxDistance',
    averageSpeed: 'averageSpeed',
    courierFee: 'courierFee',
    lastSeen: 'lastSeen',
    availabilityStatus: 'availabilityStatus'
  };

  export type CourierScalarFieldEnum = (typeof CourierScalarFieldEnum)[keyof typeof CourierScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    totalPrice: 'totalPrice',
    items: 'items',
    address: 'address',
    notes: 'notes',
    estimatedDelivery: 'estimatedDelivery',
    actualDelivery: 'actualDelivery',
    latitude: 'latitude',
    longitude: 'longitude',
    customerId: 'customerId',
    businessId: 'businessId',
    courierId: 'courierId',
    priority: 'priority',
    timeWindowId: 'timeWindowId',
    estimatedDuration: 'estimatedDuration',
    estimatedDistance: 'estimatedDistance',
    sequenceNumber: 'sequenceNumber',
    refundStatus: 'refundStatus',
    cancellationStatus: 'cancellationStatus'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    phone: 'phone',
    address: 'address',
    latitude: 'latitude',
    longitude: 'longitude',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const BusinessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    address: 'address',
    phone: 'phone',
    website: 'website',
    email: 'email',
    logoUrl: 'logoUrl',
    coverUrl: 'coverUrl',
    latitude: 'latitude',
    longitude: 'longitude',
    zoneId: 'zoneId',
    status: 'status',
    rating: 'rating',
    tax_id: 'tax_id',
    bank_iban: 'bank_iban',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    openingTime: 'openingTime',
    closingTime: 'closingTime',
    deliveryRadius: 'deliveryRadius',
    deliveryFee: 'deliveryFee',
    facebook: 'facebook',
    instagram: 'instagram',
    twitter: 'twitter',
    type: 'type',
    tags: 'tags',
    features: 'features'
  };

  export type BusinessScalarFieldEnum = (typeof BusinessScalarFieldEnum)[keyof typeof BusinessScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    coordinates: 'coordinates',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    averageDeliveryTime: 'averageDeliveryTime',
    orderVolume: 'orderVolume',
    activeBusinesses: 'activeBusinesses'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courierId: 'courierId',
    type: 'type',
    channel: 'channel',
    frequency: 'frequency',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    type: 'type',
    isRead: 'isRead',
    createdAt: 'createdAt',
    userId: 'userId',
    courierId: 'courierId',
    orderId: 'orderId',
    metadata: 'metadata'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const DeliveryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    courierId: 'courierId',
    customerId: 'customerId',
    zoneId: 'zoneId',
    orderId: 'orderId',
    assignedAt: 'assignedAt',
    pickedUpAt: 'pickedUpAt',
    deliveredAt: 'deliveredAt',
    estimatedPickupTime: 'estimatedPickupTime',
    estimatedDeliveryTime: 'estimatedDeliveryTime',
    duration: 'duration',
    actualDuration: 'actualDuration',
    distance: 'distance',
    actualDistance: 'actualDistance',
    pickupLatitude: 'pickupLatitude',
    pickupLongitude: 'pickupLongitude',
    dropoffLatitude: 'dropoffLatitude',
    dropoffLongitude: 'dropoffLongitude',
    routeId: 'routeId',
    sequenceNumber: 'sequenceNumber',
    priority: 'priority'
  };

  export type DeliveryScalarFieldEnum = (typeof DeliveryScalarFieldEnum)[keyof typeof DeliveryScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    name: 'name',
    description: 'description',
    quantity: 'quantity',
    price: 'price',
    sku: 'sku',
    imageUrl: 'imageUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    categoryId: 'categoryId'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const DeliveryLogScalarFieldEnum: {
    id: 'id',
    courierId: 'courierId',
    action: 'action',
    timestamp: 'timestamp',
    latitude: 'latitude',
    longitude: 'longitude',
    note: 'note',
    metadata: 'metadata'
  };

  export type DeliveryLogScalarFieldEnum = (typeof DeliveryLogScalarFieldEnum)[keyof typeof DeliveryLogScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    type: 'type',
    format: 'format',
    parameters: 'parameters',
    createdAt: 'createdAt',
    data: 'data',
    url: 'url',
    expiresAt: 'expiresAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const ScheduledReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    scheduleId: 'scheduleId',
    reportName: 'reportName',
    type: 'type',
    format: 'format',
    parameters: 'parameters',
    enabled: 'enabled',
    recipients: 'recipients',
    nextRunAt: 'nextRunAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduledReportScalarFieldEnum = (typeof ScheduledReportScalarFieldEnum)[keyof typeof ScheduledReportScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    language: 'language',
    theme: 'theme',
    notifications: 'notifications',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const MenuItemScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    name: 'name',
    description: 'description',
    price: 'price',
    imageUrl: 'imageUrl',
    category: 'category',
    tags: 'tags',
    ingredients: 'ingredients',
    calories: 'calories',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuItemScalarFieldEnum = (typeof MenuItemScalarFieldEnum)[keyof typeof MenuItemScalarFieldEnum]


  export const CourierAvailabilityScalarFieldEnum: {
    id: 'id',
    courierId: 'courierId',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type CourierAvailabilityScalarFieldEnum = (typeof CourierAvailabilityScalarFieldEnum)[keyof typeof CourierAvailabilityScalarFieldEnum]


  export const DeliveryTimeWindowScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startTime: 'startTime',
    endTime: 'endTime',
    description: 'description',
    priorityFactor: 'priorityFactor'
  };

  export type DeliveryTimeWindowScalarFieldEnum = (typeof DeliveryTimeWindowScalarFieldEnum)[keyof typeof DeliveryTimeWindowScalarFieldEnum]


  export const DeliveryRouteScalarFieldEnum: {
    id: 'id',
    courierId: 'courierId',
    name: 'name',
    createdAt: 'createdAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    status: 'status',
    totalDistance: 'totalDistance',
    totalDuration: 'totalDuration',
    startLatitude: 'startLatitude',
    startLongitude: 'startLongitude',
    endLatitude: 'endLatitude',
    endLongitude: 'endLongitude',
    routePath: 'routePath'
  };

  export type DeliveryRouteScalarFieldEnum = (typeof DeliveryRouteScalarFieldEnum)[keyof typeof DeliveryRouteScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    currency: 'currency',
    method: 'method',
    status: 'status',
    reference: 'reference',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    processedAt: 'processedAt',
    orderId: 'orderId',
    recipientId: 'recipientId',
    businessId: 'businessId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    name: 'name',
    description: 'description',
    slug: 'slug',
    imageUrl: 'imageUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parentId: 'parentId'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    description: 'description',
    createdAt: 'createdAt',
    userId: 'userId',
    targetId: 'targetId',
    targetType: 'targetType',
    ip: 'ip',
    userAgent: 'userAgent',
    adminId: 'adminId',
    metadata: 'metadata',
    severity: 'severity',
    category: 'category',
    isResolved: 'isResolved',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const SystemActionScalarFieldEnum: {
    id: 'id',
    action: 'action',
    description: 'description',
    createdAt: 'createdAt',
    adminId: 'adminId',
    status: 'status',
    payload: 'payload',
    result: 'result',
    error: 'error',
    executionTime: 'executionTime'
  };

  export type SystemActionScalarFieldEnum = (typeof SystemActionScalarFieldEnum)[keyof typeof SystemActionScalarFieldEnum]


  export const SystemSettingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    category: 'category',
    description: 'description',
    dataType: 'dataType',
    isEncrypted: 'isEncrypted',
    lastUpdated: 'lastUpdated',
    updatedBy: 'updatedBy'
  };

  export type SystemSettingsScalarFieldEnum = (typeof SystemSettingsScalarFieldEnum)[keyof typeof SystemSettingsScalarFieldEnum]


  export const AdminDashboardWidgetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    position: 'position',
    size: 'size',
    config: 'config',
    isActive: 'isActive',
    adminId: 'adminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminDashboardWidgetScalarFieldEnum = (typeof AdminDashboardWidgetScalarFieldEnum)[keyof typeof AdminDashboardWidgetScalarFieldEnum]


  export const AdminPermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminPermissionScalarFieldEnum = (typeof AdminPermissionScalarFieldEnum)[keyof typeof AdminPermissionScalarFieldEnum]


  export const AdminRoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminRoleScalarFieldEnum = (typeof AdminRoleScalarFieldEnum)[keyof typeof AdminRoleScalarFieldEnum]


  export const AdminRoleMappingScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    roleId: 'roleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminRoleMappingScalarFieldEnum = (typeof AdminRoleMappingScalarFieldEnum)[keyof typeof AdminRoleMappingScalarFieldEnum]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    body: 'body',
    category: 'category',
    description: 'description',
    isActive: 'isActive',
    variables: 'variables',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const SentEmailScalarFieldEnum: {
    id: 'id',
    templateId: 'templateId',
    recipient: 'recipient',
    subject: 'subject',
    variables: 'variables',
    messageId: 'messageId',
    sentBy: 'sentBy',
    sentAt: 'sentAt',
    status: 'status',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SentEmailScalarFieldEnum = (typeof SentEmailScalarFieldEnum)[keyof typeof SentEmailScalarFieldEnum]


  export const CustomerAddressScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    title: 'title',
    firstName: 'firstName',
    lastName: 'lastName',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    phone: 'phone',
    notes: 'notes',
    latitude: 'latitude',
    longitude: 'longitude',
    isDefault: 'isDefault',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerAddressScalarFieldEnum = (typeof CustomerAddressScalarFieldEnum)[keyof typeof CustomerAddressScalarFieldEnum]


  export const RefundRequestScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    customerId: 'customerId',
    businessId: 'businessId',
    status: 'status',
    reason: 'reason',
    otherReason: 'otherReason',
    requestedItems: 'requestedItems',
    refundAmount: 'refundAmount',
    approvedAmount: 'approvedAmount',
    evidenceUrls: 'evidenceUrls',
    adminNotes: 'adminNotes',
    customerNotes: 'customerNotes',
    businessNotes: 'businessNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    reviewedAt: 'reviewedAt',
    reviewedBy: 'reviewedBy',
    refundedAt: 'refundedAt'
  };

  export type RefundRequestScalarFieldEnum = (typeof RefundRequestScalarFieldEnum)[keyof typeof RefundRequestScalarFieldEnum]


  export const CancellationRequestScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    customerId: 'customerId',
    businessId: 'businessId',
    status: 'status',
    reason: 'reason',
    otherReason: 'otherReason',
    cancellationFee: 'cancellationFee',
    autoProcessed: 'autoProcessed',
    customerNotes: 'customerNotes',
    businessNotes: 'businessNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    reviewedAt: 'reviewedAt',
    reviewedBy: 'reviewedBy',
    cancelledAt: 'cancelledAt'
  };

  export type CancellationRequestScalarFieldEnum = (typeof CancellationRequestScalarFieldEnum)[keyof typeof CancellationRequestScalarFieldEnum]


  export const RefundPolicyScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    name: 'name',
    description: 'description',
    autoApproveTimeline: 'autoApproveTimeline',
    timeLimit: 'timeLimit',
    orderStatusRules: 'orderStatusRules',
    productRules: 'productRules',
    cancellationFees: 'cancellationFees',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RefundPolicyScalarFieldEnum = (typeof RefundPolicyScalarFieldEnum)[keyof typeof RefundPolicyScalarFieldEnum]


  export const SavedPaymentMethodScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    type: 'type',
    provider: 'provider',
    isDefault: 'isDefault',
    nickName: 'nickName',
    cardBrand: 'cardBrand',
    cardLast4: 'cardLast4',
    cardExpMonth: 'cardExpMonth',
    cardExpYear: 'cardExpYear',
    cardHolderName: 'cardHolderName',
    bankName: 'bankName',
    bankAccountLast4: 'bankAccountLast4',
    externalId: 'externalId',
    isActive: 'isActive',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SavedPaymentMethodScalarFieldEnum = (typeof SavedPaymentMethodScalarFieldEnum)[keyof typeof SavedPaymentMethodScalarFieldEnum]


  export const SubscriptionPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    currency: 'currency',
    interval: 'interval',
    intervalCount: 'intervalCount',
    trialPeriodDays: 'trialPeriodDays',
    features: 'features',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    businessId: 'businessId'
  };

  export type SubscriptionPlanScalarFieldEnum = (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    planId: 'planId',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    trialEndDate: 'trialEndDate',
    canceledAt: 'canceledAt',
    pausedAt: 'pausedAt',
    resumeAt: 'resumeAt',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    nextBillingDate: 'nextBillingDate',
    savedPaymentMethodId: 'savedPaymentMethodId',
    quantity: 'quantity',
    autoRenew: 'autoRenew',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    metadata: 'metadata',
    externalId: 'externalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    businessId: 'businessId'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const RecurringPaymentScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    amount: 'amount',
    status: 'status',
    paymentMethod: 'paymentMethod',
    paymentDate: 'paymentDate',
    dueDate: 'dueDate',
    description: 'description',
    externalId: 'externalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecurringPaymentScalarFieldEnum = (typeof RecurringPaymentScalarFieldEnum)[keyof typeof RecurringPaymentScalarFieldEnum]


  export const DashboardMetricScalarFieldEnum: {
    id: 'id',
    metrics: 'metrics',
    lastUpdated: 'lastUpdated'
  };

  export type DashboardMetricScalarFieldEnum = (typeof DashboardMetricScalarFieldEnum)[keyof typeof DashboardMetricScalarFieldEnum]


  export const EmailSettingsScalarFieldEnum: {
    id: 'id',
    settings: 'settings',
    lastUpdated: 'lastUpdated'
  };

  export type EmailSettingsScalarFieldEnum = (typeof EmailSettingsScalarFieldEnum)[keyof typeof EmailSettingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const AdminOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    department: 'department',
    permissions: 'permissions',
    title: 'title',
    phone: 'phone',
    profileImage: 'profileImage',
    ipRestrictions: 'ipRestrictions'
  };

  export type AdminOrderByRelevanceFieldEnum = (typeof AdminOrderByRelevanceFieldEnum)[keyof typeof AdminOrderByRelevanceFieldEnum]


  export const CourierOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    vehicleType: 'vehicleType',
    phone: 'phone',
    zoneId: 'zoneId'
  };

  export type CourierOrderByRelevanceFieldEnum = (typeof CourierOrderByRelevanceFieldEnum)[keyof typeof CourierOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const OrderOrderByRelevanceFieldEnum: {
    id: 'id',
    address: 'address',
    notes: 'notes',
    customerId: 'customerId',
    businessId: 'businessId',
    courierId: 'courierId',
    timeWindowId: 'timeWindowId',
    refundStatus: 'refundStatus',
    cancellationStatus: 'cancellationStatus'
  };

  export type OrderOrderByRelevanceFieldEnum = (typeof OrderOrderByRelevanceFieldEnum)[keyof typeof OrderOrderByRelevanceFieldEnum]


  export const CustomerOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    phone: 'phone',
    address: 'address'
  };

  export type CustomerOrderByRelevanceFieldEnum = (typeof CustomerOrderByRelevanceFieldEnum)[keyof typeof CustomerOrderByRelevanceFieldEnum]


  export const BusinessOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    address: 'address',
    phone: 'phone',
    website: 'website',
    email: 'email',
    logoUrl: 'logoUrl',
    coverUrl: 'coverUrl',
    zoneId: 'zoneId',
    tax_id: 'tax_id',
    bank_iban: 'bank_iban',
    openingTime: 'openingTime',
    closingTime: 'closingTime',
    facebook: 'facebook',
    instagram: 'instagram',
    twitter: 'twitter',
    type: 'type',
    tags: 'tags',
    features: 'features'
  };

  export type BusinessOrderByRelevanceFieldEnum = (typeof BusinessOrderByRelevanceFieldEnum)[keyof typeof BusinessOrderByRelevanceFieldEnum]


  export const ZoneOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type ZoneOrderByRelevanceFieldEnum = (typeof ZoneOrderByRelevanceFieldEnum)[keyof typeof ZoneOrderByRelevanceFieldEnum]


  export const NotificationPreferenceOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    courierId: 'courierId'
  };

  export type NotificationPreferenceOrderByRelevanceFieldEnum = (typeof NotificationPreferenceOrderByRelevanceFieldEnum)[keyof typeof NotificationPreferenceOrderByRelevanceFieldEnum]


  export const NotificationOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    userId: 'userId',
    courierId: 'courierId',
    orderId: 'orderId'
  };

  export type NotificationOrderByRelevanceFieldEnum = (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum]


  export const DeliveryOrderByRelevanceFieldEnum: {
    id: 'id',
    status: 'status',
    courierId: 'courierId',
    customerId: 'customerId',
    zoneId: 'zoneId',
    orderId: 'orderId',
    routeId: 'routeId'
  };

  export type DeliveryOrderByRelevanceFieldEnum = (typeof DeliveryOrderByRelevanceFieldEnum)[keyof typeof DeliveryOrderByRelevanceFieldEnum]


  export const InventoryOrderByRelevanceFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    name: 'name',
    description: 'description',
    sku: 'sku',
    imageUrl: 'imageUrl',
    categoryId: 'categoryId'
  };

  export type InventoryOrderByRelevanceFieldEnum = (typeof InventoryOrderByRelevanceFieldEnum)[keyof typeof InventoryOrderByRelevanceFieldEnum]


  export const DeliveryLogOrderByRelevanceFieldEnum: {
    id: 'id',
    courierId: 'courierId',
    action: 'action',
    note: 'note'
  };

  export type DeliveryLogOrderByRelevanceFieldEnum = (typeof DeliveryLogOrderByRelevanceFieldEnum)[keyof typeof DeliveryLogOrderByRelevanceFieldEnum]


  export const ReportOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    url: 'url'
  };

  export type ReportOrderByRelevanceFieldEnum = (typeof ReportOrderByRelevanceFieldEnum)[keyof typeof ReportOrderByRelevanceFieldEnum]


  export const ScheduleOrderByRelevanceFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime'
  };

  export type ScheduleOrderByRelevanceFieldEnum = (typeof ScheduleOrderByRelevanceFieldEnum)[keyof typeof ScheduleOrderByRelevanceFieldEnum]


  export const ScheduledReportOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    scheduleId: 'scheduleId',
    reportName: 'reportName',
    recipients: 'recipients'
  };

  export type ScheduledReportOrderByRelevanceFieldEnum = (typeof ScheduledReportOrderByRelevanceFieldEnum)[keyof typeof ScheduledReportOrderByRelevanceFieldEnum]


  export const UserSettingsOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    language: 'language',
    theme: 'theme'
  };

  export type UserSettingsOrderByRelevanceFieldEnum = (typeof UserSettingsOrderByRelevanceFieldEnum)[keyof typeof UserSettingsOrderByRelevanceFieldEnum]


  export const MenuItemOrderByRelevanceFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    category: 'category',
    tags: 'tags',
    ingredients: 'ingredients'
  };

  export type MenuItemOrderByRelevanceFieldEnum = (typeof MenuItemOrderByRelevanceFieldEnum)[keyof typeof MenuItemOrderByRelevanceFieldEnum]


  export const CourierAvailabilityOrderByRelevanceFieldEnum: {
    id: 'id',
    courierId: 'courierId',
    note: 'note'
  };

  export type CourierAvailabilityOrderByRelevanceFieldEnum = (typeof CourierAvailabilityOrderByRelevanceFieldEnum)[keyof typeof CourierAvailabilityOrderByRelevanceFieldEnum]


  export const DeliveryTimeWindowOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    startTime: 'startTime',
    endTime: 'endTime',
    description: 'description'
  };

  export type DeliveryTimeWindowOrderByRelevanceFieldEnum = (typeof DeliveryTimeWindowOrderByRelevanceFieldEnum)[keyof typeof DeliveryTimeWindowOrderByRelevanceFieldEnum]


  export const DeliveryRouteOrderByRelevanceFieldEnum: {
    id: 'id',
    courierId: 'courierId',
    name: 'name'
  };

  export type DeliveryRouteOrderByRelevanceFieldEnum = (typeof DeliveryRouteOrderByRelevanceFieldEnum)[keyof typeof DeliveryRouteOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    id: 'id',
    currency: 'currency',
    reference: 'reference',
    description: 'description',
    orderId: 'orderId',
    recipientId: 'recipientId',
    businessId: 'businessId'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const ProductCategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    name: 'name',
    description: 'description',
    slug: 'slug',
    imageUrl: 'imageUrl',
    parentId: 'parentId'
  };

  export type ProductCategoryOrderByRelevanceFieldEnum = (typeof ProductCategoryOrderByRelevanceFieldEnum)[keyof typeof ProductCategoryOrderByRelevanceFieldEnum]


  export const ActivityLogOrderByRelevanceFieldEnum: {
    id: 'id',
    action: 'action',
    description: 'description',
    userId: 'userId',
    targetId: 'targetId',
    targetType: 'targetType',
    ip: 'ip',
    userAgent: 'userAgent',
    adminId: 'adminId',
    severity: 'severity',
    category: 'category',
    resolvedBy: 'resolvedBy'
  };

  export type ActivityLogOrderByRelevanceFieldEnum = (typeof ActivityLogOrderByRelevanceFieldEnum)[keyof typeof ActivityLogOrderByRelevanceFieldEnum]


  export const SystemActionOrderByRelevanceFieldEnum: {
    id: 'id',
    action: 'action',
    description: 'description',
    adminId: 'adminId',
    status: 'status',
    error: 'error'
  };

  export type SystemActionOrderByRelevanceFieldEnum = (typeof SystemActionOrderByRelevanceFieldEnum)[keyof typeof SystemActionOrderByRelevanceFieldEnum]


  export const SystemSettingsOrderByRelevanceFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    category: 'category',
    description: 'description',
    dataType: 'dataType',
    updatedBy: 'updatedBy'
  };

  export type SystemSettingsOrderByRelevanceFieldEnum = (typeof SystemSettingsOrderByRelevanceFieldEnum)[keyof typeof SystemSettingsOrderByRelevanceFieldEnum]


  export const AdminDashboardWidgetOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    size: 'size',
    adminId: 'adminId'
  };

  export type AdminDashboardWidgetOrderByRelevanceFieldEnum = (typeof AdminDashboardWidgetOrderByRelevanceFieldEnum)[keyof typeof AdminDashboardWidgetOrderByRelevanceFieldEnum]


  export const AdminPermissionOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type AdminPermissionOrderByRelevanceFieldEnum = (typeof AdminPermissionOrderByRelevanceFieldEnum)[keyof typeof AdminPermissionOrderByRelevanceFieldEnum]


  export const AdminRoleOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type AdminRoleOrderByRelevanceFieldEnum = (typeof AdminRoleOrderByRelevanceFieldEnum)[keyof typeof AdminRoleOrderByRelevanceFieldEnum]


  export const AdminRoleMappingOrderByRelevanceFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    roleId: 'roleId'
  };

  export type AdminRoleMappingOrderByRelevanceFieldEnum = (typeof AdminRoleMappingOrderByRelevanceFieldEnum)[keyof typeof AdminRoleMappingOrderByRelevanceFieldEnum]


  export const EmailTemplateOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    body: 'body',
    category: 'category',
    description: 'description',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type EmailTemplateOrderByRelevanceFieldEnum = (typeof EmailTemplateOrderByRelevanceFieldEnum)[keyof typeof EmailTemplateOrderByRelevanceFieldEnum]


  export const SentEmailOrderByRelevanceFieldEnum: {
    id: 'id',
    templateId: 'templateId',
    recipient: 'recipient',
    subject: 'subject',
    variables: 'variables',
    messageId: 'messageId',
    sentBy: 'sentBy',
    status: 'status',
    category: 'category'
  };

  export type SentEmailOrderByRelevanceFieldEnum = (typeof SentEmailOrderByRelevanceFieldEnum)[keyof typeof SentEmailOrderByRelevanceFieldEnum]


  export const CustomerAddressOrderByRelevanceFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    title: 'title',
    firstName: 'firstName',
    lastName: 'lastName',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    phone: 'phone',
    notes: 'notes'
  };

  export type CustomerAddressOrderByRelevanceFieldEnum = (typeof CustomerAddressOrderByRelevanceFieldEnum)[keyof typeof CustomerAddressOrderByRelevanceFieldEnum]


  export const RefundRequestOrderByRelevanceFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    customerId: 'customerId',
    businessId: 'businessId',
    otherReason: 'otherReason',
    evidenceUrls: 'evidenceUrls',
    adminNotes: 'adminNotes',
    customerNotes: 'customerNotes',
    businessNotes: 'businessNotes',
    reviewedBy: 'reviewedBy'
  };

  export type RefundRequestOrderByRelevanceFieldEnum = (typeof RefundRequestOrderByRelevanceFieldEnum)[keyof typeof RefundRequestOrderByRelevanceFieldEnum]


  export const CancellationRequestOrderByRelevanceFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    customerId: 'customerId',
    businessId: 'businessId',
    otherReason: 'otherReason',
    customerNotes: 'customerNotes',
    businessNotes: 'businessNotes',
    reviewedBy: 'reviewedBy'
  };

  export type CancellationRequestOrderByRelevanceFieldEnum = (typeof CancellationRequestOrderByRelevanceFieldEnum)[keyof typeof CancellationRequestOrderByRelevanceFieldEnum]


  export const RefundPolicyOrderByRelevanceFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    name: 'name',
    description: 'description'
  };

  export type RefundPolicyOrderByRelevanceFieldEnum = (typeof RefundPolicyOrderByRelevanceFieldEnum)[keyof typeof RefundPolicyOrderByRelevanceFieldEnum]


  export const SavedPaymentMethodOrderByRelevanceFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    nickName: 'nickName',
    cardLast4: 'cardLast4',
    cardHolderName: 'cardHolderName',
    bankName: 'bankName',
    bankAccountLast4: 'bankAccountLast4',
    externalId: 'externalId'
  };

  export type SavedPaymentMethodOrderByRelevanceFieldEnum = (typeof SavedPaymentMethodOrderByRelevanceFieldEnum)[keyof typeof SavedPaymentMethodOrderByRelevanceFieldEnum]


  export const SubscriptionPlanOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    currency: 'currency',
    businessId: 'businessId'
  };

  export type SubscriptionPlanOrderByRelevanceFieldEnum = (typeof SubscriptionPlanOrderByRelevanceFieldEnum)[keyof typeof SubscriptionPlanOrderByRelevanceFieldEnum]


  export const SubscriptionOrderByRelevanceFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    planId: 'planId',
    savedPaymentMethodId: 'savedPaymentMethodId',
    externalId: 'externalId',
    businessId: 'businessId'
  };

  export type SubscriptionOrderByRelevanceFieldEnum = (typeof SubscriptionOrderByRelevanceFieldEnum)[keyof typeof SubscriptionOrderByRelevanceFieldEnum]


  export const RecurringPaymentOrderByRelevanceFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    description: 'description',
    externalId: 'externalId'
  };

  export type RecurringPaymentOrderByRelevanceFieldEnum = (typeof RecurringPaymentOrderByRelevanceFieldEnum)[keyof typeof RecurringPaymentOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CourierAvailabilityStatus'
   */
  export type EnumCourierAvailabilityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourierAvailabilityStatus'>
    


  /**
   * Reference to a field of type 'CourierAvailabilityStatus[]'
   */
  export type ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourierAvailabilityStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DeliveryPriority'
   */
  export type EnumDeliveryPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryPriority'>
    


  /**
   * Reference to a field of type 'DeliveryPriority[]'
   */
  export type ListEnumDeliveryPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryPriority[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationChannel'
   */
  export type EnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel'>
    


  /**
   * Reference to a field of type 'NotificationChannel[]'
   */
  export type ListEnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel[]'>
    


  /**
   * Reference to a field of type 'NotificationFrequency'
   */
  export type EnumNotificationFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationFrequency'>
    


  /**
   * Reference to a field of type 'NotificationFrequency[]'
   */
  export type ListEnumNotificationFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationFrequency[]'>
    


  /**
   * Reference to a field of type 'ReportType'
   */
  export type EnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType'>
    


  /**
   * Reference to a field of type 'ReportType[]'
   */
  export type ListEnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType[]'>
    


  /**
   * Reference to a field of type 'ReportFormat'
   */
  export type EnumReportFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportFormat'>
    


  /**
   * Reference to a field of type 'ReportFormat[]'
   */
  export type ListEnumReportFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportFormat[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'RefundRequestStatus'
   */
  export type EnumRefundRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundRequestStatus'>
    


  /**
   * Reference to a field of type 'RefundRequestStatus[]'
   */
  export type ListEnumRefundRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundRequestStatus[]'>
    


  /**
   * Reference to a field of type 'RefundReason'
   */
  export type EnumRefundReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundReason'>
    


  /**
   * Reference to a field of type 'RefundReason[]'
   */
  export type ListEnumRefundReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundReason[]'>
    


  /**
   * Reference to a field of type 'CancellationRequestStatus'
   */
  export type EnumCancellationRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CancellationRequestStatus'>
    


  /**
   * Reference to a field of type 'CancellationRequestStatus[]'
   */
  export type ListEnumCancellationRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CancellationRequestStatus[]'>
    


  /**
   * Reference to a field of type 'CancellationReason'
   */
  export type EnumCancellationReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CancellationReason'>
    


  /**
   * Reference to a field of type 'CancellationReason[]'
   */
  export type ListEnumCancellationReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CancellationReason[]'>
    


  /**
   * Reference to a field of type 'PaymentProvider'
   */
  export type EnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider'>
    


  /**
   * Reference to a field of type 'PaymentProvider[]'
   */
  export type ListEnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider[]'>
    


  /**
   * Reference to a field of type 'CardBrand'
   */
  export type EnumCardBrandFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CardBrand'>
    


  /**
   * Reference to a field of type 'CardBrand[]'
   */
  export type ListEnumCardBrandFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CardBrand[]'>
    


  /**
   * Reference to a field of type 'SubscriptionInterval'
   */
  export type EnumSubscriptionIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionInterval'>
    


  /**
   * Reference to a field of type 'SubscriptionInterval[]'
   */
  export type ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionInterval[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    courier?: XOR<CourierNullableScalarRelationFilter, CourierWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    notifications?: NotificationListRelationFilter
    notificationPreferences?: NotificationPreferenceListRelationFilter
    reports?: ReportListRelationFilter
    scheduledReports?: ScheduledReportListRelationFilter
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    activityLogs?: ActivityLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    business?: BusinessOrderByWithRelationInput
    courier?: CourierOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    notificationPreferences?: NotificationPreferenceOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    scheduledReports?: ScheduledReportOrderByRelationAggregateInput
    settings?: UserSettingsOrderByWithRelationInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    courier?: XOR<CourierNullableScalarRelationFilter, CourierWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    notifications?: NotificationListRelationFilter
    notificationPreferences?: NotificationPreferenceListRelationFilter
    reports?: ReportListRelationFilter
    scheduledReports?: ScheduledReportListRelationFilter
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    activityLogs?: ActivityLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    department?: StringNullableFilter<"Admin"> | string | null
    level?: IntFilter<"Admin"> | number
    permissions?: StringNullableListFilter<"Admin">
    title?: StringNullableFilter<"Admin"> | string | null
    phone?: StringNullableFilter<"Admin"> | string | null
    profileImage?: StringNullableFilter<"Admin"> | string | null
    lastLogin?: DateTimeNullableFilter<"Admin"> | Date | string | null
    loginAttempts?: IntFilter<"Admin"> | number
    isSuperAdmin?: BoolFilter<"Admin"> | boolean
    ipRestrictions?: StringNullableListFilter<"Admin">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    activityLogs?: ActivityLogListRelationFilter
    systemActions?: SystemActionListRelationFilter
    dashboardWidgets?: AdminDashboardWidgetListRelationFilter
    roleMappings?: AdminRoleMappingListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrderInput | SortOrder
    level?: SortOrder
    permissions?: SortOrder
    title?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    loginAttempts?: SortOrder
    isSuperAdmin?: SortOrder
    ipRestrictions?: SortOrder
    user?: UserOrderByWithRelationInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    systemActions?: SystemActionOrderByRelationAggregateInput
    dashboardWidgets?: AdminDashboardWidgetOrderByRelationAggregateInput
    roleMappings?: AdminRoleMappingOrderByRelationAggregateInput
    _relevance?: AdminOrderByRelevanceInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    department?: StringNullableFilter<"Admin"> | string | null
    level?: IntFilter<"Admin"> | number
    permissions?: StringNullableListFilter<"Admin">
    title?: StringNullableFilter<"Admin"> | string | null
    phone?: StringNullableFilter<"Admin"> | string | null
    profileImage?: StringNullableFilter<"Admin"> | string | null
    lastLogin?: DateTimeNullableFilter<"Admin"> | Date | string | null
    loginAttempts?: IntFilter<"Admin"> | number
    isSuperAdmin?: BoolFilter<"Admin"> | boolean
    ipRestrictions?: StringNullableListFilter<"Admin">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    activityLogs?: ActivityLogListRelationFilter
    systemActions?: SystemActionListRelationFilter
    dashboardWidgets?: AdminDashboardWidgetListRelationFilter
    roleMappings?: AdminRoleMappingListRelationFilter
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrderInput | SortOrder
    level?: SortOrder
    permissions?: SortOrder
    title?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    loginAttempts?: SortOrder
    isSuperAdmin?: SortOrder
    ipRestrictions?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    userId?: StringWithAggregatesFilter<"Admin"> | string
    department?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    level?: IntWithAggregatesFilter<"Admin"> | number
    permissions?: StringNullableListFilter<"Admin">
    title?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    profileImage?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    lastLogin?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    loginAttempts?: IntWithAggregatesFilter<"Admin"> | number
    isSuperAdmin?: BoolWithAggregatesFilter<"Admin"> | boolean
    ipRestrictions?: StringNullableListFilter<"Admin">
  }

  export type CourierWhereInput = {
    AND?: CourierWhereInput | CourierWhereInput[]
    OR?: CourierWhereInput[]
    NOT?: CourierWhereInput | CourierWhereInput[]
    id?: StringFilter<"Courier"> | string
    userId?: StringFilter<"Courier"> | string
    status?: EnumStatusFilter<"Courier"> | $Enums.Status
    vehicleType?: StringNullableFilter<"Courier"> | string | null
    phone?: StringNullableFilter<"Courier"> | string | null
    zoneId?: StringNullableFilter<"Courier"> | string | null
    ratings?: FloatNullableFilter<"Courier"> | number | null
    currentLatitude?: FloatNullableFilter<"Courier"> | number | null
    currentLongitude?: FloatNullableFilter<"Courier"> | number | null
    lastLocationUpdate?: DateTimeNullableFilter<"Courier"> | Date | string | null
    availableFrom?: DateTimeNullableFilter<"Courier"> | Date | string | null
    availableTo?: DateTimeNullableFilter<"Courier"> | Date | string | null
    documentsVerified?: BoolFilter<"Courier"> | boolean
    backgroundChecked?: BoolFilter<"Courier"> | boolean
    maxDeliveriesPerDay?: IntFilter<"Courier"> | number
    maxDistance?: FloatNullableFilter<"Courier"> | number | null
    averageSpeed?: FloatNullableFilter<"Courier"> | number | null
    courierFee?: FloatNullableFilter<"Courier"> | number | null
    lastSeen?: DateTimeNullableFilter<"Courier"> | Date | string | null
    availabilityStatus?: EnumCourierAvailabilityStatusNullableFilter<"Courier"> | $Enums.CourierAvailabilityStatus | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    zone?: XOR<ZoneNullableScalarRelationFilter, ZoneWhereInput> | null
    orders?: OrderListRelationFilter
    notifications?: NotificationListRelationFilter
    notificationPreferences?: NotificationPreferenceListRelationFilter
    deliveryLogs?: DeliveryLogListRelationFilter
    deliveries?: DeliveryListRelationFilter
    payments?: PaymentListRelationFilter
    availability?: CourierAvailabilityListRelationFilter
    deliveryRoutes?: DeliveryRouteListRelationFilter
  }

  export type CourierOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    vehicleType?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    zoneId?: SortOrderInput | SortOrder
    ratings?: SortOrderInput | SortOrder
    currentLatitude?: SortOrderInput | SortOrder
    currentLongitude?: SortOrderInput | SortOrder
    lastLocationUpdate?: SortOrderInput | SortOrder
    availableFrom?: SortOrderInput | SortOrder
    availableTo?: SortOrderInput | SortOrder
    documentsVerified?: SortOrder
    backgroundChecked?: SortOrder
    maxDeliveriesPerDay?: SortOrder
    maxDistance?: SortOrderInput | SortOrder
    averageSpeed?: SortOrderInput | SortOrder
    courierFee?: SortOrderInput | SortOrder
    lastSeen?: SortOrderInput | SortOrder
    availabilityStatus?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    notificationPreferences?: NotificationPreferenceOrderByRelationAggregateInput
    deliveryLogs?: DeliveryLogOrderByRelationAggregateInput
    deliveries?: DeliveryOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    availability?: CourierAvailabilityOrderByRelationAggregateInput
    deliveryRoutes?: DeliveryRouteOrderByRelationAggregateInput
    _relevance?: CourierOrderByRelevanceInput
  }

  export type CourierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CourierWhereInput | CourierWhereInput[]
    OR?: CourierWhereInput[]
    NOT?: CourierWhereInput | CourierWhereInput[]
    status?: EnumStatusFilter<"Courier"> | $Enums.Status
    vehicleType?: StringNullableFilter<"Courier"> | string | null
    phone?: StringNullableFilter<"Courier"> | string | null
    zoneId?: StringNullableFilter<"Courier"> | string | null
    ratings?: FloatNullableFilter<"Courier"> | number | null
    currentLatitude?: FloatNullableFilter<"Courier"> | number | null
    currentLongitude?: FloatNullableFilter<"Courier"> | number | null
    lastLocationUpdate?: DateTimeNullableFilter<"Courier"> | Date | string | null
    availableFrom?: DateTimeNullableFilter<"Courier"> | Date | string | null
    availableTo?: DateTimeNullableFilter<"Courier"> | Date | string | null
    documentsVerified?: BoolFilter<"Courier"> | boolean
    backgroundChecked?: BoolFilter<"Courier"> | boolean
    maxDeliveriesPerDay?: IntFilter<"Courier"> | number
    maxDistance?: FloatNullableFilter<"Courier"> | number | null
    averageSpeed?: FloatNullableFilter<"Courier"> | number | null
    courierFee?: FloatNullableFilter<"Courier"> | number | null
    lastSeen?: DateTimeNullableFilter<"Courier"> | Date | string | null
    availabilityStatus?: EnumCourierAvailabilityStatusNullableFilter<"Courier"> | $Enums.CourierAvailabilityStatus | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    zone?: XOR<ZoneNullableScalarRelationFilter, ZoneWhereInput> | null
    orders?: OrderListRelationFilter
    notifications?: NotificationListRelationFilter
    notificationPreferences?: NotificationPreferenceListRelationFilter
    deliveryLogs?: DeliveryLogListRelationFilter
    deliveries?: DeliveryListRelationFilter
    payments?: PaymentListRelationFilter
    availability?: CourierAvailabilityListRelationFilter
    deliveryRoutes?: DeliveryRouteListRelationFilter
  }, "id" | "userId">

  export type CourierOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    vehicleType?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    zoneId?: SortOrderInput | SortOrder
    ratings?: SortOrderInput | SortOrder
    currentLatitude?: SortOrderInput | SortOrder
    currentLongitude?: SortOrderInput | SortOrder
    lastLocationUpdate?: SortOrderInput | SortOrder
    availableFrom?: SortOrderInput | SortOrder
    availableTo?: SortOrderInput | SortOrder
    documentsVerified?: SortOrder
    backgroundChecked?: SortOrder
    maxDeliveriesPerDay?: SortOrder
    maxDistance?: SortOrderInput | SortOrder
    averageSpeed?: SortOrderInput | SortOrder
    courierFee?: SortOrderInput | SortOrder
    lastSeen?: SortOrderInput | SortOrder
    availabilityStatus?: SortOrderInput | SortOrder
    _count?: CourierCountOrderByAggregateInput
    _avg?: CourierAvgOrderByAggregateInput
    _max?: CourierMaxOrderByAggregateInput
    _min?: CourierMinOrderByAggregateInput
    _sum?: CourierSumOrderByAggregateInput
  }

  export type CourierScalarWhereWithAggregatesInput = {
    AND?: CourierScalarWhereWithAggregatesInput | CourierScalarWhereWithAggregatesInput[]
    OR?: CourierScalarWhereWithAggregatesInput[]
    NOT?: CourierScalarWhereWithAggregatesInput | CourierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Courier"> | string
    userId?: StringWithAggregatesFilter<"Courier"> | string
    status?: EnumStatusWithAggregatesFilter<"Courier"> | $Enums.Status
    vehicleType?: StringNullableWithAggregatesFilter<"Courier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Courier"> | string | null
    zoneId?: StringNullableWithAggregatesFilter<"Courier"> | string | null
    ratings?: FloatNullableWithAggregatesFilter<"Courier"> | number | null
    currentLatitude?: FloatNullableWithAggregatesFilter<"Courier"> | number | null
    currentLongitude?: FloatNullableWithAggregatesFilter<"Courier"> | number | null
    lastLocationUpdate?: DateTimeNullableWithAggregatesFilter<"Courier"> | Date | string | null
    availableFrom?: DateTimeNullableWithAggregatesFilter<"Courier"> | Date | string | null
    availableTo?: DateTimeNullableWithAggregatesFilter<"Courier"> | Date | string | null
    documentsVerified?: BoolWithAggregatesFilter<"Courier"> | boolean
    backgroundChecked?: BoolWithAggregatesFilter<"Courier"> | boolean
    maxDeliveriesPerDay?: IntWithAggregatesFilter<"Courier"> | number
    maxDistance?: FloatNullableWithAggregatesFilter<"Courier"> | number | null
    averageSpeed?: FloatNullableWithAggregatesFilter<"Courier"> | number | null
    courierFee?: FloatNullableWithAggregatesFilter<"Courier"> | number | null
    lastSeen?: DateTimeNullableWithAggregatesFilter<"Courier"> | Date | string | null
    availabilityStatus?: EnumCourierAvailabilityStatusNullableWithAggregatesFilter<"Courier"> | $Enums.CourierAvailabilityStatus | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    status?: EnumStatusFilter<"Order"> | $Enums.Status
    totalPrice?: FloatFilter<"Order"> | number
    items?: JsonFilter<"Order">
    address?: StringFilter<"Order"> | string
    notes?: StringNullableFilter<"Order"> | string | null
    estimatedDelivery?: DateTimeNullableFilter<"Order"> | Date | string | null
    actualDelivery?: DateTimeNullableFilter<"Order"> | Date | string | null
    latitude?: FloatNullableFilter<"Order"> | number | null
    longitude?: FloatNullableFilter<"Order"> | number | null
    customerId?: StringFilter<"Order"> | string
    businessId?: StringFilter<"Order"> | string
    courierId?: StringNullableFilter<"Order"> | string | null
    priority?: EnumDeliveryPriorityFilter<"Order"> | $Enums.DeliveryPriority
    timeWindowId?: StringNullableFilter<"Order"> | string | null
    estimatedDuration?: IntNullableFilter<"Order"> | number | null
    estimatedDistance?: FloatNullableFilter<"Order"> | number | null
    sequenceNumber?: IntNullableFilter<"Order"> | number | null
    refundStatus?: StringNullableFilter<"Order"> | string | null
    cancellationStatus?: StringNullableFilter<"Order"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    courier?: XOR<CourierNullableScalarRelationFilter, CourierWhereInput> | null
    notifications?: NotificationListRelationFilter
    payments?: PaymentListRelationFilter
    requestedTimeWindow?: XOR<DeliveryTimeWindowNullableScalarRelationFilter, DeliveryTimeWindowWhereInput> | null
    delivery?: XOR<DeliveryNullableScalarRelationFilter, DeliveryWhereInput> | null
    refundRequests?: RefundRequestListRelationFilter
    cancellationRequests?: CancellationRequestListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    items?: SortOrder
    address?: SortOrder
    notes?: SortOrderInput | SortOrder
    estimatedDelivery?: SortOrderInput | SortOrder
    actualDelivery?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    courierId?: SortOrderInput | SortOrder
    priority?: SortOrder
    timeWindowId?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    estimatedDistance?: SortOrderInput | SortOrder
    sequenceNumber?: SortOrderInput | SortOrder
    refundStatus?: SortOrderInput | SortOrder
    cancellationStatus?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    business?: BusinessOrderByWithRelationInput
    courier?: CourierOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    requestedTimeWindow?: DeliveryTimeWindowOrderByWithRelationInput
    delivery?: DeliveryOrderByWithRelationInput
    refundRequests?: RefundRequestOrderByRelationAggregateInput
    cancellationRequests?: CancellationRequestOrderByRelationAggregateInput
    _relevance?: OrderOrderByRelevanceInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    status?: EnumStatusFilter<"Order"> | $Enums.Status
    totalPrice?: FloatFilter<"Order"> | number
    items?: JsonFilter<"Order">
    address?: StringFilter<"Order"> | string
    notes?: StringNullableFilter<"Order"> | string | null
    estimatedDelivery?: DateTimeNullableFilter<"Order"> | Date | string | null
    actualDelivery?: DateTimeNullableFilter<"Order"> | Date | string | null
    latitude?: FloatNullableFilter<"Order"> | number | null
    longitude?: FloatNullableFilter<"Order"> | number | null
    customerId?: StringFilter<"Order"> | string
    businessId?: StringFilter<"Order"> | string
    courierId?: StringNullableFilter<"Order"> | string | null
    priority?: EnumDeliveryPriorityFilter<"Order"> | $Enums.DeliveryPriority
    timeWindowId?: StringNullableFilter<"Order"> | string | null
    estimatedDuration?: IntNullableFilter<"Order"> | number | null
    estimatedDistance?: FloatNullableFilter<"Order"> | number | null
    sequenceNumber?: IntNullableFilter<"Order"> | number | null
    refundStatus?: StringNullableFilter<"Order"> | string | null
    cancellationStatus?: StringNullableFilter<"Order"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    courier?: XOR<CourierNullableScalarRelationFilter, CourierWhereInput> | null
    notifications?: NotificationListRelationFilter
    payments?: PaymentListRelationFilter
    requestedTimeWindow?: XOR<DeliveryTimeWindowNullableScalarRelationFilter, DeliveryTimeWindowWhereInput> | null
    delivery?: XOR<DeliveryNullableScalarRelationFilter, DeliveryWhereInput> | null
    refundRequests?: RefundRequestListRelationFilter
    cancellationRequests?: CancellationRequestListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    items?: SortOrder
    address?: SortOrder
    notes?: SortOrderInput | SortOrder
    estimatedDelivery?: SortOrderInput | SortOrder
    actualDelivery?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    courierId?: SortOrderInput | SortOrder
    priority?: SortOrder
    timeWindowId?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    estimatedDistance?: SortOrderInput | SortOrder
    sequenceNumber?: SortOrderInput | SortOrder
    refundStatus?: SortOrderInput | SortOrder
    cancellationStatus?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    status?: EnumStatusWithAggregatesFilter<"Order"> | $Enums.Status
    totalPrice?: FloatWithAggregatesFilter<"Order"> | number
    items?: JsonWithAggregatesFilter<"Order">
    address?: StringWithAggregatesFilter<"Order"> | string
    notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    estimatedDelivery?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    actualDelivery?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    customerId?: StringWithAggregatesFilter<"Order"> | string
    businessId?: StringWithAggregatesFilter<"Order"> | string
    courierId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    priority?: EnumDeliveryPriorityWithAggregatesFilter<"Order"> | $Enums.DeliveryPriority
    timeWindowId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    estimatedDuration?: IntNullableWithAggregatesFilter<"Order"> | number | null
    estimatedDistance?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    sequenceNumber?: IntNullableWithAggregatesFilter<"Order"> | number | null
    refundStatus?: StringNullableWithAggregatesFilter<"Order"> | string | null
    cancellationStatus?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    userId?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    latitude?: FloatNullableFilter<"Customer"> | number | null
    longitude?: FloatNullableFilter<"Customer"> | number | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
    deliveries?: DeliveryListRelationFilter
    addresses?: CustomerAddressListRelationFilter
    refundRequests?: RefundRequestListRelationFilter
    cancellationRequests?: CancellationRequestListRelationFilter
    savedPaymentMethods?: SavedPaymentMethodListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    deliveries?: DeliveryOrderByRelationAggregateInput
    addresses?: CustomerAddressOrderByRelationAggregateInput
    refundRequests?: RefundRequestOrderByRelationAggregateInput
    cancellationRequests?: CancellationRequestOrderByRelationAggregateInput
    savedPaymentMethods?: SavedPaymentMethodOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    _relevance?: CustomerOrderByRelevanceInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    latitude?: FloatNullableFilter<"Customer"> | number | null
    longitude?: FloatNullableFilter<"Customer"> | number | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
    deliveries?: DeliveryListRelationFilter
    addresses?: CustomerAddressListRelationFilter
    refundRequests?: RefundRequestListRelationFilter
    cancellationRequests?: CancellationRequestListRelationFilter
    savedPaymentMethods?: SavedPaymentMethodListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
  }, "id" | "userId">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    userId?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Customer"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Customer"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type BusinessWhereInput = {
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    id?: StringFilter<"Business"> | string
    userId?: StringFilter<"Business"> | string
    name?: StringFilter<"Business"> | string
    description?: StringNullableFilter<"Business"> | string | null
    address?: StringNullableFilter<"Business"> | string | null
    phone?: StringNullableFilter<"Business"> | string | null
    website?: StringNullableFilter<"Business"> | string | null
    email?: StringNullableFilter<"Business"> | string | null
    logoUrl?: StringNullableFilter<"Business"> | string | null
    coverUrl?: StringNullableFilter<"Business"> | string | null
    latitude?: FloatNullableFilter<"Business"> | number | null
    longitude?: FloatNullableFilter<"Business"> | number | null
    zoneId?: StringNullableFilter<"Business"> | string | null
    status?: EnumStatusFilter<"Business"> | $Enums.Status
    rating?: FloatNullableFilter<"Business"> | number | null
    tax_id?: StringNullableFilter<"Business"> | string | null
    bank_iban?: StringNullableFilter<"Business"> | string | null
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    openingTime?: StringNullableFilter<"Business"> | string | null
    closingTime?: StringNullableFilter<"Business"> | string | null
    deliveryRadius?: FloatNullableFilter<"Business"> | number | null
    deliveryFee?: FloatNullableFilter<"Business"> | number | null
    facebook?: StringNullableFilter<"Business"> | string | null
    instagram?: StringNullableFilter<"Business"> | string | null
    twitter?: StringNullableFilter<"Business"> | string | null
    type?: StringNullableFilter<"Business"> | string | null
    tags?: StringNullableListFilter<"Business">
    features?: StringNullableListFilter<"Business">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    zone?: XOR<ZoneNullableScalarRelationFilter, ZoneWhereInput> | null
    inventory?: InventoryListRelationFilter
    orders?: OrderListRelationFilter
    menuItems?: MenuItemListRelationFilter
    productCategories?: ProductCategoryListRelationFilter
    payments?: PaymentListRelationFilter
    refundPolicies?: RefundPolicyListRelationFilter
    refundRequests?: RefundRequestListRelationFilter
    cancellationRequests?: CancellationRequestListRelationFilter
    subscriptionPlans?: SubscriptionPlanListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
  }

  export type BusinessOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    zoneId?: SortOrderInput | SortOrder
    status?: SortOrder
    rating?: SortOrderInput | SortOrder
    tax_id?: SortOrderInput | SortOrder
    bank_iban?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    openingTime?: SortOrderInput | SortOrder
    closingTime?: SortOrderInput | SortOrder
    deliveryRadius?: SortOrderInput | SortOrder
    deliveryFee?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    tags?: SortOrder
    features?: SortOrder
    user?: UserOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
    inventory?: InventoryOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    menuItems?: MenuItemOrderByRelationAggregateInput
    productCategories?: ProductCategoryOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    refundPolicies?: RefundPolicyOrderByRelationAggregateInput
    refundRequests?: RefundRequestOrderByRelationAggregateInput
    cancellationRequests?: CancellationRequestOrderByRelationAggregateInput
    subscriptionPlans?: SubscriptionPlanOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    _relevance?: BusinessOrderByRelevanceInput
  }

  export type BusinessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    name?: StringFilter<"Business"> | string
    description?: StringNullableFilter<"Business"> | string | null
    address?: StringNullableFilter<"Business"> | string | null
    phone?: StringNullableFilter<"Business"> | string | null
    website?: StringNullableFilter<"Business"> | string | null
    email?: StringNullableFilter<"Business"> | string | null
    logoUrl?: StringNullableFilter<"Business"> | string | null
    coverUrl?: StringNullableFilter<"Business"> | string | null
    latitude?: FloatNullableFilter<"Business"> | number | null
    longitude?: FloatNullableFilter<"Business"> | number | null
    zoneId?: StringNullableFilter<"Business"> | string | null
    status?: EnumStatusFilter<"Business"> | $Enums.Status
    rating?: FloatNullableFilter<"Business"> | number | null
    tax_id?: StringNullableFilter<"Business"> | string | null
    bank_iban?: StringNullableFilter<"Business"> | string | null
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    openingTime?: StringNullableFilter<"Business"> | string | null
    closingTime?: StringNullableFilter<"Business"> | string | null
    deliveryRadius?: FloatNullableFilter<"Business"> | number | null
    deliveryFee?: FloatNullableFilter<"Business"> | number | null
    facebook?: StringNullableFilter<"Business"> | string | null
    instagram?: StringNullableFilter<"Business"> | string | null
    twitter?: StringNullableFilter<"Business"> | string | null
    type?: StringNullableFilter<"Business"> | string | null
    tags?: StringNullableListFilter<"Business">
    features?: StringNullableListFilter<"Business">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    zone?: XOR<ZoneNullableScalarRelationFilter, ZoneWhereInput> | null
    inventory?: InventoryListRelationFilter
    orders?: OrderListRelationFilter
    menuItems?: MenuItemListRelationFilter
    productCategories?: ProductCategoryListRelationFilter
    payments?: PaymentListRelationFilter
    refundPolicies?: RefundPolicyListRelationFilter
    refundRequests?: RefundRequestListRelationFilter
    cancellationRequests?: CancellationRequestListRelationFilter
    subscriptionPlans?: SubscriptionPlanListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
  }, "id" | "userId">

  export type BusinessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    zoneId?: SortOrderInput | SortOrder
    status?: SortOrder
    rating?: SortOrderInput | SortOrder
    tax_id?: SortOrderInput | SortOrder
    bank_iban?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    openingTime?: SortOrderInput | SortOrder
    closingTime?: SortOrderInput | SortOrder
    deliveryRadius?: SortOrderInput | SortOrder
    deliveryFee?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    tags?: SortOrder
    features?: SortOrder
    _count?: BusinessCountOrderByAggregateInput
    _avg?: BusinessAvgOrderByAggregateInput
    _max?: BusinessMaxOrderByAggregateInput
    _min?: BusinessMinOrderByAggregateInput
    _sum?: BusinessSumOrderByAggregateInput
  }

  export type BusinessScalarWhereWithAggregatesInput = {
    AND?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    OR?: BusinessScalarWhereWithAggregatesInput[]
    NOT?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Business"> | string
    userId?: StringWithAggregatesFilter<"Business"> | string
    name?: StringWithAggregatesFilter<"Business"> | string
    description?: StringNullableWithAggregatesFilter<"Business"> | string | null
    address?: StringNullableWithAggregatesFilter<"Business"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Business"> | string | null
    website?: StringNullableWithAggregatesFilter<"Business"> | string | null
    email?: StringNullableWithAggregatesFilter<"Business"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Business"> | string | null
    coverUrl?: StringNullableWithAggregatesFilter<"Business"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Business"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Business"> | number | null
    zoneId?: StringNullableWithAggregatesFilter<"Business"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Business"> | $Enums.Status
    rating?: FloatNullableWithAggregatesFilter<"Business"> | number | null
    tax_id?: StringNullableWithAggregatesFilter<"Business"> | string | null
    bank_iban?: StringNullableWithAggregatesFilter<"Business"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Business"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Business"> | Date | string
    openingTime?: StringNullableWithAggregatesFilter<"Business"> | string | null
    closingTime?: StringNullableWithAggregatesFilter<"Business"> | string | null
    deliveryRadius?: FloatNullableWithAggregatesFilter<"Business"> | number | null
    deliveryFee?: FloatNullableWithAggregatesFilter<"Business"> | number | null
    facebook?: StringNullableWithAggregatesFilter<"Business"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"Business"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"Business"> | string | null
    type?: StringNullableWithAggregatesFilter<"Business"> | string | null
    tags?: StringNullableListFilter<"Business">
    features?: StringNullableListFilter<"Business">
  }

  export type ZoneWhereInput = {
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    id?: StringFilter<"Zone"> | string
    name?: StringFilter<"Zone"> | string
    description?: StringNullableFilter<"Zone"> | string | null
    coordinates?: JsonFilter<"Zone">
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    averageDeliveryTime?: IntNullableFilter<"Zone"> | number | null
    orderVolume?: IntNullableFilter<"Zone"> | number | null
    activeBusinesses?: IntNullableFilter<"Zone"> | number | null
    businesses?: BusinessListRelationFilter
    couriers?: CourierListRelationFilter
    deliveries?: DeliveryListRelationFilter
  }

  export type ZoneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    coordinates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    averageDeliveryTime?: SortOrderInput | SortOrder
    orderVolume?: SortOrderInput | SortOrder
    activeBusinesses?: SortOrderInput | SortOrder
    businesses?: BusinessOrderByRelationAggregateInput
    couriers?: CourierOrderByRelationAggregateInput
    deliveries?: DeliveryOrderByRelationAggregateInput
    _relevance?: ZoneOrderByRelevanceInput
  }

  export type ZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    name?: StringFilter<"Zone"> | string
    description?: StringNullableFilter<"Zone"> | string | null
    coordinates?: JsonFilter<"Zone">
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    averageDeliveryTime?: IntNullableFilter<"Zone"> | number | null
    orderVolume?: IntNullableFilter<"Zone"> | number | null
    activeBusinesses?: IntNullableFilter<"Zone"> | number | null
    businesses?: BusinessListRelationFilter
    couriers?: CourierListRelationFilter
    deliveries?: DeliveryListRelationFilter
  }, "id">

  export type ZoneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    coordinates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    averageDeliveryTime?: SortOrderInput | SortOrder
    orderVolume?: SortOrderInput | SortOrder
    activeBusinesses?: SortOrderInput | SortOrder
    _count?: ZoneCountOrderByAggregateInput
    _avg?: ZoneAvgOrderByAggregateInput
    _max?: ZoneMaxOrderByAggregateInput
    _min?: ZoneMinOrderByAggregateInput
    _sum?: ZoneSumOrderByAggregateInput
  }

  export type ZoneScalarWhereWithAggregatesInput = {
    AND?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    OR?: ZoneScalarWhereWithAggregatesInput[]
    NOT?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Zone"> | string
    name?: StringWithAggregatesFilter<"Zone"> | string
    description?: StringNullableWithAggregatesFilter<"Zone"> | string | null
    coordinates?: JsonWithAggregatesFilter<"Zone">
    createdAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
    averageDeliveryTime?: IntNullableWithAggregatesFilter<"Zone"> | number | null
    orderVolume?: IntNullableWithAggregatesFilter<"Zone"> | number | null
    activeBusinesses?: IntNullableWithAggregatesFilter<"Zone"> | number | null
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    userId?: StringFilter<"NotificationPreference"> | string
    courierId?: StringNullableFilter<"NotificationPreference"> | string | null
    type?: EnumNotificationTypeFilter<"NotificationPreference"> | $Enums.NotificationType
    channel?: EnumNotificationChannelFilter<"NotificationPreference"> | $Enums.NotificationChannel
    frequency?: EnumNotificationFrequencyFilter<"NotificationPreference"> | $Enums.NotificationFrequency
    enabled?: BoolFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    courier?: XOR<CourierNullableScalarRelationFilter, CourierWhereInput> | null
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courierId?: SortOrderInput | SortOrder
    type?: SortOrder
    channel?: SortOrder
    frequency?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    courier?: CourierOrderByWithRelationInput
    _relevance?: NotificationPreferenceOrderByRelevanceInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_type_channel?: NotificationPreferenceUserIdTypeChannelCompoundUniqueInput
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    userId?: StringFilter<"NotificationPreference"> | string
    courierId?: StringNullableFilter<"NotificationPreference"> | string | null
    type?: EnumNotificationTypeFilter<"NotificationPreference"> | $Enums.NotificationType
    channel?: EnumNotificationChannelFilter<"NotificationPreference"> | $Enums.NotificationChannel
    frequency?: EnumNotificationFrequencyFilter<"NotificationPreference"> | $Enums.NotificationFrequency
    enabled?: BoolFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    courier?: XOR<CourierNullableScalarRelationFilter, CourierWhereInput> | null
  }, "id" | "userId_type_channel">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courierId?: SortOrderInput | SortOrder
    type?: SortOrder
    channel?: SortOrder
    frequency?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPreference"> | string
    userId?: StringWithAggregatesFilter<"NotificationPreference"> | string
    courierId?: StringNullableWithAggregatesFilter<"NotificationPreference"> | string | null
    type?: EnumNotificationTypeWithAggregatesFilter<"NotificationPreference"> | $Enums.NotificationType
    channel?: EnumNotificationChannelWithAggregatesFilter<"NotificationPreference"> | $Enums.NotificationChannel
    frequency?: EnumNotificationFrequencyWithAggregatesFilter<"NotificationPreference"> | $Enums.NotificationFrequency
    enabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
    courierId?: StringNullableFilter<"Notification"> | string | null
    orderId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    courier?: XOR<CourierNullableScalarRelationFilter, CourierWhereInput> | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    courierId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    courier?: CourierOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    _relevance?: NotificationOrderByRelevanceInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
    courierId?: StringNullableFilter<"Notification"> | string | null
    orderId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    courier?: XOR<CourierNullableScalarRelationFilter, CourierWhereInput> | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    courierId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    courierId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
  }

  export type DeliveryWhereInput = {
    AND?: DeliveryWhereInput | DeliveryWhereInput[]
    OR?: DeliveryWhereInput[]
    NOT?: DeliveryWhereInput | DeliveryWhereInput[]
    id?: StringFilter<"Delivery"> | string
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
    status?: StringFilter<"Delivery"> | string
    courierId?: StringFilter<"Delivery"> | string
    customerId?: StringFilter<"Delivery"> | string
    zoneId?: StringFilter<"Delivery"> | string
    orderId?: StringNullableFilter<"Delivery"> | string | null
    assignedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    pickedUpAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    estimatedPickupTime?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    estimatedDeliveryTime?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    duration?: IntNullableFilter<"Delivery"> | number | null
    actualDuration?: IntNullableFilter<"Delivery"> | number | null
    distance?: FloatNullableFilter<"Delivery"> | number | null
    actualDistance?: FloatNullableFilter<"Delivery"> | number | null
    pickupLatitude?: FloatNullableFilter<"Delivery"> | number | null
    pickupLongitude?: FloatNullableFilter<"Delivery"> | number | null
    dropoffLatitude?: FloatNullableFilter<"Delivery"> | number | null
    dropoffLongitude?: FloatNullableFilter<"Delivery"> | number | null
    routeId?: StringNullableFilter<"Delivery"> | string | null
    sequenceNumber?: IntNullableFilter<"Delivery"> | number | null
    priority?: EnumDeliveryPriorityFilter<"Delivery"> | $Enums.DeliveryPriority
    courier?: XOR<CourierScalarRelationFilter, CourierWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    route?: XOR<DeliveryRouteNullableScalarRelationFilter, DeliveryRouteWhereInput> | null
  }

  export type DeliveryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    courierId?: SortOrder
    customerId?: SortOrder
    zoneId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    pickedUpAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    estimatedPickupTime?: SortOrderInput | SortOrder
    estimatedDeliveryTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    actualDuration?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    actualDistance?: SortOrderInput | SortOrder
    pickupLatitude?: SortOrderInput | SortOrder
    pickupLongitude?: SortOrderInput | SortOrder
    dropoffLatitude?: SortOrderInput | SortOrder
    dropoffLongitude?: SortOrderInput | SortOrder
    routeId?: SortOrderInput | SortOrder
    sequenceNumber?: SortOrderInput | SortOrder
    priority?: SortOrder
    courier?: CourierOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    route?: DeliveryRouteOrderByWithRelationInput
    _relevance?: DeliveryOrderByRelevanceInput
  }

  export type DeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: DeliveryWhereInput | DeliveryWhereInput[]
    OR?: DeliveryWhereInput[]
    NOT?: DeliveryWhereInput | DeliveryWhereInput[]
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
    status?: StringFilter<"Delivery"> | string
    courierId?: StringFilter<"Delivery"> | string
    customerId?: StringFilter<"Delivery"> | string
    zoneId?: StringFilter<"Delivery"> | string
    assignedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    pickedUpAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    estimatedPickupTime?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    estimatedDeliveryTime?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    duration?: IntNullableFilter<"Delivery"> | number | null
    actualDuration?: IntNullableFilter<"Delivery"> | number | null
    distance?: FloatNullableFilter<"Delivery"> | number | null
    actualDistance?: FloatNullableFilter<"Delivery"> | number | null
    pickupLatitude?: FloatNullableFilter<"Delivery"> | number | null
    pickupLongitude?: FloatNullableFilter<"Delivery"> | number | null
    dropoffLatitude?: FloatNullableFilter<"Delivery"> | number | null
    dropoffLongitude?: FloatNullableFilter<"Delivery"> | number | null
    routeId?: StringNullableFilter<"Delivery"> | string | null
    sequenceNumber?: IntNullableFilter<"Delivery"> | number | null
    priority?: EnumDeliveryPriorityFilter<"Delivery"> | $Enums.DeliveryPriority
    courier?: XOR<CourierScalarRelationFilter, CourierWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    route?: XOR<DeliveryRouteNullableScalarRelationFilter, DeliveryRouteWhereInput> | null
  }, "id" | "orderId">

  export type DeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    courierId?: SortOrder
    customerId?: SortOrder
    zoneId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    pickedUpAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    estimatedPickupTime?: SortOrderInput | SortOrder
    estimatedDeliveryTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    actualDuration?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    actualDistance?: SortOrderInput | SortOrder
    pickupLatitude?: SortOrderInput | SortOrder
    pickupLongitude?: SortOrderInput | SortOrder
    dropoffLatitude?: SortOrderInput | SortOrder
    dropoffLongitude?: SortOrderInput | SortOrder
    routeId?: SortOrderInput | SortOrder
    sequenceNumber?: SortOrderInput | SortOrder
    priority?: SortOrder
    _count?: DeliveryCountOrderByAggregateInput
    _avg?: DeliveryAvgOrderByAggregateInput
    _max?: DeliveryMaxOrderByAggregateInput
    _min?: DeliveryMinOrderByAggregateInput
    _sum?: DeliverySumOrderByAggregateInput
  }

  export type DeliveryScalarWhereWithAggregatesInput = {
    AND?: DeliveryScalarWhereWithAggregatesInput | DeliveryScalarWhereWithAggregatesInput[]
    OR?: DeliveryScalarWhereWithAggregatesInput[]
    NOT?: DeliveryScalarWhereWithAggregatesInput | DeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Delivery"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Delivery"> | Date | string
    status?: StringWithAggregatesFilter<"Delivery"> | string
    courierId?: StringWithAggregatesFilter<"Delivery"> | string
    customerId?: StringWithAggregatesFilter<"Delivery"> | string
    zoneId?: StringWithAggregatesFilter<"Delivery"> | string
    orderId?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    assignedAt?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    pickedUpAt?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    estimatedPickupTime?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    estimatedDeliveryTime?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"Delivery"> | number | null
    actualDuration?: IntNullableWithAggregatesFilter<"Delivery"> | number | null
    distance?: FloatNullableWithAggregatesFilter<"Delivery"> | number | null
    actualDistance?: FloatNullableWithAggregatesFilter<"Delivery"> | number | null
    pickupLatitude?: FloatNullableWithAggregatesFilter<"Delivery"> | number | null
    pickupLongitude?: FloatNullableWithAggregatesFilter<"Delivery"> | number | null
    dropoffLatitude?: FloatNullableWithAggregatesFilter<"Delivery"> | number | null
    dropoffLongitude?: FloatNullableWithAggregatesFilter<"Delivery"> | number | null
    routeId?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    sequenceNumber?: IntNullableWithAggregatesFilter<"Delivery"> | number | null
    priority?: EnumDeliveryPriorityWithAggregatesFilter<"Delivery"> | $Enums.DeliveryPriority
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: StringFilter<"Inventory"> | string
    businessId?: StringFilter<"Inventory"> | string
    name?: StringFilter<"Inventory"> | string
    description?: StringNullableFilter<"Inventory"> | string | null
    quantity?: IntFilter<"Inventory"> | number
    price?: FloatFilter<"Inventory"> | number
    sku?: StringNullableFilter<"Inventory"> | string | null
    imageUrl?: StringNullableFilter<"Inventory"> | string | null
    isActive?: BoolFilter<"Inventory"> | boolean
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    categoryId?: StringNullableFilter<"Inventory"> | string | null
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    category?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrder
    sku?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    business?: BusinessOrderByWithRelationInput
    category?: ProductCategoryOrderByWithRelationInput
    _relevance?: InventoryOrderByRelevanceInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    businessId?: StringFilter<"Inventory"> | string
    name?: StringFilter<"Inventory"> | string
    description?: StringNullableFilter<"Inventory"> | string | null
    quantity?: IntFilter<"Inventory"> | number
    price?: FloatFilter<"Inventory"> | number
    sku?: StringNullableFilter<"Inventory"> | string | null
    imageUrl?: StringNullableFilter<"Inventory"> | string | null
    isActive?: BoolFilter<"Inventory"> | boolean
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    categoryId?: StringNullableFilter<"Inventory"> | string | null
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    category?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
  }, "id">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrder
    sku?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inventory"> | string
    businessId?: StringWithAggregatesFilter<"Inventory"> | string
    name?: StringWithAggregatesFilter<"Inventory"> | string
    description?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    quantity?: IntWithAggregatesFilter<"Inventory"> | number
    price?: FloatWithAggregatesFilter<"Inventory"> | number
    sku?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    isActive?: BoolWithAggregatesFilter<"Inventory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    categoryId?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
  }

  export type DeliveryLogWhereInput = {
    AND?: DeliveryLogWhereInput | DeliveryLogWhereInput[]
    OR?: DeliveryLogWhereInput[]
    NOT?: DeliveryLogWhereInput | DeliveryLogWhereInput[]
    id?: StringFilter<"DeliveryLog"> | string
    courierId?: StringFilter<"DeliveryLog"> | string
    action?: StringFilter<"DeliveryLog"> | string
    timestamp?: DateTimeFilter<"DeliveryLog"> | Date | string
    latitude?: FloatNullableFilter<"DeliveryLog"> | number | null
    longitude?: FloatNullableFilter<"DeliveryLog"> | number | null
    note?: StringNullableFilter<"DeliveryLog"> | string | null
    metadata?: JsonNullableFilter<"DeliveryLog">
    courier?: XOR<CourierScalarRelationFilter, CourierWhereInput>
  }

  export type DeliveryLogOrderByWithRelationInput = {
    id?: SortOrder
    courierId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    courier?: CourierOrderByWithRelationInput
    _relevance?: DeliveryLogOrderByRelevanceInput
  }

  export type DeliveryLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryLogWhereInput | DeliveryLogWhereInput[]
    OR?: DeliveryLogWhereInput[]
    NOT?: DeliveryLogWhereInput | DeliveryLogWhereInput[]
    courierId?: StringFilter<"DeliveryLog"> | string
    action?: StringFilter<"DeliveryLog"> | string
    timestamp?: DateTimeFilter<"DeliveryLog"> | Date | string
    latitude?: FloatNullableFilter<"DeliveryLog"> | number | null
    longitude?: FloatNullableFilter<"DeliveryLog"> | number | null
    note?: StringNullableFilter<"DeliveryLog"> | string | null
    metadata?: JsonNullableFilter<"DeliveryLog">
    courier?: XOR<CourierScalarRelationFilter, CourierWhereInput>
  }, "id">

  export type DeliveryLogOrderByWithAggregationInput = {
    id?: SortOrder
    courierId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: DeliveryLogCountOrderByAggregateInput
    _avg?: DeliveryLogAvgOrderByAggregateInput
    _max?: DeliveryLogMaxOrderByAggregateInput
    _min?: DeliveryLogMinOrderByAggregateInput
    _sum?: DeliveryLogSumOrderByAggregateInput
  }

  export type DeliveryLogScalarWhereWithAggregatesInput = {
    AND?: DeliveryLogScalarWhereWithAggregatesInput | DeliveryLogScalarWhereWithAggregatesInput[]
    OR?: DeliveryLogScalarWhereWithAggregatesInput[]
    NOT?: DeliveryLogScalarWhereWithAggregatesInput | DeliveryLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryLog"> | string
    courierId?: StringWithAggregatesFilter<"DeliveryLog"> | string
    action?: StringWithAggregatesFilter<"DeliveryLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"DeliveryLog"> | Date | string
    latitude?: FloatNullableWithAggregatesFilter<"DeliveryLog"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"DeliveryLog"> | number | null
    note?: StringNullableWithAggregatesFilter<"DeliveryLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"DeliveryLog">
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    userId?: StringFilter<"Report"> | string
    name?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    format?: EnumReportFormatFilter<"Report"> | $Enums.ReportFormat
    parameters?: JsonNullableFilter<"Report">
    createdAt?: DateTimeFilter<"Report"> | Date | string
    data?: JsonNullableFilter<"Report">
    url?: StringNullableFilter<"Report"> | string | null
    expiresAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    format?: SortOrder
    parameters?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    data?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: ReportOrderByRelevanceInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    userId?: StringFilter<"Report"> | string
    name?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    format?: EnumReportFormatFilter<"Report"> | $Enums.ReportFormat
    parameters?: JsonNullableFilter<"Report">
    createdAt?: DateTimeFilter<"Report"> | Date | string
    data?: JsonNullableFilter<"Report">
    url?: StringNullableFilter<"Report"> | string | null
    expiresAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    format?: SortOrder
    parameters?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    data?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    userId?: StringWithAggregatesFilter<"Report"> | string
    name?: StringWithAggregatesFilter<"Report"> | string
    type?: EnumReportTypeWithAggregatesFilter<"Report"> | $Enums.ReportType
    format?: EnumReportFormatWithAggregatesFilter<"Report"> | $Enums.ReportFormat
    parameters?: JsonNullableWithAggregatesFilter<"Report">
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    data?: JsonNullableWithAggregatesFilter<"Report">
    url?: StringNullableWithAggregatesFilter<"Report"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: StringFilter<"Schedule"> | string
    dayOfWeek?: IntFilter<"Schedule"> | number
    startTime?: StringFilter<"Schedule"> | string
    endTime?: StringFilter<"Schedule"> | string
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    reports?: ScheduledReportListRelationFilter
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reports?: ScheduledReportOrderByRelationAggregateInput
    _relevance?: ScheduleOrderByRelevanceInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    dayOfWeek?: IntFilter<"Schedule"> | number
    startTime?: StringFilter<"Schedule"> | string
    endTime?: StringFilter<"Schedule"> | string
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    reports?: ScheduledReportListRelationFilter
  }, "id">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _avg?: ScheduleAvgOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
    _sum?: ScheduleSumOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Schedule"> | string
    dayOfWeek?: IntWithAggregatesFilter<"Schedule"> | number
    startTime?: StringWithAggregatesFilter<"Schedule"> | string
    endTime?: StringWithAggregatesFilter<"Schedule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
  }

  export type ScheduledReportWhereInput = {
    AND?: ScheduledReportWhereInput | ScheduledReportWhereInput[]
    OR?: ScheduledReportWhereInput[]
    NOT?: ScheduledReportWhereInput | ScheduledReportWhereInput[]
    id?: StringFilter<"ScheduledReport"> | string
    userId?: StringFilter<"ScheduledReport"> | string
    scheduleId?: StringFilter<"ScheduledReport"> | string
    reportName?: StringFilter<"ScheduledReport"> | string
    type?: EnumReportTypeFilter<"ScheduledReport"> | $Enums.ReportType
    format?: EnumReportFormatFilter<"ScheduledReport"> | $Enums.ReportFormat
    parameters?: JsonNullableFilter<"ScheduledReport">
    enabled?: BoolFilter<"ScheduledReport"> | boolean
    recipients?: StringNullableListFilter<"ScheduledReport">
    nextRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    createdAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    schedule?: XOR<ScheduleScalarRelationFilter, ScheduleWhereInput>
  }

  export type ScheduledReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    reportName?: SortOrder
    type?: SortOrder
    format?: SortOrder
    parameters?: SortOrderInput | SortOrder
    enabled?: SortOrder
    recipients?: SortOrder
    nextRunAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    schedule?: ScheduleOrderByWithRelationInput
    _relevance?: ScheduledReportOrderByRelevanceInput
  }

  export type ScheduledReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledReportWhereInput | ScheduledReportWhereInput[]
    OR?: ScheduledReportWhereInput[]
    NOT?: ScheduledReportWhereInput | ScheduledReportWhereInput[]
    userId?: StringFilter<"ScheduledReport"> | string
    scheduleId?: StringFilter<"ScheduledReport"> | string
    reportName?: StringFilter<"ScheduledReport"> | string
    type?: EnumReportTypeFilter<"ScheduledReport"> | $Enums.ReportType
    format?: EnumReportFormatFilter<"ScheduledReport"> | $Enums.ReportFormat
    parameters?: JsonNullableFilter<"ScheduledReport">
    enabled?: BoolFilter<"ScheduledReport"> | boolean
    recipients?: StringNullableListFilter<"ScheduledReport">
    nextRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    createdAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    schedule?: XOR<ScheduleScalarRelationFilter, ScheduleWhereInput>
  }, "id">

  export type ScheduledReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    reportName?: SortOrder
    type?: SortOrder
    format?: SortOrder
    parameters?: SortOrderInput | SortOrder
    enabled?: SortOrder
    recipients?: SortOrder
    nextRunAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduledReportCountOrderByAggregateInput
    _max?: ScheduledReportMaxOrderByAggregateInput
    _min?: ScheduledReportMinOrderByAggregateInput
  }

  export type ScheduledReportScalarWhereWithAggregatesInput = {
    AND?: ScheduledReportScalarWhereWithAggregatesInput | ScheduledReportScalarWhereWithAggregatesInput[]
    OR?: ScheduledReportScalarWhereWithAggregatesInput[]
    NOT?: ScheduledReportScalarWhereWithAggregatesInput | ScheduledReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledReport"> | string
    userId?: StringWithAggregatesFilter<"ScheduledReport"> | string
    scheduleId?: StringWithAggregatesFilter<"ScheduledReport"> | string
    reportName?: StringWithAggregatesFilter<"ScheduledReport"> | string
    type?: EnumReportTypeWithAggregatesFilter<"ScheduledReport"> | $Enums.ReportType
    format?: EnumReportFormatWithAggregatesFilter<"ScheduledReport"> | $Enums.ReportFormat
    parameters?: JsonNullableWithAggregatesFilter<"ScheduledReport">
    enabled?: BoolWithAggregatesFilter<"ScheduledReport"> | boolean
    recipients?: StringNullableListFilter<"ScheduledReport">
    nextRunAt?: DateTimeNullableWithAggregatesFilter<"ScheduledReport"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduledReport"> | Date | string
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    id?: StringFilter<"UserSettings"> | string
    userId?: StringFilter<"UserSettings"> | string
    language?: StringFilter<"UserSettings"> | string
    theme?: StringFilter<"UserSettings"> | string
    notifications?: BoolFilter<"UserSettings"> | boolean
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    notifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: UserSettingsOrderByRelevanceInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    language?: StringFilter<"UserSettings"> | string
    theme?: StringFilter<"UserSettings"> | string
    notifications?: BoolFilter<"UserSettings"> | boolean
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    notifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSettings"> | string
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    language?: StringWithAggregatesFilter<"UserSettings"> | string
    theme?: StringWithAggregatesFilter<"UserSettings"> | string
    notifications?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
  }

  export type MenuItemWhereInput = {
    AND?: MenuItemWhereInput | MenuItemWhereInput[]
    OR?: MenuItemWhereInput[]
    NOT?: MenuItemWhereInput | MenuItemWhereInput[]
    id?: StringFilter<"MenuItem"> | string
    businessId?: StringFilter<"MenuItem"> | string
    name?: StringFilter<"MenuItem"> | string
    description?: StringNullableFilter<"MenuItem"> | string | null
    price?: FloatFilter<"MenuItem"> | number
    imageUrl?: StringNullableFilter<"MenuItem"> | string | null
    category?: StringNullableFilter<"MenuItem"> | string | null
    tags?: StringNullableListFilter<"MenuItem">
    ingredients?: StringNullableListFilter<"MenuItem">
    calories?: IntNullableFilter<"MenuItem"> | number | null
    isActive?: BoolFilter<"MenuItem"> | boolean
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
  }

  export type MenuItemOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    ingredients?: SortOrder
    calories?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
    _relevance?: MenuItemOrderByRelevanceInput
  }

  export type MenuItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MenuItemWhereInput | MenuItemWhereInput[]
    OR?: MenuItemWhereInput[]
    NOT?: MenuItemWhereInput | MenuItemWhereInput[]
    businessId?: StringFilter<"MenuItem"> | string
    name?: StringFilter<"MenuItem"> | string
    description?: StringNullableFilter<"MenuItem"> | string | null
    price?: FloatFilter<"MenuItem"> | number
    imageUrl?: StringNullableFilter<"MenuItem"> | string | null
    category?: StringNullableFilter<"MenuItem"> | string | null
    tags?: StringNullableListFilter<"MenuItem">
    ingredients?: StringNullableListFilter<"MenuItem">
    calories?: IntNullableFilter<"MenuItem"> | number | null
    isActive?: BoolFilter<"MenuItem"> | boolean
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
  }, "id">

  export type MenuItemOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    ingredients?: SortOrder
    calories?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuItemCountOrderByAggregateInput
    _avg?: MenuItemAvgOrderByAggregateInput
    _max?: MenuItemMaxOrderByAggregateInput
    _min?: MenuItemMinOrderByAggregateInput
    _sum?: MenuItemSumOrderByAggregateInput
  }

  export type MenuItemScalarWhereWithAggregatesInput = {
    AND?: MenuItemScalarWhereWithAggregatesInput | MenuItemScalarWhereWithAggregatesInput[]
    OR?: MenuItemScalarWhereWithAggregatesInput[]
    NOT?: MenuItemScalarWhereWithAggregatesInput | MenuItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MenuItem"> | string
    businessId?: StringWithAggregatesFilter<"MenuItem"> | string
    name?: StringWithAggregatesFilter<"MenuItem"> | string
    description?: StringNullableWithAggregatesFilter<"MenuItem"> | string | null
    price?: FloatWithAggregatesFilter<"MenuItem"> | number
    imageUrl?: StringNullableWithAggregatesFilter<"MenuItem"> | string | null
    category?: StringNullableWithAggregatesFilter<"MenuItem"> | string | null
    tags?: StringNullableListFilter<"MenuItem">
    ingredients?: StringNullableListFilter<"MenuItem">
    calories?: IntNullableWithAggregatesFilter<"MenuItem"> | number | null
    isActive?: BoolWithAggregatesFilter<"MenuItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MenuItem"> | Date | string
  }

  export type CourierAvailabilityWhereInput = {
    AND?: CourierAvailabilityWhereInput | CourierAvailabilityWhereInput[]
    OR?: CourierAvailabilityWhereInput[]
    NOT?: CourierAvailabilityWhereInput | CourierAvailabilityWhereInput[]
    id?: StringFilter<"CourierAvailability"> | string
    courierId?: StringFilter<"CourierAvailability"> | string
    status?: EnumCourierAvailabilityStatusFilter<"CourierAvailability"> | $Enums.CourierAvailabilityStatus
    startTime?: DateTimeFilter<"CourierAvailability"> | Date | string
    endTime?: DateTimeNullableFilter<"CourierAvailability"> | Date | string | null
    note?: StringNullableFilter<"CourierAvailability"> | string | null
    createdAt?: DateTimeFilter<"CourierAvailability"> | Date | string
    courier?: XOR<CourierScalarRelationFilter, CourierWhereInput>
  }

  export type CourierAvailabilityOrderByWithRelationInput = {
    id?: SortOrder
    courierId?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    courier?: CourierOrderByWithRelationInput
    _relevance?: CourierAvailabilityOrderByRelevanceInput
  }

  export type CourierAvailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourierAvailabilityWhereInput | CourierAvailabilityWhereInput[]
    OR?: CourierAvailabilityWhereInput[]
    NOT?: CourierAvailabilityWhereInput | CourierAvailabilityWhereInput[]
    courierId?: StringFilter<"CourierAvailability"> | string
    status?: EnumCourierAvailabilityStatusFilter<"CourierAvailability"> | $Enums.CourierAvailabilityStatus
    startTime?: DateTimeFilter<"CourierAvailability"> | Date | string
    endTime?: DateTimeNullableFilter<"CourierAvailability"> | Date | string | null
    note?: StringNullableFilter<"CourierAvailability"> | string | null
    createdAt?: DateTimeFilter<"CourierAvailability"> | Date | string
    courier?: XOR<CourierScalarRelationFilter, CourierWhereInput>
  }, "id">

  export type CourierAvailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    courierId?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CourierAvailabilityCountOrderByAggregateInput
    _max?: CourierAvailabilityMaxOrderByAggregateInput
    _min?: CourierAvailabilityMinOrderByAggregateInput
  }

  export type CourierAvailabilityScalarWhereWithAggregatesInput = {
    AND?: CourierAvailabilityScalarWhereWithAggregatesInput | CourierAvailabilityScalarWhereWithAggregatesInput[]
    OR?: CourierAvailabilityScalarWhereWithAggregatesInput[]
    NOT?: CourierAvailabilityScalarWhereWithAggregatesInput | CourierAvailabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourierAvailability"> | string
    courierId?: StringWithAggregatesFilter<"CourierAvailability"> | string
    status?: EnumCourierAvailabilityStatusWithAggregatesFilter<"CourierAvailability"> | $Enums.CourierAvailabilityStatus
    startTime?: DateTimeWithAggregatesFilter<"CourierAvailability"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"CourierAvailability"> | Date | string | null
    note?: StringNullableWithAggregatesFilter<"CourierAvailability"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CourierAvailability"> | Date | string
  }

  export type DeliveryTimeWindowWhereInput = {
    AND?: DeliveryTimeWindowWhereInput | DeliveryTimeWindowWhereInput[]
    OR?: DeliveryTimeWindowWhereInput[]
    NOT?: DeliveryTimeWindowWhereInput | DeliveryTimeWindowWhereInput[]
    id?: StringFilter<"DeliveryTimeWindow"> | string
    name?: StringFilter<"DeliveryTimeWindow"> | string
    startTime?: StringFilter<"DeliveryTimeWindow"> | string
    endTime?: StringFilter<"DeliveryTimeWindow"> | string
    description?: StringNullableFilter<"DeliveryTimeWindow"> | string | null
    priorityFactor?: FloatFilter<"DeliveryTimeWindow"> | number
    orders?: OrderListRelationFilter
  }

  export type DeliveryTimeWindowOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    description?: SortOrderInput | SortOrder
    priorityFactor?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
    _relevance?: DeliveryTimeWindowOrderByRelevanceInput
  }

  export type DeliveryTimeWindowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryTimeWindowWhereInput | DeliveryTimeWindowWhereInput[]
    OR?: DeliveryTimeWindowWhereInput[]
    NOT?: DeliveryTimeWindowWhereInput | DeliveryTimeWindowWhereInput[]
    name?: StringFilter<"DeliveryTimeWindow"> | string
    startTime?: StringFilter<"DeliveryTimeWindow"> | string
    endTime?: StringFilter<"DeliveryTimeWindow"> | string
    description?: StringNullableFilter<"DeliveryTimeWindow"> | string | null
    priorityFactor?: FloatFilter<"DeliveryTimeWindow"> | number
    orders?: OrderListRelationFilter
  }, "id">

  export type DeliveryTimeWindowOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    description?: SortOrderInput | SortOrder
    priorityFactor?: SortOrder
    _count?: DeliveryTimeWindowCountOrderByAggregateInput
    _avg?: DeliveryTimeWindowAvgOrderByAggregateInput
    _max?: DeliveryTimeWindowMaxOrderByAggregateInput
    _min?: DeliveryTimeWindowMinOrderByAggregateInput
    _sum?: DeliveryTimeWindowSumOrderByAggregateInput
  }

  export type DeliveryTimeWindowScalarWhereWithAggregatesInput = {
    AND?: DeliveryTimeWindowScalarWhereWithAggregatesInput | DeliveryTimeWindowScalarWhereWithAggregatesInput[]
    OR?: DeliveryTimeWindowScalarWhereWithAggregatesInput[]
    NOT?: DeliveryTimeWindowScalarWhereWithAggregatesInput | DeliveryTimeWindowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryTimeWindow"> | string
    name?: StringWithAggregatesFilter<"DeliveryTimeWindow"> | string
    startTime?: StringWithAggregatesFilter<"DeliveryTimeWindow"> | string
    endTime?: StringWithAggregatesFilter<"DeliveryTimeWindow"> | string
    description?: StringNullableWithAggregatesFilter<"DeliveryTimeWindow"> | string | null
    priorityFactor?: FloatWithAggregatesFilter<"DeliveryTimeWindow"> | number
  }

  export type DeliveryRouteWhereInput = {
    AND?: DeliveryRouteWhereInput | DeliveryRouteWhereInput[]
    OR?: DeliveryRouteWhereInput[]
    NOT?: DeliveryRouteWhereInput | DeliveryRouteWhereInput[]
    id?: StringFilter<"DeliveryRoute"> | string
    courierId?: StringFilter<"DeliveryRoute"> | string
    name?: StringNullableFilter<"DeliveryRoute"> | string | null
    createdAt?: DateTimeFilter<"DeliveryRoute"> | Date | string
    startedAt?: DateTimeNullableFilter<"DeliveryRoute"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DeliveryRoute"> | Date | string | null
    status?: EnumStatusFilter<"DeliveryRoute"> | $Enums.Status
    totalDistance?: FloatNullableFilter<"DeliveryRoute"> | number | null
    totalDuration?: IntNullableFilter<"DeliveryRoute"> | number | null
    startLatitude?: FloatNullableFilter<"DeliveryRoute"> | number | null
    startLongitude?: FloatNullableFilter<"DeliveryRoute"> | number | null
    endLatitude?: FloatNullableFilter<"DeliveryRoute"> | number | null
    endLongitude?: FloatNullableFilter<"DeliveryRoute"> | number | null
    routePath?: JsonNullableFilter<"DeliveryRoute">
    courier?: XOR<CourierScalarRelationFilter, CourierWhereInput>
    deliveries?: DeliveryListRelationFilter
  }

  export type DeliveryRouteOrderByWithRelationInput = {
    id?: SortOrder
    courierId?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    totalDistance?: SortOrderInput | SortOrder
    totalDuration?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    routePath?: SortOrderInput | SortOrder
    courier?: CourierOrderByWithRelationInput
    deliveries?: DeliveryOrderByRelationAggregateInput
    _relevance?: DeliveryRouteOrderByRelevanceInput
  }

  export type DeliveryRouteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryRouteWhereInput | DeliveryRouteWhereInput[]
    OR?: DeliveryRouteWhereInput[]
    NOT?: DeliveryRouteWhereInput | DeliveryRouteWhereInput[]
    courierId?: StringFilter<"DeliveryRoute"> | string
    name?: StringNullableFilter<"DeliveryRoute"> | string | null
    createdAt?: DateTimeFilter<"DeliveryRoute"> | Date | string
    startedAt?: DateTimeNullableFilter<"DeliveryRoute"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DeliveryRoute"> | Date | string | null
    status?: EnumStatusFilter<"DeliveryRoute"> | $Enums.Status
    totalDistance?: FloatNullableFilter<"DeliveryRoute"> | number | null
    totalDuration?: IntNullableFilter<"DeliveryRoute"> | number | null
    startLatitude?: FloatNullableFilter<"DeliveryRoute"> | number | null
    startLongitude?: FloatNullableFilter<"DeliveryRoute"> | number | null
    endLatitude?: FloatNullableFilter<"DeliveryRoute"> | number | null
    endLongitude?: FloatNullableFilter<"DeliveryRoute"> | number | null
    routePath?: JsonNullableFilter<"DeliveryRoute">
    courier?: XOR<CourierScalarRelationFilter, CourierWhereInput>
    deliveries?: DeliveryListRelationFilter
  }, "id">

  export type DeliveryRouteOrderByWithAggregationInput = {
    id?: SortOrder
    courierId?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    totalDistance?: SortOrderInput | SortOrder
    totalDuration?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    routePath?: SortOrderInput | SortOrder
    _count?: DeliveryRouteCountOrderByAggregateInput
    _avg?: DeliveryRouteAvgOrderByAggregateInput
    _max?: DeliveryRouteMaxOrderByAggregateInput
    _min?: DeliveryRouteMinOrderByAggregateInput
    _sum?: DeliveryRouteSumOrderByAggregateInput
  }

  export type DeliveryRouteScalarWhereWithAggregatesInput = {
    AND?: DeliveryRouteScalarWhereWithAggregatesInput | DeliveryRouteScalarWhereWithAggregatesInput[]
    OR?: DeliveryRouteScalarWhereWithAggregatesInput[]
    NOT?: DeliveryRouteScalarWhereWithAggregatesInput | DeliveryRouteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryRoute"> | string
    courierId?: StringWithAggregatesFilter<"DeliveryRoute"> | string
    name?: StringNullableWithAggregatesFilter<"DeliveryRoute"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryRoute"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"DeliveryRoute"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"DeliveryRoute"> | Date | string | null
    status?: EnumStatusWithAggregatesFilter<"DeliveryRoute"> | $Enums.Status
    totalDistance?: FloatNullableWithAggregatesFilter<"DeliveryRoute"> | number | null
    totalDuration?: IntNullableWithAggregatesFilter<"DeliveryRoute"> | number | null
    startLatitude?: FloatNullableWithAggregatesFilter<"DeliveryRoute"> | number | null
    startLongitude?: FloatNullableWithAggregatesFilter<"DeliveryRoute"> | number | null
    endLatitude?: FloatNullableWithAggregatesFilter<"DeliveryRoute"> | number | null
    endLongitude?: FloatNullableWithAggregatesFilter<"DeliveryRoute"> | number | null
    routePath?: JsonNullableWithAggregatesFilter<"DeliveryRoute">
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    reference?: StringNullableFilter<"Payment"> | string | null
    description?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    orderId?: StringNullableFilter<"Payment"> | string | null
    recipientId?: StringNullableFilter<"Payment"> | string | null
    businessId?: StringNullableFilter<"Payment"> | string | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    recipient?: XOR<CourierNullableScalarRelationFilter, CourierWhereInput> | null
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    reference?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    recipientId?: SortOrderInput | SortOrder
    businessId?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    recipient?: CourierOrderByWithRelationInput
    business?: BusinessOrderByWithRelationInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    reference?: StringNullableFilter<"Payment"> | string | null
    description?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    orderId?: StringNullableFilter<"Payment"> | string | null
    recipientId?: StringNullableFilter<"Payment"> | string | null
    businessId?: StringNullableFilter<"Payment"> | string | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    recipient?: XOR<CourierNullableScalarRelationFilter, CourierWhereInput> | null
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    reference?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    recipientId?: SortOrderInput | SortOrder
    businessId?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    description?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    orderId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    recipientId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    businessId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    businessId?: StringFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    slug?: StringFilter<"ProductCategory"> | string
    imageUrl?: StringNullableFilter<"ProductCategory"> | string | null
    isActive?: BoolFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    parentId?: StringNullableFilter<"ProductCategory"> | string | null
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    parent?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    children?: ProductCategoryListRelationFilter
    products?: InventoryListRelationFilter
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    business?: BusinessOrderByWithRelationInput
    parent?: ProductCategoryOrderByWithRelationInput
    children?: ProductCategoryOrderByRelationAggregateInput
    products?: InventoryOrderByRelationAggregateInput
    _relevance?: ProductCategoryOrderByRelevanceInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessId_slug?: ProductCategoryBusinessIdSlugCompoundUniqueInput
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    businessId?: StringFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    slug?: StringFilter<"ProductCategory"> | string
    imageUrl?: StringNullableFilter<"ProductCategory"> | string | null
    isActive?: BoolFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    parentId?: StringNullableFilter<"ProductCategory"> | string | null
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    parent?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    children?: ProductCategoryListRelationFilter
    products?: InventoryListRelationFilter
  }, "id" | "businessId_slug">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductCategory"> | string
    businessId?: StringWithAggregatesFilter<"ProductCategory"> | string
    name?: StringWithAggregatesFilter<"ProductCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    slug?: StringWithAggregatesFilter<"ProductCategory"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    isActive?: BoolWithAggregatesFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    parentId?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    description?: StringFilter<"ActivityLog"> | string
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    targetId?: StringNullableFilter<"ActivityLog"> | string | null
    targetType?: StringNullableFilter<"ActivityLog"> | string | null
    ip?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    adminId?: StringNullableFilter<"ActivityLog"> | string | null
    metadata?: JsonNullableFilter<"ActivityLog">
    severity?: StringNullableFilter<"ActivityLog"> | string | null
    category?: StringNullableFilter<"ActivityLog"> | string | null
    isResolved?: BoolFilter<"ActivityLog"> | boolean
    resolvedAt?: DateTimeNullableFilter<"ActivityLog"> | Date | string | null
    resolvedBy?: StringNullableFilter<"ActivityLog"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    targetId?: SortOrderInput | SortOrder
    targetType?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    _relevance?: ActivityLogOrderByRelevanceInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    action?: StringFilter<"ActivityLog"> | string
    description?: StringFilter<"ActivityLog"> | string
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    targetId?: StringNullableFilter<"ActivityLog"> | string | null
    targetType?: StringNullableFilter<"ActivityLog"> | string | null
    ip?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    adminId?: StringNullableFilter<"ActivityLog"> | string | null
    metadata?: JsonNullableFilter<"ActivityLog">
    severity?: StringNullableFilter<"ActivityLog"> | string | null
    category?: StringNullableFilter<"ActivityLog"> | string | null
    isResolved?: BoolFilter<"ActivityLog"> | boolean
    resolvedAt?: DateTimeNullableFilter<"ActivityLog"> | Date | string | null
    resolvedBy?: StringNullableFilter<"ActivityLog"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    targetId?: SortOrderInput | SortOrder
    targetType?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    description?: StringWithAggregatesFilter<"ActivityLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    targetId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    targetType?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    ip?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    adminId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ActivityLog">
    severity?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    category?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    isResolved?: BoolWithAggregatesFilter<"ActivityLog"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"ActivityLog"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
  }

  export type SystemActionWhereInput = {
    AND?: SystemActionWhereInput | SystemActionWhereInput[]
    OR?: SystemActionWhereInput[]
    NOT?: SystemActionWhereInput | SystemActionWhereInput[]
    id?: StringFilter<"SystemAction"> | string
    action?: StringFilter<"SystemAction"> | string
    description?: StringFilter<"SystemAction"> | string
    createdAt?: DateTimeFilter<"SystemAction"> | Date | string
    adminId?: StringNullableFilter<"SystemAction"> | string | null
    status?: StringFilter<"SystemAction"> | string
    payload?: JsonNullableFilter<"SystemAction">
    result?: JsonNullableFilter<"SystemAction">
    error?: StringNullableFilter<"SystemAction"> | string | null
    executionTime?: IntNullableFilter<"SystemAction"> | number | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }

  export type SystemActionOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrderInput | SortOrder
    status?: SortOrder
    payload?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    executionTime?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
    _relevance?: SystemActionOrderByRelevanceInput
  }

  export type SystemActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemActionWhereInput | SystemActionWhereInput[]
    OR?: SystemActionWhereInput[]
    NOT?: SystemActionWhereInput | SystemActionWhereInput[]
    action?: StringFilter<"SystemAction"> | string
    description?: StringFilter<"SystemAction"> | string
    createdAt?: DateTimeFilter<"SystemAction"> | Date | string
    adminId?: StringNullableFilter<"SystemAction"> | string | null
    status?: StringFilter<"SystemAction"> | string
    payload?: JsonNullableFilter<"SystemAction">
    result?: JsonNullableFilter<"SystemAction">
    error?: StringNullableFilter<"SystemAction"> | string | null
    executionTime?: IntNullableFilter<"SystemAction"> | number | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }, "id">

  export type SystemActionOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrderInput | SortOrder
    status?: SortOrder
    payload?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    executionTime?: SortOrderInput | SortOrder
    _count?: SystemActionCountOrderByAggregateInput
    _avg?: SystemActionAvgOrderByAggregateInput
    _max?: SystemActionMaxOrderByAggregateInput
    _min?: SystemActionMinOrderByAggregateInput
    _sum?: SystemActionSumOrderByAggregateInput
  }

  export type SystemActionScalarWhereWithAggregatesInput = {
    AND?: SystemActionScalarWhereWithAggregatesInput | SystemActionScalarWhereWithAggregatesInput[]
    OR?: SystemActionScalarWhereWithAggregatesInput[]
    NOT?: SystemActionScalarWhereWithAggregatesInput | SystemActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemAction"> | string
    action?: StringWithAggregatesFilter<"SystemAction"> | string
    description?: StringWithAggregatesFilter<"SystemAction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SystemAction"> | Date | string
    adminId?: StringNullableWithAggregatesFilter<"SystemAction"> | string | null
    status?: StringWithAggregatesFilter<"SystemAction"> | string
    payload?: JsonNullableWithAggregatesFilter<"SystemAction">
    result?: JsonNullableWithAggregatesFilter<"SystemAction">
    error?: StringNullableWithAggregatesFilter<"SystemAction"> | string | null
    executionTime?: IntNullableWithAggregatesFilter<"SystemAction"> | number | null
  }

  export type SystemSettingsWhereInput = {
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    id?: StringFilter<"SystemSettings"> | string
    key?: StringFilter<"SystemSettings"> | string
    value?: StringFilter<"SystemSettings"> | string
    category?: StringFilter<"SystemSettings"> | string
    description?: StringNullableFilter<"SystemSettings"> | string | null
    dataType?: StringFilter<"SystemSettings"> | string
    isEncrypted?: BoolFilter<"SystemSettings"> | boolean
    lastUpdated?: DateTimeFilter<"SystemSettings"> | Date | string
    updatedBy?: StringNullableFilter<"SystemSettings"> | string | null
  }

  export type SystemSettingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    dataType?: SortOrder
    isEncrypted?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _relevance?: SystemSettingsOrderByRelevanceInput
  }

  export type SystemSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    value?: StringFilter<"SystemSettings"> | string
    category?: StringFilter<"SystemSettings"> | string
    description?: StringNullableFilter<"SystemSettings"> | string | null
    dataType?: StringFilter<"SystemSettings"> | string
    isEncrypted?: BoolFilter<"SystemSettings"> | boolean
    lastUpdated?: DateTimeFilter<"SystemSettings"> | Date | string
    updatedBy?: StringNullableFilter<"SystemSettings"> | string | null
  }, "id" | "key">

  export type SystemSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    dataType?: SortOrder
    isEncrypted?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SystemSettingsCountOrderByAggregateInput
    _max?: SystemSettingsMaxOrderByAggregateInput
    _min?: SystemSettingsMinOrderByAggregateInput
  }

  export type SystemSettingsScalarWhereWithAggregatesInput = {
    AND?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    OR?: SystemSettingsScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSettings"> | string
    key?: StringWithAggregatesFilter<"SystemSettings"> | string
    value?: StringWithAggregatesFilter<"SystemSettings"> | string
    category?: StringWithAggregatesFilter<"SystemSettings"> | string
    description?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    dataType?: StringWithAggregatesFilter<"SystemSettings"> | string
    isEncrypted?: BoolWithAggregatesFilter<"SystemSettings"> | boolean
    lastUpdated?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
  }

  export type AdminDashboardWidgetWhereInput = {
    AND?: AdminDashboardWidgetWhereInput | AdminDashboardWidgetWhereInput[]
    OR?: AdminDashboardWidgetWhereInput[]
    NOT?: AdminDashboardWidgetWhereInput | AdminDashboardWidgetWhereInput[]
    id?: StringFilter<"AdminDashboardWidget"> | string
    name?: StringFilter<"AdminDashboardWidget"> | string
    type?: StringFilter<"AdminDashboardWidget"> | string
    position?: IntFilter<"AdminDashboardWidget"> | number
    size?: StringFilter<"AdminDashboardWidget"> | string
    config?: JsonFilter<"AdminDashboardWidget">
    isActive?: BoolFilter<"AdminDashboardWidget"> | boolean
    adminId?: StringFilter<"AdminDashboardWidget"> | string
    createdAt?: DateTimeFilter<"AdminDashboardWidget"> | Date | string
    updatedAt?: DateTimeFilter<"AdminDashboardWidget"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminDashboardWidgetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    position?: SortOrder
    size?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    _relevance?: AdminDashboardWidgetOrderByRelevanceInput
  }

  export type AdminDashboardWidgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminDashboardWidgetWhereInput | AdminDashboardWidgetWhereInput[]
    OR?: AdminDashboardWidgetWhereInput[]
    NOT?: AdminDashboardWidgetWhereInput | AdminDashboardWidgetWhereInput[]
    name?: StringFilter<"AdminDashboardWidget"> | string
    type?: StringFilter<"AdminDashboardWidget"> | string
    position?: IntFilter<"AdminDashboardWidget"> | number
    size?: StringFilter<"AdminDashboardWidget"> | string
    config?: JsonFilter<"AdminDashboardWidget">
    isActive?: BoolFilter<"AdminDashboardWidget"> | boolean
    adminId?: StringFilter<"AdminDashboardWidget"> | string
    createdAt?: DateTimeFilter<"AdminDashboardWidget"> | Date | string
    updatedAt?: DateTimeFilter<"AdminDashboardWidget"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id">

  export type AdminDashboardWidgetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    position?: SortOrder
    size?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminDashboardWidgetCountOrderByAggregateInput
    _avg?: AdminDashboardWidgetAvgOrderByAggregateInput
    _max?: AdminDashboardWidgetMaxOrderByAggregateInput
    _min?: AdminDashboardWidgetMinOrderByAggregateInput
    _sum?: AdminDashboardWidgetSumOrderByAggregateInput
  }

  export type AdminDashboardWidgetScalarWhereWithAggregatesInput = {
    AND?: AdminDashboardWidgetScalarWhereWithAggregatesInput | AdminDashboardWidgetScalarWhereWithAggregatesInput[]
    OR?: AdminDashboardWidgetScalarWhereWithAggregatesInput[]
    NOT?: AdminDashboardWidgetScalarWhereWithAggregatesInput | AdminDashboardWidgetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminDashboardWidget"> | string
    name?: StringWithAggregatesFilter<"AdminDashboardWidget"> | string
    type?: StringWithAggregatesFilter<"AdminDashboardWidget"> | string
    position?: IntWithAggregatesFilter<"AdminDashboardWidget"> | number
    size?: StringWithAggregatesFilter<"AdminDashboardWidget"> | string
    config?: JsonWithAggregatesFilter<"AdminDashboardWidget">
    isActive?: BoolWithAggregatesFilter<"AdminDashboardWidget"> | boolean
    adminId?: StringWithAggregatesFilter<"AdminDashboardWidget"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminDashboardWidget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminDashboardWidget"> | Date | string
  }

  export type AdminPermissionWhereInput = {
    AND?: AdminPermissionWhereInput | AdminPermissionWhereInput[]
    OR?: AdminPermissionWhereInput[]
    NOT?: AdminPermissionWhereInput | AdminPermissionWhereInput[]
    id?: StringFilter<"AdminPermission"> | string
    name?: StringFilter<"AdminPermission"> | string
    description?: StringFilter<"AdminPermission"> | string
    createdAt?: DateTimeFilter<"AdminPermission"> | Date | string
    updatedAt?: DateTimeFilter<"AdminPermission"> | Date | string
    adminRoles?: AdminRoleListRelationFilter
  }

  export type AdminPermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminRoles?: AdminRoleOrderByRelationAggregateInput
    _relevance?: AdminPermissionOrderByRelevanceInput
  }

  export type AdminPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AdminPermissionWhereInput | AdminPermissionWhereInput[]
    OR?: AdminPermissionWhereInput[]
    NOT?: AdminPermissionWhereInput | AdminPermissionWhereInput[]
    description?: StringFilter<"AdminPermission"> | string
    createdAt?: DateTimeFilter<"AdminPermission"> | Date | string
    updatedAt?: DateTimeFilter<"AdminPermission"> | Date | string
    adminRoles?: AdminRoleListRelationFilter
  }, "id" | "name">

  export type AdminPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminPermissionCountOrderByAggregateInput
    _max?: AdminPermissionMaxOrderByAggregateInput
    _min?: AdminPermissionMinOrderByAggregateInput
  }

  export type AdminPermissionScalarWhereWithAggregatesInput = {
    AND?: AdminPermissionScalarWhereWithAggregatesInput | AdminPermissionScalarWhereWithAggregatesInput[]
    OR?: AdminPermissionScalarWhereWithAggregatesInput[]
    NOT?: AdminPermissionScalarWhereWithAggregatesInput | AdminPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminPermission"> | string
    name?: StringWithAggregatesFilter<"AdminPermission"> | string
    description?: StringWithAggregatesFilter<"AdminPermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminPermission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminPermission"> | Date | string
  }

  export type AdminRoleWhereInput = {
    AND?: AdminRoleWhereInput | AdminRoleWhereInput[]
    OR?: AdminRoleWhereInput[]
    NOT?: AdminRoleWhereInput | AdminRoleWhereInput[]
    id?: StringFilter<"AdminRole"> | string
    name?: StringFilter<"AdminRole"> | string
    description?: StringFilter<"AdminRole"> | string
    createdAt?: DateTimeFilter<"AdminRole"> | Date | string
    updatedAt?: DateTimeFilter<"AdminRole"> | Date | string
    permissions?: AdminPermissionListRelationFilter
    admins?: AdminRoleMappingListRelationFilter
  }

  export type AdminRoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: AdminPermissionOrderByRelationAggregateInput
    admins?: AdminRoleMappingOrderByRelationAggregateInput
    _relevance?: AdminRoleOrderByRelevanceInput
  }

  export type AdminRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AdminRoleWhereInput | AdminRoleWhereInput[]
    OR?: AdminRoleWhereInput[]
    NOT?: AdminRoleWhereInput | AdminRoleWhereInput[]
    description?: StringFilter<"AdminRole"> | string
    createdAt?: DateTimeFilter<"AdminRole"> | Date | string
    updatedAt?: DateTimeFilter<"AdminRole"> | Date | string
    permissions?: AdminPermissionListRelationFilter
    admins?: AdminRoleMappingListRelationFilter
  }, "id" | "name">

  export type AdminRoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminRoleCountOrderByAggregateInput
    _max?: AdminRoleMaxOrderByAggregateInput
    _min?: AdminRoleMinOrderByAggregateInput
  }

  export type AdminRoleScalarWhereWithAggregatesInput = {
    AND?: AdminRoleScalarWhereWithAggregatesInput | AdminRoleScalarWhereWithAggregatesInput[]
    OR?: AdminRoleScalarWhereWithAggregatesInput[]
    NOT?: AdminRoleScalarWhereWithAggregatesInput | AdminRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminRole"> | string
    name?: StringWithAggregatesFilter<"AdminRole"> | string
    description?: StringWithAggregatesFilter<"AdminRole"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminRole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminRole"> | Date | string
  }

  export type AdminRoleMappingWhereInput = {
    AND?: AdminRoleMappingWhereInput | AdminRoleMappingWhereInput[]
    OR?: AdminRoleMappingWhereInput[]
    NOT?: AdminRoleMappingWhereInput | AdminRoleMappingWhereInput[]
    id?: StringFilter<"AdminRoleMapping"> | string
    adminId?: StringFilter<"AdminRoleMapping"> | string
    roleId?: StringFilter<"AdminRoleMapping"> | string
    createdAt?: DateTimeFilter<"AdminRoleMapping"> | Date | string
    updatedAt?: DateTimeFilter<"AdminRoleMapping"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    role?: XOR<AdminRoleScalarRelationFilter, AdminRoleWhereInput>
  }

  export type AdminRoleMappingOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    role?: AdminRoleOrderByWithRelationInput
    _relevance?: AdminRoleMappingOrderByRelevanceInput
  }

  export type AdminRoleMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    adminId_roleId?: AdminRoleMappingAdminIdRoleIdCompoundUniqueInput
    AND?: AdminRoleMappingWhereInput | AdminRoleMappingWhereInput[]
    OR?: AdminRoleMappingWhereInput[]
    NOT?: AdminRoleMappingWhereInput | AdminRoleMappingWhereInput[]
    adminId?: StringFilter<"AdminRoleMapping"> | string
    roleId?: StringFilter<"AdminRoleMapping"> | string
    createdAt?: DateTimeFilter<"AdminRoleMapping"> | Date | string
    updatedAt?: DateTimeFilter<"AdminRoleMapping"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    role?: XOR<AdminRoleScalarRelationFilter, AdminRoleWhereInput>
  }, "id" | "adminId_roleId">

  export type AdminRoleMappingOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminRoleMappingCountOrderByAggregateInput
    _max?: AdminRoleMappingMaxOrderByAggregateInput
    _min?: AdminRoleMappingMinOrderByAggregateInput
  }

  export type AdminRoleMappingScalarWhereWithAggregatesInput = {
    AND?: AdminRoleMappingScalarWhereWithAggregatesInput | AdminRoleMappingScalarWhereWithAggregatesInput[]
    OR?: AdminRoleMappingScalarWhereWithAggregatesInput[]
    NOT?: AdminRoleMappingScalarWhereWithAggregatesInput | AdminRoleMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminRoleMapping"> | string
    adminId?: StringWithAggregatesFilter<"AdminRoleMapping"> | string
    roleId?: StringWithAggregatesFilter<"AdminRoleMapping"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminRoleMapping"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminRoleMapping"> | Date | string
  }

  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    body?: StringFilter<"EmailTemplate"> | string
    category?: StringFilter<"EmailTemplate"> | string
    description?: StringNullableFilter<"EmailTemplate"> | string | null
    isActive?: BoolFilter<"EmailTemplate"> | boolean
    variables?: JsonFilter<"EmailTemplate">
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    createdBy?: StringFilter<"EmailTemplate"> | string
    updatedBy?: StringNullableFilter<"EmailTemplate"> | string | null
    sentEmails?: SentEmailListRelationFilter
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    variables?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    sentEmails?: SentEmailOrderByRelationAggregateInput
    _relevance?: EmailTemplateOrderByRelevanceInput
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    subject?: StringFilter<"EmailTemplate"> | string
    body?: StringFilter<"EmailTemplate"> | string
    category?: StringFilter<"EmailTemplate"> | string
    description?: StringNullableFilter<"EmailTemplate"> | string | null
    isActive?: BoolFilter<"EmailTemplate"> | boolean
    variables?: JsonFilter<"EmailTemplate">
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    createdBy?: StringFilter<"EmailTemplate"> | string
    updatedBy?: StringNullableFilter<"EmailTemplate"> | string | null
    sentEmails?: SentEmailListRelationFilter
  }, "id" | "name">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    variables?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTemplate"> | string
    name?: StringWithAggregatesFilter<"EmailTemplate"> | string
    subject?: StringWithAggregatesFilter<"EmailTemplate"> | string
    body?: StringWithAggregatesFilter<"EmailTemplate"> | string
    category?: StringWithAggregatesFilter<"EmailTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    isActive?: BoolWithAggregatesFilter<"EmailTemplate"> | boolean
    variables?: JsonWithAggregatesFilter<"EmailTemplate">
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    createdBy?: StringWithAggregatesFilter<"EmailTemplate"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
  }

  export type SentEmailWhereInput = {
    AND?: SentEmailWhereInput | SentEmailWhereInput[]
    OR?: SentEmailWhereInput[]
    NOT?: SentEmailWhereInput | SentEmailWhereInput[]
    id?: StringFilter<"SentEmail"> | string
    templateId?: StringFilter<"SentEmail"> | string
    recipient?: StringFilter<"SentEmail"> | string
    subject?: StringFilter<"SentEmail"> | string
    variables?: StringFilter<"SentEmail"> | string
    messageId?: StringNullableFilter<"SentEmail"> | string | null
    sentBy?: StringFilter<"SentEmail"> | string
    sentAt?: DateTimeFilter<"SentEmail"> | Date | string
    status?: StringFilter<"SentEmail"> | string
    category?: StringFilter<"SentEmail"> | string
    createdAt?: DateTimeFilter<"SentEmail"> | Date | string
    updatedAt?: DateTimeFilter<"SentEmail"> | Date | string
    template?: XOR<EmailTemplateScalarRelationFilter, EmailTemplateWhereInput>
  }

  export type SentEmailOrderByWithRelationInput = {
    id?: SortOrder
    templateId?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    variables?: SortOrder
    messageId?: SortOrderInput | SortOrder
    sentBy?: SortOrder
    sentAt?: SortOrder
    status?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    template?: EmailTemplateOrderByWithRelationInput
    _relevance?: SentEmailOrderByRelevanceInput
  }

  export type SentEmailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SentEmailWhereInput | SentEmailWhereInput[]
    OR?: SentEmailWhereInput[]
    NOT?: SentEmailWhereInput | SentEmailWhereInput[]
    templateId?: StringFilter<"SentEmail"> | string
    recipient?: StringFilter<"SentEmail"> | string
    subject?: StringFilter<"SentEmail"> | string
    variables?: StringFilter<"SentEmail"> | string
    messageId?: StringNullableFilter<"SentEmail"> | string | null
    sentBy?: StringFilter<"SentEmail"> | string
    sentAt?: DateTimeFilter<"SentEmail"> | Date | string
    status?: StringFilter<"SentEmail"> | string
    category?: StringFilter<"SentEmail"> | string
    createdAt?: DateTimeFilter<"SentEmail"> | Date | string
    updatedAt?: DateTimeFilter<"SentEmail"> | Date | string
    template?: XOR<EmailTemplateScalarRelationFilter, EmailTemplateWhereInput>
  }, "id">

  export type SentEmailOrderByWithAggregationInput = {
    id?: SortOrder
    templateId?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    variables?: SortOrder
    messageId?: SortOrderInput | SortOrder
    sentBy?: SortOrder
    sentAt?: SortOrder
    status?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SentEmailCountOrderByAggregateInput
    _max?: SentEmailMaxOrderByAggregateInput
    _min?: SentEmailMinOrderByAggregateInput
  }

  export type SentEmailScalarWhereWithAggregatesInput = {
    AND?: SentEmailScalarWhereWithAggregatesInput | SentEmailScalarWhereWithAggregatesInput[]
    OR?: SentEmailScalarWhereWithAggregatesInput[]
    NOT?: SentEmailScalarWhereWithAggregatesInput | SentEmailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SentEmail"> | string
    templateId?: StringWithAggregatesFilter<"SentEmail"> | string
    recipient?: StringWithAggregatesFilter<"SentEmail"> | string
    subject?: StringWithAggregatesFilter<"SentEmail"> | string
    variables?: StringWithAggregatesFilter<"SentEmail"> | string
    messageId?: StringNullableWithAggregatesFilter<"SentEmail"> | string | null
    sentBy?: StringWithAggregatesFilter<"SentEmail"> | string
    sentAt?: DateTimeWithAggregatesFilter<"SentEmail"> | Date | string
    status?: StringWithAggregatesFilter<"SentEmail"> | string
    category?: StringWithAggregatesFilter<"SentEmail"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SentEmail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SentEmail"> | Date | string
  }

  export type CustomerAddressWhereInput = {
    AND?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    OR?: CustomerAddressWhereInput[]
    NOT?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    id?: StringFilter<"CustomerAddress"> | string
    customerId?: StringFilter<"CustomerAddress"> | string
    title?: StringFilter<"CustomerAddress"> | string
    firstName?: StringFilter<"CustomerAddress"> | string
    lastName?: StringFilter<"CustomerAddress"> | string
    addressLine1?: StringFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableFilter<"CustomerAddress"> | string | null
    city?: StringFilter<"CustomerAddress"> | string
    state?: StringNullableFilter<"CustomerAddress"> | string | null
    postalCode?: StringFilter<"CustomerAddress"> | string
    country?: StringFilter<"CustomerAddress"> | string
    phone?: StringNullableFilter<"CustomerAddress"> | string | null
    notes?: StringNullableFilter<"CustomerAddress"> | string | null
    latitude?: FloatNullableFilter<"CustomerAddress"> | number | null
    longitude?: FloatNullableFilter<"CustomerAddress"> | number | null
    isDefault?: BoolFilter<"CustomerAddress"> | boolean
    isActive?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerAddressOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    phone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    _relevance?: CustomerAddressOrderByRelevanceInput
  }

  export type CustomerAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    OR?: CustomerAddressWhereInput[]
    NOT?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    customerId?: StringFilter<"CustomerAddress"> | string
    title?: StringFilter<"CustomerAddress"> | string
    firstName?: StringFilter<"CustomerAddress"> | string
    lastName?: StringFilter<"CustomerAddress"> | string
    addressLine1?: StringFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableFilter<"CustomerAddress"> | string | null
    city?: StringFilter<"CustomerAddress"> | string
    state?: StringNullableFilter<"CustomerAddress"> | string | null
    postalCode?: StringFilter<"CustomerAddress"> | string
    country?: StringFilter<"CustomerAddress"> | string
    phone?: StringNullableFilter<"CustomerAddress"> | string | null
    notes?: StringNullableFilter<"CustomerAddress"> | string | null
    latitude?: FloatNullableFilter<"CustomerAddress"> | number | null
    longitude?: FloatNullableFilter<"CustomerAddress"> | number | null
    isDefault?: BoolFilter<"CustomerAddress"> | boolean
    isActive?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type CustomerAddressOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    phone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerAddressCountOrderByAggregateInput
    _avg?: CustomerAddressAvgOrderByAggregateInput
    _max?: CustomerAddressMaxOrderByAggregateInput
    _min?: CustomerAddressMinOrderByAggregateInput
    _sum?: CustomerAddressSumOrderByAggregateInput
  }

  export type CustomerAddressScalarWhereWithAggregatesInput = {
    AND?: CustomerAddressScalarWhereWithAggregatesInput | CustomerAddressScalarWhereWithAggregatesInput[]
    OR?: CustomerAddressScalarWhereWithAggregatesInput[]
    NOT?: CustomerAddressScalarWhereWithAggregatesInput | CustomerAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerAddress"> | string
    customerId?: StringWithAggregatesFilter<"CustomerAddress"> | string
    title?: StringWithAggregatesFilter<"CustomerAddress"> | string
    firstName?: StringWithAggregatesFilter<"CustomerAddress"> | string
    lastName?: StringWithAggregatesFilter<"CustomerAddress"> | string
    addressLine1?: StringWithAggregatesFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    city?: StringWithAggregatesFilter<"CustomerAddress"> | string
    state?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    postalCode?: StringWithAggregatesFilter<"CustomerAddress"> | string
    country?: StringWithAggregatesFilter<"CustomerAddress"> | string
    phone?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    notes?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"CustomerAddress"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"CustomerAddress"> | number | null
    isDefault?: BoolWithAggregatesFilter<"CustomerAddress"> | boolean
    isActive?: BoolWithAggregatesFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerAddress"> | Date | string
  }

  export type RefundRequestWhereInput = {
    AND?: RefundRequestWhereInput | RefundRequestWhereInput[]
    OR?: RefundRequestWhereInput[]
    NOT?: RefundRequestWhereInput | RefundRequestWhereInput[]
    id?: StringFilter<"RefundRequest"> | string
    orderId?: StringFilter<"RefundRequest"> | string
    customerId?: StringFilter<"RefundRequest"> | string
    businessId?: StringFilter<"RefundRequest"> | string
    status?: EnumRefundRequestStatusFilter<"RefundRequest"> | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFilter<"RefundRequest"> | $Enums.RefundReason
    otherReason?: StringNullableFilter<"RefundRequest"> | string | null
    requestedItems?: JsonNullableFilter<"RefundRequest">
    refundAmount?: FloatNullableFilter<"RefundRequest"> | number | null
    approvedAmount?: FloatNullableFilter<"RefundRequest"> | number | null
    evidenceUrls?: StringNullableListFilter<"RefundRequest">
    adminNotes?: StringNullableFilter<"RefundRequest"> | string | null
    customerNotes?: StringNullableFilter<"RefundRequest"> | string | null
    businessNotes?: StringNullableFilter<"RefundRequest"> | string | null
    createdAt?: DateTimeFilter<"RefundRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RefundRequest"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"RefundRequest"> | Date | string | null
    reviewedBy?: StringNullableFilter<"RefundRequest"> | string | null
    refundedAt?: DateTimeNullableFilter<"RefundRequest"> | Date | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
  }

  export type RefundRequestOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    otherReason?: SortOrderInput | SortOrder
    requestedItems?: SortOrderInput | SortOrder
    refundAmount?: SortOrderInput | SortOrder
    approvedAmount?: SortOrderInput | SortOrder
    evidenceUrls?: SortOrder
    adminNotes?: SortOrderInput | SortOrder
    customerNotes?: SortOrderInput | SortOrder
    businessNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    refundedAt?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    business?: BusinessOrderByWithRelationInput
    _relevance?: RefundRequestOrderByRelevanceInput
  }

  export type RefundRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RefundRequestWhereInput | RefundRequestWhereInput[]
    OR?: RefundRequestWhereInput[]
    NOT?: RefundRequestWhereInput | RefundRequestWhereInput[]
    orderId?: StringFilter<"RefundRequest"> | string
    customerId?: StringFilter<"RefundRequest"> | string
    businessId?: StringFilter<"RefundRequest"> | string
    status?: EnumRefundRequestStatusFilter<"RefundRequest"> | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFilter<"RefundRequest"> | $Enums.RefundReason
    otherReason?: StringNullableFilter<"RefundRequest"> | string | null
    requestedItems?: JsonNullableFilter<"RefundRequest">
    refundAmount?: FloatNullableFilter<"RefundRequest"> | number | null
    approvedAmount?: FloatNullableFilter<"RefundRequest"> | number | null
    evidenceUrls?: StringNullableListFilter<"RefundRequest">
    adminNotes?: StringNullableFilter<"RefundRequest"> | string | null
    customerNotes?: StringNullableFilter<"RefundRequest"> | string | null
    businessNotes?: StringNullableFilter<"RefundRequest"> | string | null
    createdAt?: DateTimeFilter<"RefundRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RefundRequest"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"RefundRequest"> | Date | string | null
    reviewedBy?: StringNullableFilter<"RefundRequest"> | string | null
    refundedAt?: DateTimeNullableFilter<"RefundRequest"> | Date | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
  }, "id">

  export type RefundRequestOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    otherReason?: SortOrderInput | SortOrder
    requestedItems?: SortOrderInput | SortOrder
    refundAmount?: SortOrderInput | SortOrder
    approvedAmount?: SortOrderInput | SortOrder
    evidenceUrls?: SortOrder
    adminNotes?: SortOrderInput | SortOrder
    customerNotes?: SortOrderInput | SortOrder
    businessNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    refundedAt?: SortOrderInput | SortOrder
    _count?: RefundRequestCountOrderByAggregateInput
    _avg?: RefundRequestAvgOrderByAggregateInput
    _max?: RefundRequestMaxOrderByAggregateInput
    _min?: RefundRequestMinOrderByAggregateInput
    _sum?: RefundRequestSumOrderByAggregateInput
  }

  export type RefundRequestScalarWhereWithAggregatesInput = {
    AND?: RefundRequestScalarWhereWithAggregatesInput | RefundRequestScalarWhereWithAggregatesInput[]
    OR?: RefundRequestScalarWhereWithAggregatesInput[]
    NOT?: RefundRequestScalarWhereWithAggregatesInput | RefundRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefundRequest"> | string
    orderId?: StringWithAggregatesFilter<"RefundRequest"> | string
    customerId?: StringWithAggregatesFilter<"RefundRequest"> | string
    businessId?: StringWithAggregatesFilter<"RefundRequest"> | string
    status?: EnumRefundRequestStatusWithAggregatesFilter<"RefundRequest"> | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonWithAggregatesFilter<"RefundRequest"> | $Enums.RefundReason
    otherReason?: StringNullableWithAggregatesFilter<"RefundRequest"> | string | null
    requestedItems?: JsonNullableWithAggregatesFilter<"RefundRequest">
    refundAmount?: FloatNullableWithAggregatesFilter<"RefundRequest"> | number | null
    approvedAmount?: FloatNullableWithAggregatesFilter<"RefundRequest"> | number | null
    evidenceUrls?: StringNullableListFilter<"RefundRequest">
    adminNotes?: StringNullableWithAggregatesFilter<"RefundRequest"> | string | null
    customerNotes?: StringNullableWithAggregatesFilter<"RefundRequest"> | string | null
    businessNotes?: StringNullableWithAggregatesFilter<"RefundRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RefundRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefundRequest"> | Date | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"RefundRequest"> | Date | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"RefundRequest"> | string | null
    refundedAt?: DateTimeNullableWithAggregatesFilter<"RefundRequest"> | Date | string | null
  }

  export type CancellationRequestWhereInput = {
    AND?: CancellationRequestWhereInput | CancellationRequestWhereInput[]
    OR?: CancellationRequestWhereInput[]
    NOT?: CancellationRequestWhereInput | CancellationRequestWhereInput[]
    id?: StringFilter<"CancellationRequest"> | string
    orderId?: StringFilter<"CancellationRequest"> | string
    customerId?: StringFilter<"CancellationRequest"> | string
    businessId?: StringFilter<"CancellationRequest"> | string
    status?: EnumCancellationRequestStatusFilter<"CancellationRequest"> | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFilter<"CancellationRequest"> | $Enums.CancellationReason
    otherReason?: StringNullableFilter<"CancellationRequest"> | string | null
    cancellationFee?: FloatNullableFilter<"CancellationRequest"> | number | null
    autoProcessed?: BoolFilter<"CancellationRequest"> | boolean
    customerNotes?: StringNullableFilter<"CancellationRequest"> | string | null
    businessNotes?: StringNullableFilter<"CancellationRequest"> | string | null
    createdAt?: DateTimeFilter<"CancellationRequest"> | Date | string
    updatedAt?: DateTimeFilter<"CancellationRequest"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"CancellationRequest"> | Date | string | null
    reviewedBy?: StringNullableFilter<"CancellationRequest"> | string | null
    cancelledAt?: DateTimeNullableFilter<"CancellationRequest"> | Date | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
  }

  export type CancellationRequestOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    otherReason?: SortOrderInput | SortOrder
    cancellationFee?: SortOrderInput | SortOrder
    autoProcessed?: SortOrder
    customerNotes?: SortOrderInput | SortOrder
    businessNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    business?: BusinessOrderByWithRelationInput
    _relevance?: CancellationRequestOrderByRelevanceInput
  }

  export type CancellationRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CancellationRequestWhereInput | CancellationRequestWhereInput[]
    OR?: CancellationRequestWhereInput[]
    NOT?: CancellationRequestWhereInput | CancellationRequestWhereInput[]
    orderId?: StringFilter<"CancellationRequest"> | string
    customerId?: StringFilter<"CancellationRequest"> | string
    businessId?: StringFilter<"CancellationRequest"> | string
    status?: EnumCancellationRequestStatusFilter<"CancellationRequest"> | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFilter<"CancellationRequest"> | $Enums.CancellationReason
    otherReason?: StringNullableFilter<"CancellationRequest"> | string | null
    cancellationFee?: FloatNullableFilter<"CancellationRequest"> | number | null
    autoProcessed?: BoolFilter<"CancellationRequest"> | boolean
    customerNotes?: StringNullableFilter<"CancellationRequest"> | string | null
    businessNotes?: StringNullableFilter<"CancellationRequest"> | string | null
    createdAt?: DateTimeFilter<"CancellationRequest"> | Date | string
    updatedAt?: DateTimeFilter<"CancellationRequest"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"CancellationRequest"> | Date | string | null
    reviewedBy?: StringNullableFilter<"CancellationRequest"> | string | null
    cancelledAt?: DateTimeNullableFilter<"CancellationRequest"> | Date | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
  }, "id">

  export type CancellationRequestOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    otherReason?: SortOrderInput | SortOrder
    cancellationFee?: SortOrderInput | SortOrder
    autoProcessed?: SortOrder
    customerNotes?: SortOrderInput | SortOrder
    businessNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    _count?: CancellationRequestCountOrderByAggregateInput
    _avg?: CancellationRequestAvgOrderByAggregateInput
    _max?: CancellationRequestMaxOrderByAggregateInput
    _min?: CancellationRequestMinOrderByAggregateInput
    _sum?: CancellationRequestSumOrderByAggregateInput
  }

  export type CancellationRequestScalarWhereWithAggregatesInput = {
    AND?: CancellationRequestScalarWhereWithAggregatesInput | CancellationRequestScalarWhereWithAggregatesInput[]
    OR?: CancellationRequestScalarWhereWithAggregatesInput[]
    NOT?: CancellationRequestScalarWhereWithAggregatesInput | CancellationRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CancellationRequest"> | string
    orderId?: StringWithAggregatesFilter<"CancellationRequest"> | string
    customerId?: StringWithAggregatesFilter<"CancellationRequest"> | string
    businessId?: StringWithAggregatesFilter<"CancellationRequest"> | string
    status?: EnumCancellationRequestStatusWithAggregatesFilter<"CancellationRequest"> | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonWithAggregatesFilter<"CancellationRequest"> | $Enums.CancellationReason
    otherReason?: StringNullableWithAggregatesFilter<"CancellationRequest"> | string | null
    cancellationFee?: FloatNullableWithAggregatesFilter<"CancellationRequest"> | number | null
    autoProcessed?: BoolWithAggregatesFilter<"CancellationRequest"> | boolean
    customerNotes?: StringNullableWithAggregatesFilter<"CancellationRequest"> | string | null
    businessNotes?: StringNullableWithAggregatesFilter<"CancellationRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CancellationRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CancellationRequest"> | Date | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"CancellationRequest"> | Date | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"CancellationRequest"> | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"CancellationRequest"> | Date | string | null
  }

  export type RefundPolicyWhereInput = {
    AND?: RefundPolicyWhereInput | RefundPolicyWhereInput[]
    OR?: RefundPolicyWhereInput[]
    NOT?: RefundPolicyWhereInput | RefundPolicyWhereInput[]
    id?: StringFilter<"RefundPolicy"> | string
    businessId?: StringFilter<"RefundPolicy"> | string
    name?: StringFilter<"RefundPolicy"> | string
    description?: StringNullableFilter<"RefundPolicy"> | string | null
    autoApproveTimeline?: IntNullableFilter<"RefundPolicy"> | number | null
    timeLimit?: IntNullableFilter<"RefundPolicy"> | number | null
    orderStatusRules?: JsonNullableFilter<"RefundPolicy">
    productRules?: JsonNullableFilter<"RefundPolicy">
    cancellationFees?: JsonNullableFilter<"RefundPolicy">
    isActive?: BoolFilter<"RefundPolicy"> | boolean
    createdAt?: DateTimeFilter<"RefundPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"RefundPolicy"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
  }

  export type RefundPolicyOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    autoApproveTimeline?: SortOrderInput | SortOrder
    timeLimit?: SortOrderInput | SortOrder
    orderStatusRules?: SortOrderInput | SortOrder
    productRules?: SortOrderInput | SortOrder
    cancellationFees?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
    _relevance?: RefundPolicyOrderByRelevanceInput
  }

  export type RefundPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RefundPolicyWhereInput | RefundPolicyWhereInput[]
    OR?: RefundPolicyWhereInput[]
    NOT?: RefundPolicyWhereInput | RefundPolicyWhereInput[]
    businessId?: StringFilter<"RefundPolicy"> | string
    name?: StringFilter<"RefundPolicy"> | string
    description?: StringNullableFilter<"RefundPolicy"> | string | null
    autoApproveTimeline?: IntNullableFilter<"RefundPolicy"> | number | null
    timeLimit?: IntNullableFilter<"RefundPolicy"> | number | null
    orderStatusRules?: JsonNullableFilter<"RefundPolicy">
    productRules?: JsonNullableFilter<"RefundPolicy">
    cancellationFees?: JsonNullableFilter<"RefundPolicy">
    isActive?: BoolFilter<"RefundPolicy"> | boolean
    createdAt?: DateTimeFilter<"RefundPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"RefundPolicy"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
  }, "id">

  export type RefundPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    autoApproveTimeline?: SortOrderInput | SortOrder
    timeLimit?: SortOrderInput | SortOrder
    orderStatusRules?: SortOrderInput | SortOrder
    productRules?: SortOrderInput | SortOrder
    cancellationFees?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RefundPolicyCountOrderByAggregateInput
    _avg?: RefundPolicyAvgOrderByAggregateInput
    _max?: RefundPolicyMaxOrderByAggregateInput
    _min?: RefundPolicyMinOrderByAggregateInput
    _sum?: RefundPolicySumOrderByAggregateInput
  }

  export type RefundPolicyScalarWhereWithAggregatesInput = {
    AND?: RefundPolicyScalarWhereWithAggregatesInput | RefundPolicyScalarWhereWithAggregatesInput[]
    OR?: RefundPolicyScalarWhereWithAggregatesInput[]
    NOT?: RefundPolicyScalarWhereWithAggregatesInput | RefundPolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefundPolicy"> | string
    businessId?: StringWithAggregatesFilter<"RefundPolicy"> | string
    name?: StringWithAggregatesFilter<"RefundPolicy"> | string
    description?: StringNullableWithAggregatesFilter<"RefundPolicy"> | string | null
    autoApproveTimeline?: IntNullableWithAggregatesFilter<"RefundPolicy"> | number | null
    timeLimit?: IntNullableWithAggregatesFilter<"RefundPolicy"> | number | null
    orderStatusRules?: JsonNullableWithAggregatesFilter<"RefundPolicy">
    productRules?: JsonNullableWithAggregatesFilter<"RefundPolicy">
    cancellationFees?: JsonNullableWithAggregatesFilter<"RefundPolicy">
    isActive?: BoolWithAggregatesFilter<"RefundPolicy"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RefundPolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefundPolicy"> | Date | string
  }

  export type SavedPaymentMethodWhereInput = {
    AND?: SavedPaymentMethodWhereInput | SavedPaymentMethodWhereInput[]
    OR?: SavedPaymentMethodWhereInput[]
    NOT?: SavedPaymentMethodWhereInput | SavedPaymentMethodWhereInput[]
    id?: StringFilter<"SavedPaymentMethod"> | string
    customerId?: StringFilter<"SavedPaymentMethod"> | string
    type?: EnumPaymentMethodFilter<"SavedPaymentMethod"> | $Enums.PaymentMethod
    provider?: EnumPaymentProviderFilter<"SavedPaymentMethod"> | $Enums.PaymentProvider
    isDefault?: BoolFilter<"SavedPaymentMethod"> | boolean
    nickName?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    cardBrand?: EnumCardBrandNullableFilter<"SavedPaymentMethod"> | $Enums.CardBrand | null
    cardLast4?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    cardExpMonth?: IntNullableFilter<"SavedPaymentMethod"> | number | null
    cardExpYear?: IntNullableFilter<"SavedPaymentMethod"> | number | null
    cardHolderName?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    bankName?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    bankAccountLast4?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    externalId?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    isActive?: BoolFilter<"SavedPaymentMethod"> | boolean
    metadata?: JsonNullableFilter<"SavedPaymentMethod">
    createdAt?: DateTimeFilter<"SavedPaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"SavedPaymentMethod"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    subscriptions?: SubscriptionListRelationFilter
  }

  export type SavedPaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrder
    nickName?: SortOrderInput | SortOrder
    cardBrand?: SortOrderInput | SortOrder
    cardLast4?: SortOrderInput | SortOrder
    cardExpMonth?: SortOrderInput | SortOrder
    cardExpYear?: SortOrderInput | SortOrder
    cardHolderName?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankAccountLast4?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    _relevance?: SavedPaymentMethodOrderByRelevanceInput
  }

  export type SavedPaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SavedPaymentMethodWhereInput | SavedPaymentMethodWhereInput[]
    OR?: SavedPaymentMethodWhereInput[]
    NOT?: SavedPaymentMethodWhereInput | SavedPaymentMethodWhereInput[]
    customerId?: StringFilter<"SavedPaymentMethod"> | string
    type?: EnumPaymentMethodFilter<"SavedPaymentMethod"> | $Enums.PaymentMethod
    provider?: EnumPaymentProviderFilter<"SavedPaymentMethod"> | $Enums.PaymentProvider
    isDefault?: BoolFilter<"SavedPaymentMethod"> | boolean
    nickName?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    cardBrand?: EnumCardBrandNullableFilter<"SavedPaymentMethod"> | $Enums.CardBrand | null
    cardLast4?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    cardExpMonth?: IntNullableFilter<"SavedPaymentMethod"> | number | null
    cardExpYear?: IntNullableFilter<"SavedPaymentMethod"> | number | null
    cardHolderName?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    bankName?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    bankAccountLast4?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    externalId?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    isActive?: BoolFilter<"SavedPaymentMethod"> | boolean
    metadata?: JsonNullableFilter<"SavedPaymentMethod">
    createdAt?: DateTimeFilter<"SavedPaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"SavedPaymentMethod"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    subscriptions?: SubscriptionListRelationFilter
  }, "id">

  export type SavedPaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrder
    nickName?: SortOrderInput | SortOrder
    cardBrand?: SortOrderInput | SortOrder
    cardLast4?: SortOrderInput | SortOrder
    cardExpMonth?: SortOrderInput | SortOrder
    cardExpYear?: SortOrderInput | SortOrder
    cardHolderName?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankAccountLast4?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SavedPaymentMethodCountOrderByAggregateInput
    _avg?: SavedPaymentMethodAvgOrderByAggregateInput
    _max?: SavedPaymentMethodMaxOrderByAggregateInput
    _min?: SavedPaymentMethodMinOrderByAggregateInput
    _sum?: SavedPaymentMethodSumOrderByAggregateInput
  }

  export type SavedPaymentMethodScalarWhereWithAggregatesInput = {
    AND?: SavedPaymentMethodScalarWhereWithAggregatesInput | SavedPaymentMethodScalarWhereWithAggregatesInput[]
    OR?: SavedPaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: SavedPaymentMethodScalarWhereWithAggregatesInput | SavedPaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SavedPaymentMethod"> | string
    customerId?: StringWithAggregatesFilter<"SavedPaymentMethod"> | string
    type?: EnumPaymentMethodWithAggregatesFilter<"SavedPaymentMethod"> | $Enums.PaymentMethod
    provider?: EnumPaymentProviderWithAggregatesFilter<"SavedPaymentMethod"> | $Enums.PaymentProvider
    isDefault?: BoolWithAggregatesFilter<"SavedPaymentMethod"> | boolean
    nickName?: StringNullableWithAggregatesFilter<"SavedPaymentMethod"> | string | null
    cardBrand?: EnumCardBrandNullableWithAggregatesFilter<"SavedPaymentMethod"> | $Enums.CardBrand | null
    cardLast4?: StringNullableWithAggregatesFilter<"SavedPaymentMethod"> | string | null
    cardExpMonth?: IntNullableWithAggregatesFilter<"SavedPaymentMethod"> | number | null
    cardExpYear?: IntNullableWithAggregatesFilter<"SavedPaymentMethod"> | number | null
    cardHolderName?: StringNullableWithAggregatesFilter<"SavedPaymentMethod"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"SavedPaymentMethod"> | string | null
    bankAccountLast4?: StringNullableWithAggregatesFilter<"SavedPaymentMethod"> | string | null
    externalId?: StringNullableWithAggregatesFilter<"SavedPaymentMethod"> | string | null
    isActive?: BoolWithAggregatesFilter<"SavedPaymentMethod"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"SavedPaymentMethod">
    createdAt?: DateTimeWithAggregatesFilter<"SavedPaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SavedPaymentMethod"> | Date | string
  }

  export type SubscriptionPlanWhereInput = {
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    id?: StringFilter<"SubscriptionPlan"> | string
    name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    price?: FloatFilter<"SubscriptionPlan"> | number
    currency?: StringFilter<"SubscriptionPlan"> | string
    interval?: EnumSubscriptionIntervalFilter<"SubscriptionPlan"> | $Enums.SubscriptionInterval
    intervalCount?: IntFilter<"SubscriptionPlan"> | number
    trialPeriodDays?: IntNullableFilter<"SubscriptionPlan"> | number | null
    features?: JsonNullableFilter<"SubscriptionPlan">
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    businessId?: StringNullableFilter<"SubscriptionPlan"> | string | null
    subscriptions?: SubscriptionListRelationFilter
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
  }

  export type SubscriptionPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessId?: SortOrderInput | SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    business?: BusinessOrderByWithRelationInput
    _relevance?: SubscriptionPlanOrderByRelevanceInput
  }

  export type SubscriptionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    price?: FloatFilter<"SubscriptionPlan"> | number
    currency?: StringFilter<"SubscriptionPlan"> | string
    interval?: EnumSubscriptionIntervalFilter<"SubscriptionPlan"> | $Enums.SubscriptionInterval
    intervalCount?: IntFilter<"SubscriptionPlan"> | number
    trialPeriodDays?: IntNullableFilter<"SubscriptionPlan"> | number | null
    features?: JsonNullableFilter<"SubscriptionPlan">
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    businessId?: StringNullableFilter<"SubscriptionPlan"> | string | null
    subscriptions?: SubscriptionListRelationFilter
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
  }, "id">

  export type SubscriptionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessId?: SortOrderInput | SortOrder
    _count?: SubscriptionPlanCountOrderByAggregateInput
    _avg?: SubscriptionPlanAvgOrderByAggregateInput
    _max?: SubscriptionPlanMaxOrderByAggregateInput
    _min?: SubscriptionPlanMinOrderByAggregateInput
    _sum?: SubscriptionPlanSumOrderByAggregateInput
  }

  export type SubscriptionPlanScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPlanScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    name?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    description?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    price?: FloatWithAggregatesFilter<"SubscriptionPlan"> | number
    currency?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    interval?: EnumSubscriptionIntervalWithAggregatesFilter<"SubscriptionPlan"> | $Enums.SubscriptionInterval
    intervalCount?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    trialPeriodDays?: IntNullableWithAggregatesFilter<"SubscriptionPlan"> | number | null
    features?: JsonNullableWithAggregatesFilter<"SubscriptionPlan">
    isActive?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
    businessId?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    customerId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEndDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    resumeAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    nextBillingDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    savedPaymentMethodId?: StringNullableFilter<"Subscription"> | string | null
    quantity?: IntFilter<"Subscription"> | number
    autoRenew?: BoolFilter<"Subscription"> | boolean
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    metadata?: JsonNullableFilter<"Subscription">
    externalId?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    businessId?: StringNullableFilter<"Subscription"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    plan?: XOR<SubscriptionPlanScalarRelationFilter, SubscriptionPlanWhereInput>
    savedPaymentMethod?: XOR<SavedPaymentMethodNullableScalarRelationFilter, SavedPaymentMethodWhereInput> | null
    recurringPayments?: RecurringPaymentListRelationFilter
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    trialEndDate?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    pausedAt?: SortOrderInput | SortOrder
    resumeAt?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    savedPaymentMethodId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    autoRenew?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    metadata?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessId?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    plan?: SubscriptionPlanOrderByWithRelationInput
    savedPaymentMethod?: SavedPaymentMethodOrderByWithRelationInput
    recurringPayments?: RecurringPaymentOrderByRelationAggregateInput
    business?: BusinessOrderByWithRelationInput
    _relevance?: SubscriptionOrderByRelevanceInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    customerId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEndDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    resumeAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    nextBillingDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    savedPaymentMethodId?: StringNullableFilter<"Subscription"> | string | null
    quantity?: IntFilter<"Subscription"> | number
    autoRenew?: BoolFilter<"Subscription"> | boolean
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    metadata?: JsonNullableFilter<"Subscription">
    externalId?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    businessId?: StringNullableFilter<"Subscription"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    plan?: XOR<SubscriptionPlanScalarRelationFilter, SubscriptionPlanWhereInput>
    savedPaymentMethod?: XOR<SavedPaymentMethodNullableScalarRelationFilter, SavedPaymentMethodWhereInput> | null
    recurringPayments?: RecurringPaymentListRelationFilter
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    trialEndDate?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    pausedAt?: SortOrderInput | SortOrder
    resumeAt?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    savedPaymentMethodId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    autoRenew?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    metadata?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessId?: SortOrderInput | SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    customerId?: StringWithAggregatesFilter<"Subscription"> | string
    planId?: StringWithAggregatesFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialEndDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    pausedAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    resumeAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    nextBillingDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    savedPaymentMethodId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    quantity?: IntWithAggregatesFilter<"Subscription"> | number
    autoRenew?: BoolWithAggregatesFilter<"Subscription"> | boolean
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Subscription">
    externalId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    businessId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
  }

  export type RecurringPaymentWhereInput = {
    AND?: RecurringPaymentWhereInput | RecurringPaymentWhereInput[]
    OR?: RecurringPaymentWhereInput[]
    NOT?: RecurringPaymentWhereInput | RecurringPaymentWhereInput[]
    id?: StringFilter<"RecurringPayment"> | string
    subscriptionId?: StringFilter<"RecurringPayment"> | string
    amount?: FloatFilter<"RecurringPayment"> | number
    status?: EnumPaymentStatusFilter<"RecurringPayment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"RecurringPayment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"RecurringPayment"> | Date | string
    dueDate?: DateTimeFilter<"RecurringPayment"> | Date | string
    description?: StringNullableFilter<"RecurringPayment"> | string | null
    externalId?: StringNullableFilter<"RecurringPayment"> | string | null
    createdAt?: DateTimeFilter<"RecurringPayment"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringPayment"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type RecurringPaymentOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
    _relevance?: RecurringPaymentOrderByRelevanceInput
  }

  export type RecurringPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecurringPaymentWhereInput | RecurringPaymentWhereInput[]
    OR?: RecurringPaymentWhereInput[]
    NOT?: RecurringPaymentWhereInput | RecurringPaymentWhereInput[]
    subscriptionId?: StringFilter<"RecurringPayment"> | string
    amount?: FloatFilter<"RecurringPayment"> | number
    status?: EnumPaymentStatusFilter<"RecurringPayment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"RecurringPayment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"RecurringPayment"> | Date | string
    dueDate?: DateTimeFilter<"RecurringPayment"> | Date | string
    description?: StringNullableFilter<"RecurringPayment"> | string | null
    externalId?: StringNullableFilter<"RecurringPayment"> | string | null
    createdAt?: DateTimeFilter<"RecurringPayment"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringPayment"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type RecurringPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecurringPaymentCountOrderByAggregateInput
    _avg?: RecurringPaymentAvgOrderByAggregateInput
    _max?: RecurringPaymentMaxOrderByAggregateInput
    _min?: RecurringPaymentMinOrderByAggregateInput
    _sum?: RecurringPaymentSumOrderByAggregateInput
  }

  export type RecurringPaymentScalarWhereWithAggregatesInput = {
    AND?: RecurringPaymentScalarWhereWithAggregatesInput | RecurringPaymentScalarWhereWithAggregatesInput[]
    OR?: RecurringPaymentScalarWhereWithAggregatesInput[]
    NOT?: RecurringPaymentScalarWhereWithAggregatesInput | RecurringPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecurringPayment"> | string
    subscriptionId?: StringWithAggregatesFilter<"RecurringPayment"> | string
    amount?: FloatWithAggregatesFilter<"RecurringPayment"> | number
    status?: EnumPaymentStatusWithAggregatesFilter<"RecurringPayment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"RecurringPayment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeWithAggregatesFilter<"RecurringPayment"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"RecurringPayment"> | Date | string
    description?: StringNullableWithAggregatesFilter<"RecurringPayment"> | string | null
    externalId?: StringNullableWithAggregatesFilter<"RecurringPayment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RecurringPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RecurringPayment"> | Date | string
  }

  export type DashboardMetricWhereInput = {
    AND?: DashboardMetricWhereInput | DashboardMetricWhereInput[]
    OR?: DashboardMetricWhereInput[]
    NOT?: DashboardMetricWhereInput | DashboardMetricWhereInput[]
    id?: IntFilter<"DashboardMetric"> | number
    metrics?: JsonFilter<"DashboardMetric">
    lastUpdated?: DateTimeFilter<"DashboardMetric"> | Date | string
  }

  export type DashboardMetricOrderByWithRelationInput = {
    id?: SortOrder
    metrics?: SortOrder
    lastUpdated?: SortOrder
  }

  export type DashboardMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DashboardMetricWhereInput | DashboardMetricWhereInput[]
    OR?: DashboardMetricWhereInput[]
    NOT?: DashboardMetricWhereInput | DashboardMetricWhereInput[]
    metrics?: JsonFilter<"DashboardMetric">
    lastUpdated?: DateTimeFilter<"DashboardMetric"> | Date | string
  }, "id">

  export type DashboardMetricOrderByWithAggregationInput = {
    id?: SortOrder
    metrics?: SortOrder
    lastUpdated?: SortOrder
    _count?: DashboardMetricCountOrderByAggregateInput
    _avg?: DashboardMetricAvgOrderByAggregateInput
    _max?: DashboardMetricMaxOrderByAggregateInput
    _min?: DashboardMetricMinOrderByAggregateInput
    _sum?: DashboardMetricSumOrderByAggregateInput
  }

  export type DashboardMetricScalarWhereWithAggregatesInput = {
    AND?: DashboardMetricScalarWhereWithAggregatesInput | DashboardMetricScalarWhereWithAggregatesInput[]
    OR?: DashboardMetricScalarWhereWithAggregatesInput[]
    NOT?: DashboardMetricScalarWhereWithAggregatesInput | DashboardMetricScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DashboardMetric"> | number
    metrics?: JsonWithAggregatesFilter<"DashboardMetric">
    lastUpdated?: DateTimeWithAggregatesFilter<"DashboardMetric"> | Date | string
  }

  export type EmailSettingsWhereInput = {
    AND?: EmailSettingsWhereInput | EmailSettingsWhereInput[]
    OR?: EmailSettingsWhereInput[]
    NOT?: EmailSettingsWhereInput | EmailSettingsWhereInput[]
    id?: IntFilter<"EmailSettings"> | number
    settings?: JsonFilter<"EmailSettings">
    lastUpdated?: DateTimeFilter<"EmailSettings"> | Date | string
  }

  export type EmailSettingsOrderByWithRelationInput = {
    id?: SortOrder
    settings?: SortOrder
    lastUpdated?: SortOrder
  }

  export type EmailSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmailSettingsWhereInput | EmailSettingsWhereInput[]
    OR?: EmailSettingsWhereInput[]
    NOT?: EmailSettingsWhereInput | EmailSettingsWhereInput[]
    settings?: JsonFilter<"EmailSettings">
    lastUpdated?: DateTimeFilter<"EmailSettings"> | Date | string
  }, "id">

  export type EmailSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    settings?: SortOrder
    lastUpdated?: SortOrder
    _count?: EmailSettingsCountOrderByAggregateInput
    _avg?: EmailSettingsAvgOrderByAggregateInput
    _max?: EmailSettingsMaxOrderByAggregateInput
    _min?: EmailSettingsMinOrderByAggregateInput
    _sum?: EmailSettingsSumOrderByAggregateInput
  }

  export type EmailSettingsScalarWhereWithAggregatesInput = {
    AND?: EmailSettingsScalarWhereWithAggregatesInput | EmailSettingsScalarWhereWithAggregatesInput[]
    OR?: EmailSettingsScalarWhereWithAggregatesInput[]
    NOT?: EmailSettingsScalarWhereWithAggregatesInput | EmailSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmailSettings"> | number
    settings?: JsonWithAggregatesFilter<"EmailSettings">
    lastUpdated?: DateTimeWithAggregatesFilter<"EmailSettings"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutUserInput
    business?: BusinessCreateNestedOneWithoutUserInput
    courier?: CourierCreateNestedOneWithoutUserInput
    customer?: CustomerCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    business?: BusinessUncheckedCreateNestedOneWithoutUserInput
    courier?: CourierUncheckedCreateNestedOneWithoutUserInput
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    business?: BusinessUpdateOneWithoutUserNestedInput
    courier?: CourierUpdateOneWithoutUserNestedInput
    customer?: CustomerUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    business?: BusinessUncheckedUpdateOneWithoutUserNestedInput
    courier?: CourierUncheckedUpdateOneWithoutUserNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    department?: string | null
    level?: number
    permissions?: AdminCreatepermissionsInput | string[]
    title?: string | null
    phone?: string | null
    profileImage?: string | null
    lastLogin?: Date | string | null
    loginAttempts?: number
    isSuperAdmin?: boolean
    ipRestrictions?: AdminCreateipRestrictionsInput | string[]
    user: UserCreateNestedOneWithoutAdminInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    systemActions?: SystemActionCreateNestedManyWithoutAdminInput
    dashboardWidgets?: AdminDashboardWidgetCreateNestedManyWithoutAdminInput
    roleMappings?: AdminRoleMappingCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    userId: string
    department?: string | null
    level?: number
    permissions?: AdminCreatepermissionsInput | string[]
    title?: string | null
    phone?: string | null
    profileImage?: string | null
    lastLogin?: Date | string | null
    loginAttempts?: number
    isSuperAdmin?: boolean
    ipRestrictions?: AdminCreateipRestrictionsInput | string[]
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    systemActions?: SystemActionUncheckedCreateNestedManyWithoutAdminInput
    dashboardWidgets?: AdminDashboardWidgetUncheckedCreateNestedManyWithoutAdminInput
    roleMappings?: AdminRoleMappingUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    permissions?: AdminUpdatepermissionsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    ipRestrictions?: AdminUpdateipRestrictionsInput | string[]
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    systemActions?: SystemActionUpdateManyWithoutAdminNestedInput
    dashboardWidgets?: AdminDashboardWidgetUpdateManyWithoutAdminNestedInput
    roleMappings?: AdminRoleMappingUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    permissions?: AdminUpdatepermissionsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    ipRestrictions?: AdminUpdateipRestrictionsInput | string[]
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    systemActions?: SystemActionUncheckedUpdateManyWithoutAdminNestedInput
    dashboardWidgets?: AdminDashboardWidgetUncheckedUpdateManyWithoutAdminNestedInput
    roleMappings?: AdminRoleMappingUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateManyInput = {
    id?: string
    userId: string
    department?: string | null
    level?: number
    permissions?: AdminCreatepermissionsInput | string[]
    title?: string | null
    phone?: string | null
    profileImage?: string | null
    lastLogin?: Date | string | null
    loginAttempts?: number
    isSuperAdmin?: boolean
    ipRestrictions?: AdminCreateipRestrictionsInput | string[]
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    permissions?: AdminUpdatepermissionsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    ipRestrictions?: AdminUpdateipRestrictionsInput | string[]
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    permissions?: AdminUpdatepermissionsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    ipRestrictions?: AdminUpdateipRestrictionsInput | string[]
  }

  export type CourierCreateInput = {
    id?: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    user: UserCreateNestedOneWithoutCourierInput
    zone?: ZoneCreateNestedOneWithoutCouriersInput
    orders?: OrderCreateNestedManyWithoutCourierInput
    notifications?: NotificationCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    payments?: PaymentCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteCreateNestedManyWithoutCourierInput
  }

  export type CourierUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    zoneId?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedCreateNestedManyWithoutCourierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityUncheckedCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteUncheckedCreateNestedManyWithoutCourierInput
  }

  export type CourierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    zone?: ZoneUpdateOneWithoutCouriersNestedInput
    orders?: OrderUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    payments?: PaymentUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUpdateManyWithoutCourierNestedInput
  }

  export type CourierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUncheckedUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUncheckedUpdateManyWithoutCourierNestedInput
  }

  export type CourierCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    zoneId?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
  }

  export type CourierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
  }

  export type CourierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
  }

  export type OrderCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    priority?: $Enums.DeliveryPriority
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    business: BusinessCreateNestedOneWithoutOrdersInput
    courier?: CourierCreateNestedOneWithoutOrdersInput
    notifications?: NotificationCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    requestedTimeWindow?: DeliveryTimeWindowCreateNestedOneWithoutOrdersInput
    delivery?: DeliveryCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    customerId: string
    businessId: string
    courierId?: string | null
    priority?: $Enums.DeliveryPriority
    timeWindowId?: string | null
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    delivery?: DeliveryUncheckedCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    business?: BusinessUpdateOneRequiredWithoutOrdersNestedInput
    courier?: CourierUpdateOneWithoutOrdersNestedInput
    notifications?: NotificationUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    requestedTimeWindow?: DeliveryTimeWindowUpdateOneWithoutOrdersNestedInput
    delivery?: DeliveryUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    timeWindowId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    delivery?: DeliveryUncheckedUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    customerId: string
    businessId: string
    courierId?: string | null
    priority?: $Enums.DeliveryPriority
    timeWindowId?: string | null
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    timeWindowId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerCreateInput = {
    id?: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    deliveries?: DeliveryCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    userId: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    deliveries?: DeliveryUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    userId: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessCreateInput = {
    id?: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    user: UserCreateNestedOneWithoutBusinessInput
    zone?: ZoneCreateNestedOneWithoutBusinessesInput
    inventory?: InventoryCreateNestedManyWithoutBusinessInput
    orders?: OrderCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBusinessInput
    payments?: PaymentCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    zoneId?: string | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    inventory?: InventoryUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrderUncheckedCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBusinessInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyUncheckedCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    zone?: ZoneUpdateOneWithoutBusinessesNestedInput
    inventory?: InventoryUpdateManyWithoutBusinessNestedInput
    orders?: OrderUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    inventory?: InventoryUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUncheckedUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    zoneId?: string | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
  }

  export type BusinessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
  }

  export type BusinessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
  }

  export type ZoneCreateInput = {
    id?: string
    name: string
    description?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    averageDeliveryTime?: number | null
    orderVolume?: number | null
    activeBusinesses?: number | null
    businesses?: BusinessCreateNestedManyWithoutZoneInput
    couriers?: CourierCreateNestedManyWithoutZoneInput
    deliveries?: DeliveryCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    averageDeliveryTime?: number | null
    orderVolume?: number | null
    activeBusinesses?: number | null
    businesses?: BusinessUncheckedCreateNestedManyWithoutZoneInput
    couriers?: CourierUncheckedCreateNestedManyWithoutZoneInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    averageDeliveryTime?: NullableIntFieldUpdateOperationsInput | number | null
    orderVolume?: NullableIntFieldUpdateOperationsInput | number | null
    activeBusinesses?: NullableIntFieldUpdateOperationsInput | number | null
    businesses?: BusinessUpdateManyWithoutZoneNestedInput
    couriers?: CourierUpdateManyWithoutZoneNestedInput
    deliveries?: DeliveryUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    averageDeliveryTime?: NullableIntFieldUpdateOperationsInput | number | null
    orderVolume?: NullableIntFieldUpdateOperationsInput | number | null
    activeBusinesses?: NullableIntFieldUpdateOperationsInput | number | null
    businesses?: BusinessUncheckedUpdateManyWithoutZoneNestedInput
    couriers?: CourierUncheckedUpdateManyWithoutZoneNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    averageDeliveryTime?: number | null
    orderVolume?: number | null
    activeBusinesses?: number | null
  }

  export type ZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    averageDeliveryTime?: NullableIntFieldUpdateOperationsInput | number | null
    orderVolume?: NullableIntFieldUpdateOperationsInput | number | null
    activeBusinesses?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    averageDeliveryTime?: NullableIntFieldUpdateOperationsInput | number | null
    orderVolume?: NullableIntFieldUpdateOperationsInput | number | null
    activeBusinesses?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationPreferenceCreateInput = {
    id?: string
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
    frequency?: $Enums.NotificationFrequency
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationPreferencesInput
    courier?: CourierCreateNestedOneWithoutNotificationPreferencesInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    courierId?: string | null
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
    frequency?: $Enums.NotificationFrequency
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    frequency?: EnumNotificationFrequencyFieldUpdateOperationsInput | $Enums.NotificationFrequency
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput
    courier?: CourierUpdateOneWithoutNotificationPreferencesNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    frequency?: EnumNotificationFrequencyFieldUpdateOperationsInput | $Enums.NotificationFrequency
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: string
    userId: string
    courierId?: string | null
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
    frequency?: $Enums.NotificationFrequency
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    frequency?: EnumNotificationFrequencyFieldUpdateOperationsInput | $Enums.NotificationFrequency
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    frequency?: EnumNotificationFrequencyFieldUpdateOperationsInput | $Enums.NotificationFrequency
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutNotificationsInput
    courier?: CourierCreateNestedOneWithoutNotificationsInput
    order?: OrderCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    userId: string
    courierId?: string | null
    orderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    courier?: CourierUpdateOneWithoutNotificationsNestedInput
    order?: OrderUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    userId: string
    courierId?: string | null
    orderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DeliveryCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
    courier: CourierCreateNestedOneWithoutDeliveriesInput
    customer: CustomerCreateNestedOneWithoutDeliveriesInput
    zone: ZoneCreateNestedOneWithoutDeliveriesInput
    order?: OrderCreateNestedOneWithoutDeliveryInput
    route?: DeliveryRouteCreateNestedOneWithoutDeliveriesInput
  }

  export type DeliveryUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    courierId: string
    customerId: string
    zoneId: string
    orderId?: string | null
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    routeId?: string | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
  }

  export type DeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    courier?: CourierUpdateOneRequiredWithoutDeliveriesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutDeliveriesNestedInput
    zone?: ZoneUpdateOneRequiredWithoutDeliveriesNestedInput
    order?: OrderUpdateOneWithoutDeliveryNestedInput
    route?: DeliveryRouteUpdateOneWithoutDeliveriesNestedInput
  }

  export type DeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
  }

  export type DeliveryCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    courierId: string
    customerId: string
    zoneId: string
    orderId?: string | null
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    routeId?: string | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
  }

  export type DeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
  }

  export type DeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
  }

  export type InventoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    price: number
    sku?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutInventoryInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    quantity: number
    price: number
    sku?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
  }

  export type InventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutInventoryNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryCreateManyInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    quantity: number
    price: number
    sku?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
  }

  export type InventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryLogCreateInput = {
    id?: string
    action: string
    timestamp?: Date | string
    latitude?: number | null
    longitude?: number | null
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    courier: CourierCreateNestedOneWithoutDeliveryLogsInput
  }

  export type DeliveryLogUncheckedCreateInput = {
    id?: string
    courierId: string
    action: string
    timestamp?: Date | string
    latitude?: number | null
    longitude?: number | null
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DeliveryLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    courier?: CourierUpdateOneRequiredWithoutDeliveryLogsNestedInput
  }

  export type DeliveryLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DeliveryLogCreateManyInput = {
    id?: string
    courierId: string
    action: string
    timestamp?: Date | string
    latitude?: number | null
    longitude?: number | null
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DeliveryLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DeliveryLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportCreateInput = {
    id?: string
    name: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    expiresAt?: Date | string | null
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCreateManyInput = {
    id?: string
    userId: string
    name: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    expiresAt?: Date | string | null
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduleCreateInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ScheduledReportCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ScheduledReportUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ScheduledReportUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ScheduledReportUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleCreateManyInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportCreateInput = {
    id?: string
    reportName: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    recipients?: ScheduledReportCreaterecipientsInput | string[]
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutScheduledReportsInput
    schedule: ScheduleCreateNestedOneWithoutReportsInput
  }

  export type ScheduledReportUncheckedCreateInput = {
    id?: string
    userId: string
    scheduleId: string
    reportName: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    recipients?: ScheduledReportCreaterecipientsInput | string[]
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    recipients?: ScheduledReportUpdaterecipientsInput | string[]
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutScheduledReportsNestedInput
    schedule?: ScheduleUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ScheduledReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    recipients?: ScheduledReportUpdaterecipientsInput | string[]
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportCreateManyInput = {
    id?: string
    userId: string
    scheduleId: string
    reportName: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    recipients?: ScheduledReportCreaterecipientsInput | string[]
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    recipients?: ScheduledReportUpdaterecipientsInput | string[]
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    recipients?: ScheduledReportUpdaterecipientsInput | string[]
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateInput = {
    id?: string
    language?: string
    theme?: string
    notifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    language?: string
    theme?: string
    notifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateManyInput = {
    id?: string
    userId: string
    language?: string
    theme?: string
    notifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    imageUrl?: string | null
    category?: string | null
    tags?: MenuItemCreatetagsInput | string[]
    ingredients?: MenuItemCreateingredientsInput | string[]
    calories?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutMenuItemsInput
  }

  export type MenuItemUncheckedCreateInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    price: number
    imageUrl?: string | null
    category?: string | null
    tags?: MenuItemCreatetagsInput | string[]
    ingredients?: MenuItemCreateingredientsInput | string[]
    calories?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MenuItemUpdatetagsInput | string[]
    ingredients?: MenuItemUpdateingredientsInput | string[]
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutMenuItemsNestedInput
  }

  export type MenuItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MenuItemUpdatetagsInput | string[]
    ingredients?: MenuItemUpdateingredientsInput | string[]
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemCreateManyInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    price: number
    imageUrl?: string | null
    category?: string | null
    tags?: MenuItemCreatetagsInput | string[]
    ingredients?: MenuItemCreateingredientsInput | string[]
    calories?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MenuItemUpdatetagsInput | string[]
    ingredients?: MenuItemUpdateingredientsInput | string[]
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MenuItemUpdatetagsInput | string[]
    ingredients?: MenuItemUpdateingredientsInput | string[]
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourierAvailabilityCreateInput = {
    id?: string
    status: $Enums.CourierAvailabilityStatus
    startTime: Date | string
    endTime?: Date | string | null
    note?: string | null
    createdAt?: Date | string
    courier: CourierCreateNestedOneWithoutAvailabilityInput
  }

  export type CourierAvailabilityUncheckedCreateInput = {
    id?: string
    courierId: string
    status: $Enums.CourierAvailabilityStatus
    startTime: Date | string
    endTime?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type CourierAvailabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courier?: CourierUpdateOneRequiredWithoutAvailabilityNestedInput
  }

  export type CourierAvailabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    status?: EnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourierAvailabilityCreateManyInput = {
    id?: string
    courierId: string
    status: $Enums.CourierAvailabilityStatus
    startTime: Date | string
    endTime?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type CourierAvailabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourierAvailabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    status?: EnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryTimeWindowCreateInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    description?: string | null
    priorityFactor?: number
    orders?: OrderCreateNestedManyWithoutRequestedTimeWindowInput
  }

  export type DeliveryTimeWindowUncheckedCreateInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    description?: string | null
    priorityFactor?: number
    orders?: OrderUncheckedCreateNestedManyWithoutRequestedTimeWindowInput
  }

  export type DeliveryTimeWindowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorityFactor?: FloatFieldUpdateOperationsInput | number
    orders?: OrderUpdateManyWithoutRequestedTimeWindowNestedInput
  }

  export type DeliveryTimeWindowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorityFactor?: FloatFieldUpdateOperationsInput | number
    orders?: OrderUncheckedUpdateManyWithoutRequestedTimeWindowNestedInput
  }

  export type DeliveryTimeWindowCreateManyInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    description?: string | null
    priorityFactor?: number
  }

  export type DeliveryTimeWindowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorityFactor?: FloatFieldUpdateOperationsInput | number
  }

  export type DeliveryTimeWindowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorityFactor?: FloatFieldUpdateOperationsInput | number
  }

  export type DeliveryRouteCreateInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.Status
    totalDistance?: number | null
    totalDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
    courier: CourierCreateNestedOneWithoutDeliveryRoutesInput
    deliveries?: DeliveryCreateNestedManyWithoutRouteInput
  }

  export type DeliveryRouteUncheckedCreateInput = {
    id?: string
    courierId: string
    name?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.Status
    totalDistance?: number | null
    totalDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutRouteInput
  }

  export type DeliveryRouteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
    courier?: CourierUpdateOneRequiredWithoutDeliveryRoutesNestedInput
    deliveries?: DeliveryUpdateManyWithoutRouteNestedInput
  }

  export type DeliveryRouteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
    deliveries?: DeliveryUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type DeliveryRouteCreateManyInput = {
    id?: string
    courierId: string
    name?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.Status
    totalDistance?: number | null
    totalDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DeliveryRouteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DeliveryRouteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    order?: OrderCreateNestedOneWithoutPaymentsInput
    recipient?: CourierCreateNestedOneWithoutPaymentsInput
    business?: BusinessCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    orderId?: string | null
    recipientId?: string | null
    businessId?: string | null
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneWithoutPaymentsNestedInput
    recipient?: CourierUpdateOneWithoutPaymentsNestedInput
    business?: BusinessUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    orderId?: string | null
    recipientId?: string | null
    businessId?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutProductCategoriesInput
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    products?: InventoryCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    slug: string
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
    products?: InventoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutProductCategoriesNestedInput
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    products?: InventoryUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: InventoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    slug: string
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
  }

  export type ProductCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogCreateInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    targetId?: string | null
    targetType?: string | null
    ip?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: string | null
    category?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    user?: UserCreateNestedOneWithoutActivityLogsInput
    admin?: AdminCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    userId?: string | null
    targetId?: string | null
    targetType?: string | null
    ip?: string | null
    userAgent?: string | null
    adminId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: string | null
    category?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutActivityLogsNestedInput
    admin?: AdminUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    userId?: string | null
    targetId?: string | null
    targetType?: string | null
    ip?: string | null
    userAgent?: string | null
    adminId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: string | null
    category?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemActionCreateInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    status?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    executionTime?: number | null
    admin?: AdminCreateNestedOneWithoutSystemActionsInput
  }

  export type SystemActionUncheckedCreateInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    adminId?: string | null
    status?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    executionTime?: number | null
  }

  export type SystemActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    admin?: AdminUpdateOneWithoutSystemActionsNestedInput
  }

  export type SystemActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SystemActionCreateManyInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    adminId?: string | null
    status?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    executionTime?: number | null
  }

  export type SystemActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SystemActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SystemSettingsCreateInput = {
    id?: string
    key: string
    value: string
    category: string
    description?: string | null
    dataType: string
    isEncrypted?: boolean
    lastUpdated?: Date | string
    updatedBy?: string | null
  }

  export type SystemSettingsUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    category: string
    description?: string | null
    dataType: string
    isEncrypted?: boolean
    lastUpdated?: Date | string
    updatedBy?: string | null
  }

  export type SystemSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemSettingsCreateManyInput = {
    id?: string
    key: string
    value: string
    category: string
    description?: string | null
    dataType: string
    isEncrypted?: boolean
    lastUpdated?: Date | string
    updatedBy?: string | null
  }

  export type SystemSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: StringFieldUpdateOperationsInput | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminDashboardWidgetCreateInput = {
    id?: string
    name: string
    type: string
    position?: number
    size?: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutDashboardWidgetsInput
  }

  export type AdminDashboardWidgetUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    position?: number
    size?: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminDashboardWidgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutDashboardWidgetsNestedInput
  }

  export type AdminDashboardWidgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminDashboardWidgetCreateManyInput = {
    id?: string
    name: string
    type: string
    position?: number
    size?: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminDashboardWidgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminDashboardWidgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPermissionCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    adminRoles?: AdminRoleCreateNestedManyWithoutPermissionsInput
  }

  export type AdminPermissionUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    adminRoles?: AdminRoleUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type AdminPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminRoles?: AdminRoleUpdateManyWithoutPermissionsNestedInput
  }

  export type AdminPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminRoles?: AdminRoleUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type AdminPermissionCreateManyInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: AdminPermissionCreateNestedManyWithoutAdminRolesInput
    admins?: AdminRoleMappingCreateNestedManyWithoutRoleInput
  }

  export type AdminRoleUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: AdminPermissionUncheckedCreateNestedManyWithoutAdminRolesInput
    admins?: AdminRoleMappingUncheckedCreateNestedManyWithoutRoleInput
  }

  export type AdminRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: AdminPermissionUpdateManyWithoutAdminRolesNestedInput
    admins?: AdminRoleMappingUpdateManyWithoutRoleNestedInput
  }

  export type AdminRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: AdminPermissionUncheckedUpdateManyWithoutAdminRolesNestedInput
    admins?: AdminRoleMappingUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type AdminRoleCreateManyInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleMappingCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutRoleMappingsInput
    role: AdminRoleCreateNestedOneWithoutAdminsInput
  }

  export type AdminRoleMappingUncheckedCreateInput = {
    id?: string
    adminId: string
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminRoleMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutRoleMappingsNestedInput
    role?: AdminRoleUpdateOneRequiredWithoutAdminsNestedInput
  }

  export type AdminRoleMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleMappingCreateManyInput = {
    id?: string
    adminId: string
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminRoleMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateInput = {
    id?: string
    name: string
    subject: string
    body: string
    category: string
    description?: string | null
    isActive?: boolean
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    sentEmails?: SentEmailCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    body: string
    category: string
    description?: string | null
    isActive?: boolean
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type EmailTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sentEmails?: SentEmailUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sentEmails?: SentEmailUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type EmailTemplateCreateManyInput = {
    id?: string
    name: string
    subject: string
    body: string
    category: string
    description?: string | null
    isActive?: boolean
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type EmailTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SentEmailCreateInput = {
    id?: string
    recipient: string
    subject: string
    variables: string
    messageId?: string | null
    sentBy: string
    sentAt?: Date | string
    status?: string
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    template: EmailTemplateCreateNestedOneWithoutSentEmailsInput
  }

  export type SentEmailUncheckedCreateInput = {
    id?: string
    templateId: string
    recipient: string
    subject: string
    variables: string
    messageId?: string | null
    sentBy: string
    sentAt?: Date | string
    status?: string
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SentEmailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    sentBy?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: EmailTemplateUpdateOneRequiredWithoutSentEmailsNestedInput
  }

  export type SentEmailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    sentBy?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SentEmailCreateManyInput = {
    id?: string
    templateId: string
    recipient: string
    subject: string
    variables: string
    messageId?: string | null
    sentBy: string
    sentAt?: Date | string
    status?: string
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SentEmailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    sentBy?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SentEmailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    sentBy?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressCreateInput = {
    id?: string
    title: string
    firstName: string
    lastName: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    postalCode: string
    country?: string
    phone?: string | null
    notes?: string | null
    latitude?: number | null
    longitude?: number | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutAddressesInput
  }

  export type CustomerAddressUncheckedCreateInput = {
    id?: string
    customerId: string
    title: string
    firstName: string
    lastName: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    postalCode: string
    country?: string
    phone?: string | null
    notes?: string | null
    latitude?: number | null
    longitude?: number | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type CustomerAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressCreateManyInput = {
    id?: string
    customerId: string
    title: string
    firstName: string
    lastName: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    postalCode: string
    country?: string
    phone?: string | null
    notes?: string | null
    latitude?: number | null
    longitude?: number | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundRequestCreateInput = {
    id?: string
    status?: $Enums.RefundRequestStatus
    reason: $Enums.RefundReason
    otherReason?: string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: number | null
    approvedAmount?: number | null
    evidenceUrls?: RefundRequestCreateevidenceUrlsInput | string[]
    adminNotes?: string | null
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    refundedAt?: Date | string | null
    order: OrderCreateNestedOneWithoutRefundRequestsInput
    customer: CustomerCreateNestedOneWithoutRefundRequestsInput
    business: BusinessCreateNestedOneWithoutRefundRequestsInput
  }

  export type RefundRequestUncheckedCreateInput = {
    id?: string
    orderId: string
    customerId: string
    businessId: string
    status?: $Enums.RefundRequestStatus
    reason: $Enums.RefundReason
    otherReason?: string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: number | null
    approvedAmount?: number | null
    evidenceUrls?: RefundRequestCreateevidenceUrlsInput | string[]
    adminNotes?: string | null
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    refundedAt?: Date | string | null
  }

  export type RefundRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundRequestStatusFieldUpdateOperationsInput | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFieldUpdateOperationsInput | $Enums.RefundReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evidenceUrls?: RefundRequestUpdateevidenceUrlsInput | string[]
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutRefundRequestsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutRefundRequestsNestedInput
    business?: BusinessUpdateOneRequiredWithoutRefundRequestsNestedInput
  }

  export type RefundRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundRequestStatusFieldUpdateOperationsInput | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFieldUpdateOperationsInput | $Enums.RefundReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evidenceUrls?: RefundRequestUpdateevidenceUrlsInput | string[]
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundRequestCreateManyInput = {
    id?: string
    orderId: string
    customerId: string
    businessId: string
    status?: $Enums.RefundRequestStatus
    reason: $Enums.RefundReason
    otherReason?: string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: number | null
    approvedAmount?: number | null
    evidenceUrls?: RefundRequestCreateevidenceUrlsInput | string[]
    adminNotes?: string | null
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    refundedAt?: Date | string | null
  }

  export type RefundRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundRequestStatusFieldUpdateOperationsInput | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFieldUpdateOperationsInput | $Enums.RefundReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evidenceUrls?: RefundRequestUpdateevidenceUrlsInput | string[]
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundRequestStatusFieldUpdateOperationsInput | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFieldUpdateOperationsInput | $Enums.RefundReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evidenceUrls?: RefundRequestUpdateevidenceUrlsInput | string[]
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CancellationRequestCreateInput = {
    id?: string
    status?: $Enums.CancellationRequestStatus
    reason: $Enums.CancellationReason
    otherReason?: string | null
    cancellationFee?: number | null
    autoProcessed?: boolean
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    cancelledAt?: Date | string | null
    order: OrderCreateNestedOneWithoutCancellationRequestsInput
    customer: CustomerCreateNestedOneWithoutCancellationRequestsInput
    business: BusinessCreateNestedOneWithoutCancellationRequestsInput
  }

  export type CancellationRequestUncheckedCreateInput = {
    id?: string
    orderId: string
    customerId: string
    businessId: string
    status?: $Enums.CancellationRequestStatus
    reason: $Enums.CancellationReason
    otherReason?: string | null
    cancellationFee?: number | null
    autoProcessed?: boolean
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    cancelledAt?: Date | string | null
  }

  export type CancellationRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCancellationRequestStatusFieldUpdateOperationsInput | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFieldUpdateOperationsInput | $Enums.CancellationReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    autoProcessed?: BoolFieldUpdateOperationsInput | boolean
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutCancellationRequestsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutCancellationRequestsNestedInput
    business?: BusinessUpdateOneRequiredWithoutCancellationRequestsNestedInput
  }

  export type CancellationRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    status?: EnumCancellationRequestStatusFieldUpdateOperationsInput | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFieldUpdateOperationsInput | $Enums.CancellationReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    autoProcessed?: BoolFieldUpdateOperationsInput | boolean
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CancellationRequestCreateManyInput = {
    id?: string
    orderId: string
    customerId: string
    businessId: string
    status?: $Enums.CancellationRequestStatus
    reason: $Enums.CancellationReason
    otherReason?: string | null
    cancellationFee?: number | null
    autoProcessed?: boolean
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    cancelledAt?: Date | string | null
  }

  export type CancellationRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCancellationRequestStatusFieldUpdateOperationsInput | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFieldUpdateOperationsInput | $Enums.CancellationReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    autoProcessed?: BoolFieldUpdateOperationsInput | boolean
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CancellationRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    status?: EnumCancellationRequestStatusFieldUpdateOperationsInput | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFieldUpdateOperationsInput | $Enums.CancellationReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    autoProcessed?: BoolFieldUpdateOperationsInput | boolean
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundPolicyCreateInput = {
    id?: string
    name: string
    description?: string | null
    autoApproveTimeline?: number | null
    timeLimit?: number | null
    orderStatusRules?: NullableJsonNullValueInput | InputJsonValue
    productRules?: NullableJsonNullValueInput | InputJsonValue
    cancellationFees?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutRefundPoliciesInput
  }

  export type RefundPolicyUncheckedCreateInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    autoApproveTimeline?: number | null
    timeLimit?: number | null
    orderStatusRules?: NullableJsonNullValueInput | InputJsonValue
    productRules?: NullableJsonNullValueInput | InputJsonValue
    cancellationFees?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundPolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    autoApproveTimeline?: NullableIntFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    orderStatusRules?: NullableJsonNullValueInput | InputJsonValue
    productRules?: NullableJsonNullValueInput | InputJsonValue
    cancellationFees?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutRefundPoliciesNestedInput
  }

  export type RefundPolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    autoApproveTimeline?: NullableIntFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    orderStatusRules?: NullableJsonNullValueInput | InputJsonValue
    productRules?: NullableJsonNullValueInput | InputJsonValue
    cancellationFees?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundPolicyCreateManyInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    autoApproveTimeline?: number | null
    timeLimit?: number | null
    orderStatusRules?: NullableJsonNullValueInput | InputJsonValue
    productRules?: NullableJsonNullValueInput | InputJsonValue
    cancellationFees?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundPolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    autoApproveTimeline?: NullableIntFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    orderStatusRules?: NullableJsonNullValueInput | InputJsonValue
    productRules?: NullableJsonNullValueInput | InputJsonValue
    cancellationFees?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundPolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    autoApproveTimeline?: NullableIntFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    orderStatusRules?: NullableJsonNullValueInput | InputJsonValue
    productRules?: NullableJsonNullValueInput | InputJsonValue
    cancellationFees?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedPaymentMethodCreateInput = {
    id?: string
    type: $Enums.PaymentMethod
    provider: $Enums.PaymentProvider
    isDefault?: boolean
    nickName?: string | null
    cardBrand?: $Enums.CardBrand | null
    cardLast4?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    cardHolderName?: string | null
    bankName?: string | null
    bankAccountLast4?: string | null
    externalId?: string | null
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSavedPaymentMethodsInput
    subscriptions?: SubscriptionCreateNestedManyWithoutSavedPaymentMethodInput
  }

  export type SavedPaymentMethodUncheckedCreateInput = {
    id?: string
    customerId: string
    type: $Enums.PaymentMethod
    provider: $Enums.PaymentProvider
    isDefault?: boolean
    nickName?: string | null
    cardBrand?: $Enums.CardBrand | null
    cardLast4?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    cardHolderName?: string | null
    bankName?: string | null
    bankAccountLast4?: string | null
    externalId?: string | null
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutSavedPaymentMethodInput
  }

  export type SavedPaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableEnumCardBrandFieldUpdateOperationsInput | $Enums.CardBrand | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    cardHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSavedPaymentMethodsNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutSavedPaymentMethodNestedInput
  }

  export type SavedPaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableEnumCardBrandFieldUpdateOperationsInput | $Enums.CardBrand | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    cardHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutSavedPaymentMethodNestedInput
  }

  export type SavedPaymentMethodCreateManyInput = {
    id?: string
    customerId: string
    type: $Enums.PaymentMethod
    provider: $Enums.PaymentProvider
    isDefault?: boolean
    nickName?: string | null
    cardBrand?: $Enums.CardBrand | null
    cardLast4?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    cardHolderName?: string | null
    bankName?: string | null
    bankAccountLast4?: string | null
    externalId?: string | null
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedPaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableEnumCardBrandFieldUpdateOperationsInput | $Enums.CardBrand | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    cardHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedPaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableEnumCardBrandFieldUpdateOperationsInput | $Enums.CardBrand | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    cardHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval?: $Enums.SubscriptionInterval
    intervalCount?: number
    trialPeriodDays?: number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
    business?: BusinessCreateNestedOneWithoutSubscriptionPlansInput
  }

  export type SubscriptionPlanUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval?: $Enums.SubscriptionInterval
    intervalCount?: number
    trialPeriodDays?: number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessId?: string | null
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
    business?: BusinessUpdateOneWithoutSubscriptionPlansNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval?: $Enums.SubscriptionInterval
    intervalCount?: number
    trialPeriodDays?: number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessId?: string | null
  }

  export type SubscriptionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionCreateInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    savedPaymentMethod?: SavedPaymentMethodCreateNestedOneWithoutSubscriptionsInput
    recurringPayments?: RecurringPaymentCreateNestedManyWithoutSubscriptionInput
    business?: BusinessCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    customerId: string
    planId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    savedPaymentMethodId?: string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessId?: string | null
    recurringPayments?: RecurringPaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    savedPaymentMethod?: SavedPaymentMethodUpdateOneWithoutSubscriptionsNestedInput
    recurringPayments?: RecurringPaymentUpdateManyWithoutSubscriptionNestedInput
    business?: BusinessUpdateOneWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    recurringPayments?: RecurringPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    customerId: string
    planId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    savedPaymentMethodId?: string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessId?: string | null
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecurringPaymentCreateInput = {
    id?: string
    amount: number
    status: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date | string
    dueDate: Date | string
    description?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutRecurringPaymentsInput
  }

  export type RecurringPaymentUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    amount: number
    status: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date | string
    dueDate: Date | string
    description?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutRecurringPaymentsNestedInput
  }

  export type RecurringPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringPaymentCreateManyInput = {
    id?: string
    subscriptionId: string
    amount: number
    status: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date | string
    dueDate: Date | string
    description?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardMetricCreateInput = {
    id?: number
    metrics: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
  }

  export type DashboardMetricUncheckedCreateInput = {
    id?: number
    metrics: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
  }

  export type DashboardMetricUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    metrics?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardMetricUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    metrics?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardMetricCreateManyInput = {
    id?: number
    metrics: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
  }

  export type DashboardMetricUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    metrics?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardMetricUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    metrics?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSettingsCreateInput = {
    id?: number
    settings: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
  }

  export type EmailSettingsUncheckedCreateInput = {
    id?: number
    settings: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
  }

  export type EmailSettingsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    settings?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    settings?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSettingsCreateManyInput = {
    id?: number
    settings: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
  }

  export type EmailSettingsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    settings?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    settings?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type BusinessNullableScalarRelationFilter = {
    is?: BusinessWhereInput | null
    isNot?: BusinessWhereInput | null
  }

  export type CourierNullableScalarRelationFilter = {
    is?: CourierWhereInput | null
    isNot?: CourierWhereInput | null
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type NotificationPreferenceListRelationFilter = {
    every?: NotificationPreferenceWhereInput
    some?: NotificationPreferenceWhereInput
    none?: NotificationPreferenceWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type ScheduledReportListRelationFilter = {
    every?: ScheduledReportWhereInput
    some?: ScheduledReportWhereInput
    none?: ScheduledReportWhereInput
  }

  export type UserSettingsNullableScalarRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduledReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SystemActionListRelationFilter = {
    every?: SystemActionWhereInput
    some?: SystemActionWhereInput
    none?: SystemActionWhereInput
  }

  export type AdminDashboardWidgetListRelationFilter = {
    every?: AdminDashboardWidgetWhereInput
    some?: AdminDashboardWidgetWhereInput
    none?: AdminDashboardWidgetWhereInput
  }

  export type AdminRoleMappingListRelationFilter = {
    every?: AdminRoleMappingWhereInput
    some?: AdminRoleMappingWhereInput
    none?: AdminRoleMappingWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SystemActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminDashboardWidgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminRoleMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminOrderByRelevanceInput = {
    fields: AdminOrderByRelevanceFieldEnum | AdminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    level?: SortOrder
    permissions?: SortOrder
    title?: SortOrder
    phone?: SortOrder
    profileImage?: SortOrder
    lastLogin?: SortOrder
    loginAttempts?: SortOrder
    isSuperAdmin?: SortOrder
    ipRestrictions?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    level?: SortOrder
    loginAttempts?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    level?: SortOrder
    title?: SortOrder
    phone?: SortOrder
    profileImage?: SortOrder
    lastLogin?: SortOrder
    loginAttempts?: SortOrder
    isSuperAdmin?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    level?: SortOrder
    title?: SortOrder
    phone?: SortOrder
    profileImage?: SortOrder
    lastLogin?: SortOrder
    loginAttempts?: SortOrder
    isSuperAdmin?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    level?: SortOrder
    loginAttempts?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumCourierAvailabilityStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CourierAvailabilityStatus | EnumCourierAvailabilityStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCourierAvailabilityStatusNullableFilter<$PrismaModel> | $Enums.CourierAvailabilityStatus | null
  }

  export type ZoneNullableScalarRelationFilter = {
    is?: ZoneWhereInput | null
    isNot?: ZoneWhereInput | null
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type DeliveryLogListRelationFilter = {
    every?: DeliveryLogWhereInput
    some?: DeliveryLogWhereInput
    none?: DeliveryLogWhereInput
  }

  export type DeliveryListRelationFilter = {
    every?: DeliveryWhereInput
    some?: DeliveryWhereInput
    none?: DeliveryWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type CourierAvailabilityListRelationFilter = {
    every?: CourierAvailabilityWhereInput
    some?: CourierAvailabilityWhereInput
    none?: CourierAvailabilityWhereInput
  }

  export type DeliveryRouteListRelationFilter = {
    every?: DeliveryRouteWhereInput
    some?: DeliveryRouteWhereInput
    none?: DeliveryRouteWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourierAvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryRouteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourierOrderByRelevanceInput = {
    fields: CourierOrderByRelevanceFieldEnum | CourierOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CourierCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    vehicleType?: SortOrder
    phone?: SortOrder
    zoneId?: SortOrder
    ratings?: SortOrder
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
    lastLocationUpdate?: SortOrder
    availableFrom?: SortOrder
    availableTo?: SortOrder
    documentsVerified?: SortOrder
    backgroundChecked?: SortOrder
    maxDeliveriesPerDay?: SortOrder
    maxDistance?: SortOrder
    averageSpeed?: SortOrder
    courierFee?: SortOrder
    lastSeen?: SortOrder
    availabilityStatus?: SortOrder
  }

  export type CourierAvgOrderByAggregateInput = {
    ratings?: SortOrder
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
    maxDeliveriesPerDay?: SortOrder
    maxDistance?: SortOrder
    averageSpeed?: SortOrder
    courierFee?: SortOrder
  }

  export type CourierMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    vehicleType?: SortOrder
    phone?: SortOrder
    zoneId?: SortOrder
    ratings?: SortOrder
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
    lastLocationUpdate?: SortOrder
    availableFrom?: SortOrder
    availableTo?: SortOrder
    documentsVerified?: SortOrder
    backgroundChecked?: SortOrder
    maxDeliveriesPerDay?: SortOrder
    maxDistance?: SortOrder
    averageSpeed?: SortOrder
    courierFee?: SortOrder
    lastSeen?: SortOrder
    availabilityStatus?: SortOrder
  }

  export type CourierMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    vehicleType?: SortOrder
    phone?: SortOrder
    zoneId?: SortOrder
    ratings?: SortOrder
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
    lastLocationUpdate?: SortOrder
    availableFrom?: SortOrder
    availableTo?: SortOrder
    documentsVerified?: SortOrder
    backgroundChecked?: SortOrder
    maxDeliveriesPerDay?: SortOrder
    maxDistance?: SortOrder
    averageSpeed?: SortOrder
    courierFee?: SortOrder
    lastSeen?: SortOrder
    availabilityStatus?: SortOrder
  }

  export type CourierSumOrderByAggregateInput = {
    ratings?: SortOrder
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
    maxDeliveriesPerDay?: SortOrder
    maxDistance?: SortOrder
    averageSpeed?: SortOrder
    courierFee?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumCourierAvailabilityStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourierAvailabilityStatus | EnumCourierAvailabilityStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCourierAvailabilityStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.CourierAvailabilityStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCourierAvailabilityStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumCourierAvailabilityStatusNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumDeliveryPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryPriority | EnumDeliveryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryPriority[] | ListEnumDeliveryPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryPriority[] | ListEnumDeliveryPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryPriorityFilter<$PrismaModel> | $Enums.DeliveryPriority
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type BusinessScalarRelationFilter = {
    is?: BusinessWhereInput
    isNot?: BusinessWhereInput
  }

  export type DeliveryTimeWindowNullableScalarRelationFilter = {
    is?: DeliveryTimeWindowWhereInput | null
    isNot?: DeliveryTimeWindowWhereInput | null
  }

  export type DeliveryNullableScalarRelationFilter = {
    is?: DeliveryWhereInput | null
    isNot?: DeliveryWhereInput | null
  }

  export type RefundRequestListRelationFilter = {
    every?: RefundRequestWhereInput
    some?: RefundRequestWhereInput
    none?: RefundRequestWhereInput
  }

  export type CancellationRequestListRelationFilter = {
    every?: CancellationRequestWhereInput
    some?: CancellationRequestWhereInput
    none?: CancellationRequestWhereInput
  }

  export type RefundRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CancellationRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelevanceInput = {
    fields: OrderOrderByRelevanceFieldEnum | OrderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    items?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    estimatedDelivery?: SortOrder
    actualDelivery?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    courierId?: SortOrder
    priority?: SortOrder
    timeWindowId?: SortOrder
    estimatedDuration?: SortOrder
    estimatedDistance?: SortOrder
    sequenceNumber?: SortOrder
    refundStatus?: SortOrder
    cancellationStatus?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    estimatedDuration?: SortOrder
    estimatedDistance?: SortOrder
    sequenceNumber?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    estimatedDelivery?: SortOrder
    actualDelivery?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    courierId?: SortOrder
    priority?: SortOrder
    timeWindowId?: SortOrder
    estimatedDuration?: SortOrder
    estimatedDistance?: SortOrder
    sequenceNumber?: SortOrder
    refundStatus?: SortOrder
    cancellationStatus?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    estimatedDelivery?: SortOrder
    actualDelivery?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    courierId?: SortOrder
    priority?: SortOrder
    timeWindowId?: SortOrder
    estimatedDuration?: SortOrder
    estimatedDistance?: SortOrder
    sequenceNumber?: SortOrder
    refundStatus?: SortOrder
    cancellationStatus?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    totalPrice?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    estimatedDuration?: SortOrder
    estimatedDistance?: SortOrder
    sequenceNumber?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumDeliveryPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryPriority | EnumDeliveryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryPriority[] | ListEnumDeliveryPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryPriority[] | ListEnumDeliveryPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryPriorityWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryPriorityFilter<$PrismaModel>
    _max?: NestedEnumDeliveryPriorityFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CustomerAddressListRelationFilter = {
    every?: CustomerAddressWhereInput
    some?: CustomerAddressWhereInput
    none?: CustomerAddressWhereInput
  }

  export type SavedPaymentMethodListRelationFilter = {
    every?: SavedPaymentMethodWhereInput
    some?: SavedPaymentMethodWhereInput
    none?: SavedPaymentMethodWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type CustomerAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedPaymentMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelevanceInput = {
    fields: CustomerOrderByRelevanceFieldEnum | CustomerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type MenuItemListRelationFilter = {
    every?: MenuItemWhereInput
    some?: MenuItemWhereInput
    none?: MenuItemWhereInput
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type RefundPolicyListRelationFilter = {
    every?: RefundPolicyWhereInput
    some?: RefundPolicyWhereInput
    none?: RefundPolicyWhereInput
  }

  export type SubscriptionPlanListRelationFilter = {
    every?: SubscriptionPlanWhereInput
    some?: SubscriptionPlanWhereInput
    none?: SubscriptionPlanWhereInput
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefundPolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessOrderByRelevanceInput = {
    fields: BusinessOrderByRelevanceFieldEnum | BusinessOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BusinessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    email?: SortOrder
    logoUrl?: SortOrder
    coverUrl?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    zoneId?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    tax_id?: SortOrder
    bank_iban?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    deliveryRadius?: SortOrder
    deliveryFee?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    twitter?: SortOrder
    type?: SortOrder
    tags?: SortOrder
    features?: SortOrder
  }

  export type BusinessAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    rating?: SortOrder
    deliveryRadius?: SortOrder
    deliveryFee?: SortOrder
  }

  export type BusinessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    email?: SortOrder
    logoUrl?: SortOrder
    coverUrl?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    zoneId?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    tax_id?: SortOrder
    bank_iban?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    deliveryRadius?: SortOrder
    deliveryFee?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    twitter?: SortOrder
    type?: SortOrder
  }

  export type BusinessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    email?: SortOrder
    logoUrl?: SortOrder
    coverUrl?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    zoneId?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    tax_id?: SortOrder
    bank_iban?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    deliveryRadius?: SortOrder
    deliveryFee?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    twitter?: SortOrder
    type?: SortOrder
  }

  export type BusinessSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    rating?: SortOrder
    deliveryRadius?: SortOrder
    deliveryFee?: SortOrder
  }

  export type BusinessListRelationFilter = {
    every?: BusinessWhereInput
    some?: BusinessWhereInput
    none?: BusinessWhereInput
  }

  export type CourierListRelationFilter = {
    every?: CourierWhereInput
    some?: CourierWhereInput
    none?: CourierWhereInput
  }

  export type BusinessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoneOrderByRelevanceInput = {
    fields: ZoneOrderByRelevanceFieldEnum | ZoneOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ZoneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    coordinates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    averageDeliveryTime?: SortOrder
    orderVolume?: SortOrder
    activeBusinesses?: SortOrder
  }

  export type ZoneAvgOrderByAggregateInput = {
    averageDeliveryTime?: SortOrder
    orderVolume?: SortOrder
    activeBusinesses?: SortOrder
  }

  export type ZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    averageDeliveryTime?: SortOrder
    orderVolume?: SortOrder
    activeBusinesses?: SortOrder
  }

  export type ZoneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    averageDeliveryTime?: SortOrder
    orderVolume?: SortOrder
    activeBusinesses?: SortOrder
  }

  export type ZoneSumOrderByAggregateInput = {
    averageDeliveryTime?: SortOrder
    orderVolume?: SortOrder
    activeBusinesses?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelFilter<$PrismaModel> | $Enums.NotificationChannel
  }

  export type EnumNotificationFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationFrequency | EnumNotificationFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationFrequency[] | ListEnumNotificationFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationFrequency[] | ListEnumNotificationFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationFrequencyFilter<$PrismaModel> | $Enums.NotificationFrequency
  }

  export type NotificationPreferenceOrderByRelevanceInput = {
    fields: NotificationPreferenceOrderByRelevanceFieldEnum | NotificationPreferenceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationPreferenceUserIdTypeChannelCompoundUniqueInput = {
    userId: string
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courierId?: SortOrder
    type?: SortOrder
    channel?: SortOrder
    frequency?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courierId?: SortOrder
    type?: SortOrder
    channel?: SortOrder
    frequency?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courierId?: SortOrder
    type?: SortOrder
    channel?: SortOrder
    frequency?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelFilter<$PrismaModel>
  }

  export type EnumNotificationFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationFrequency | EnumNotificationFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationFrequency[] | ListEnumNotificationFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationFrequency[] | ListEnumNotificationFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.NotificationFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationFrequencyFilter<$PrismaModel>
    _max?: NestedEnumNotificationFrequencyFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type NotificationOrderByRelevanceInput = {
    fields: NotificationOrderByRelevanceFieldEnum | NotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    courierId?: SortOrder
    orderId?: SortOrder
    metadata?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    courierId?: SortOrder
    orderId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    courierId?: SortOrder
    orderId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CourierScalarRelationFilter = {
    is?: CourierWhereInput
    isNot?: CourierWhereInput
  }

  export type ZoneScalarRelationFilter = {
    is?: ZoneWhereInput
    isNot?: ZoneWhereInput
  }

  export type DeliveryRouteNullableScalarRelationFilter = {
    is?: DeliveryRouteWhereInput | null
    isNot?: DeliveryRouteWhereInput | null
  }

  export type DeliveryOrderByRelevanceInput = {
    fields: DeliveryOrderByRelevanceFieldEnum | DeliveryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    courierId?: SortOrder
    customerId?: SortOrder
    zoneId?: SortOrder
    orderId?: SortOrder
    assignedAt?: SortOrder
    pickedUpAt?: SortOrder
    deliveredAt?: SortOrder
    estimatedPickupTime?: SortOrder
    estimatedDeliveryTime?: SortOrder
    duration?: SortOrder
    actualDuration?: SortOrder
    distance?: SortOrder
    actualDistance?: SortOrder
    pickupLatitude?: SortOrder
    pickupLongitude?: SortOrder
    dropoffLatitude?: SortOrder
    dropoffLongitude?: SortOrder
    routeId?: SortOrder
    sequenceNumber?: SortOrder
    priority?: SortOrder
  }

  export type DeliveryAvgOrderByAggregateInput = {
    duration?: SortOrder
    actualDuration?: SortOrder
    distance?: SortOrder
    actualDistance?: SortOrder
    pickupLatitude?: SortOrder
    pickupLongitude?: SortOrder
    dropoffLatitude?: SortOrder
    dropoffLongitude?: SortOrder
    sequenceNumber?: SortOrder
  }

  export type DeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    courierId?: SortOrder
    customerId?: SortOrder
    zoneId?: SortOrder
    orderId?: SortOrder
    assignedAt?: SortOrder
    pickedUpAt?: SortOrder
    deliveredAt?: SortOrder
    estimatedPickupTime?: SortOrder
    estimatedDeliveryTime?: SortOrder
    duration?: SortOrder
    actualDuration?: SortOrder
    distance?: SortOrder
    actualDistance?: SortOrder
    pickupLatitude?: SortOrder
    pickupLongitude?: SortOrder
    dropoffLatitude?: SortOrder
    dropoffLongitude?: SortOrder
    routeId?: SortOrder
    sequenceNumber?: SortOrder
    priority?: SortOrder
  }

  export type DeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    courierId?: SortOrder
    customerId?: SortOrder
    zoneId?: SortOrder
    orderId?: SortOrder
    assignedAt?: SortOrder
    pickedUpAt?: SortOrder
    deliveredAt?: SortOrder
    estimatedPickupTime?: SortOrder
    estimatedDeliveryTime?: SortOrder
    duration?: SortOrder
    actualDuration?: SortOrder
    distance?: SortOrder
    actualDistance?: SortOrder
    pickupLatitude?: SortOrder
    pickupLongitude?: SortOrder
    dropoffLatitude?: SortOrder
    dropoffLongitude?: SortOrder
    routeId?: SortOrder
    sequenceNumber?: SortOrder
    priority?: SortOrder
  }

  export type DeliverySumOrderByAggregateInput = {
    duration?: SortOrder
    actualDuration?: SortOrder
    distance?: SortOrder
    actualDistance?: SortOrder
    pickupLatitude?: SortOrder
    pickupLongitude?: SortOrder
    dropoffLatitude?: SortOrder
    dropoffLongitude?: SortOrder
    sequenceNumber?: SortOrder
  }

  export type ProductCategoryNullableScalarRelationFilter = {
    is?: ProductCategoryWhereInput | null
    isNot?: ProductCategoryWhereInput | null
  }

  export type InventoryOrderByRelevanceInput = {
    fields: InventoryOrderByRelevanceFieldEnum | InventoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type DeliveryLogOrderByRelevanceInput = {
    fields: DeliveryLogOrderByRelevanceFieldEnum | DeliveryLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeliveryLogCountOrderByAggregateInput = {
    id?: SortOrder
    courierId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    note?: SortOrder
    metadata?: SortOrder
  }

  export type DeliveryLogAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type DeliveryLogMaxOrderByAggregateInput = {
    id?: SortOrder
    courierId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    note?: SortOrder
  }

  export type DeliveryLogMinOrderByAggregateInput = {
    id?: SortOrder
    courierId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    note?: SortOrder
  }

  export type DeliveryLogSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type EnumReportFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFormat | EnumReportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFormatFilter<$PrismaModel> | $Enums.ReportFormat
  }

  export type ReportOrderByRelevanceInput = {
    fields: ReportOrderByRelevanceFieldEnum | ReportOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    format?: SortOrder
    parameters?: SortOrder
    createdAt?: SortOrder
    data?: SortOrder
    url?: SortOrder
    expiresAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    expiresAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type EnumReportFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFormat | EnumReportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFormatWithAggregatesFilter<$PrismaModel> | $Enums.ReportFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportFormatFilter<$PrismaModel>
    _max?: NestedEnumReportFormatFilter<$PrismaModel>
  }

  export type ScheduleOrderByRelevanceInput = {
    fields: ScheduleOrderByRelevanceFieldEnum | ScheduleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type ScheduleScalarRelationFilter = {
    is?: ScheduleWhereInput
    isNot?: ScheduleWhereInput
  }

  export type ScheduledReportOrderByRelevanceInput = {
    fields: ScheduledReportOrderByRelevanceFieldEnum | ScheduledReportOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ScheduledReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    reportName?: SortOrder
    type?: SortOrder
    format?: SortOrder
    parameters?: SortOrder
    enabled?: SortOrder
    recipients?: SortOrder
    nextRunAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    reportName?: SortOrder
    type?: SortOrder
    format?: SortOrder
    enabled?: SortOrder
    nextRunAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    reportName?: SortOrder
    type?: SortOrder
    format?: SortOrder
    enabled?: SortOrder
    nextRunAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsOrderByRelevanceInput = {
    fields: UserSettingsOrderByRelevanceFieldEnum | UserSettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    notifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    notifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    notifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemOrderByRelevanceInput = {
    fields: MenuItemOrderByRelevanceFieldEnum | MenuItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MenuItemCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    ingredients?: SortOrder
    calories?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemAvgOrderByAggregateInput = {
    price?: SortOrder
    calories?: SortOrder
  }

  export type MenuItemMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    calories?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    calories?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemSumOrderByAggregateInput = {
    price?: SortOrder
    calories?: SortOrder
  }

  export type EnumCourierAvailabilityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CourierAvailabilityStatus | EnumCourierAvailabilityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourierAvailabilityStatusFilter<$PrismaModel> | $Enums.CourierAvailabilityStatus
  }

  export type CourierAvailabilityOrderByRelevanceInput = {
    fields: CourierAvailabilityOrderByRelevanceFieldEnum | CourierAvailabilityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CourierAvailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    courierId?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type CourierAvailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    courierId?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type CourierAvailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    courierId?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCourierAvailabilityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourierAvailabilityStatus | EnumCourierAvailabilityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourierAvailabilityStatusWithAggregatesFilter<$PrismaModel> | $Enums.CourierAvailabilityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourierAvailabilityStatusFilter<$PrismaModel>
    _max?: NestedEnumCourierAvailabilityStatusFilter<$PrismaModel>
  }

  export type DeliveryTimeWindowOrderByRelevanceInput = {
    fields: DeliveryTimeWindowOrderByRelevanceFieldEnum | DeliveryTimeWindowOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeliveryTimeWindowCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    description?: SortOrder
    priorityFactor?: SortOrder
  }

  export type DeliveryTimeWindowAvgOrderByAggregateInput = {
    priorityFactor?: SortOrder
  }

  export type DeliveryTimeWindowMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    description?: SortOrder
    priorityFactor?: SortOrder
  }

  export type DeliveryTimeWindowMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    description?: SortOrder
    priorityFactor?: SortOrder
  }

  export type DeliveryTimeWindowSumOrderByAggregateInput = {
    priorityFactor?: SortOrder
  }

  export type DeliveryRouteOrderByRelevanceInput = {
    fields: DeliveryRouteOrderByRelevanceFieldEnum | DeliveryRouteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeliveryRouteCountOrderByAggregateInput = {
    id?: SortOrder
    courierId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    totalDistance?: SortOrder
    totalDuration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    routePath?: SortOrder
  }

  export type DeliveryRouteAvgOrderByAggregateInput = {
    totalDistance?: SortOrder
    totalDuration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
  }

  export type DeliveryRouteMaxOrderByAggregateInput = {
    id?: SortOrder
    courierId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    totalDistance?: SortOrder
    totalDuration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
  }

  export type DeliveryRouteMinOrderByAggregateInput = {
    id?: SortOrder
    courierId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    totalDistance?: SortOrder
    totalDuration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
  }

  export type DeliveryRouteSumOrderByAggregateInput = {
    totalDistance?: SortOrder
    totalDuration?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrder
    orderId?: SortOrder
    recipientId?: SortOrder
    businessId?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrder
    orderId?: SortOrder
    recipientId?: SortOrder
    businessId?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrder
    orderId?: SortOrder
    recipientId?: SortOrder
    businessId?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type ProductCategoryOrderByRelevanceInput = {
    fields: ProductCategoryOrderByRelevanceFieldEnum | ProductCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductCategoryBusinessIdSlugCompoundUniqueInput = {
    businessId: string
    slug: string
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ActivityLogOrderByRelevanceInput = {
    fields: ActivityLogOrderByRelevanceFieldEnum | ActivityLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    adminId?: SortOrder
    metadata?: SortOrder
    severity?: SortOrder
    category?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    adminId?: SortOrder
    severity?: SortOrder
    category?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    adminId?: SortOrder
    severity?: SortOrder
    category?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
  }

  export type SystemActionOrderByRelevanceInput = {
    fields: SystemActionOrderByRelevanceFieldEnum | SystemActionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SystemActionCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    status?: SortOrder
    payload?: SortOrder
    result?: SortOrder
    error?: SortOrder
    executionTime?: SortOrder
  }

  export type SystemActionAvgOrderByAggregateInput = {
    executionTime?: SortOrder
  }

  export type SystemActionMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    status?: SortOrder
    error?: SortOrder
    executionTime?: SortOrder
  }

  export type SystemActionMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    status?: SortOrder
    error?: SortOrder
    executionTime?: SortOrder
  }

  export type SystemActionSumOrderByAggregateInput = {
    executionTime?: SortOrder
  }

  export type SystemSettingsOrderByRelevanceInput = {
    fields: SystemSettingsOrderByRelevanceFieldEnum | SystemSettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SystemSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    isEncrypted?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    isEncrypted?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    isEncrypted?: SortOrder
    lastUpdated?: SortOrder
    updatedBy?: SortOrder
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type AdminDashboardWidgetOrderByRelevanceInput = {
    fields: AdminDashboardWidgetOrderByRelevanceFieldEnum | AdminDashboardWidgetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminDashboardWidgetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    position?: SortOrder
    size?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminDashboardWidgetAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type AdminDashboardWidgetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    position?: SortOrder
    size?: SortOrder
    isActive?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminDashboardWidgetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    position?: SortOrder
    size?: SortOrder
    isActive?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminDashboardWidgetSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type AdminRoleListRelationFilter = {
    every?: AdminRoleWhereInput
    some?: AdminRoleWhereInput
    none?: AdminRoleWhereInput
  }

  export type AdminRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminPermissionOrderByRelevanceInput = {
    fields: AdminPermissionOrderByRelevanceFieldEnum | AdminPermissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminPermissionListRelationFilter = {
    every?: AdminPermissionWhereInput
    some?: AdminPermissionWhereInput
    none?: AdminPermissionWhereInput
  }

  export type AdminPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminRoleOrderByRelevanceInput = {
    fields: AdminRoleOrderByRelevanceFieldEnum | AdminRoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminRoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminRoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminRoleScalarRelationFilter = {
    is?: AdminRoleWhereInput
    isNot?: AdminRoleWhereInput
  }

  export type AdminRoleMappingOrderByRelevanceInput = {
    fields: AdminRoleMappingOrderByRelevanceFieldEnum | AdminRoleMappingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminRoleMappingAdminIdRoleIdCompoundUniqueInput = {
    adminId: string
    roleId: string
  }

  export type AdminRoleMappingCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminRoleMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminRoleMappingMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SentEmailListRelationFilter = {
    every?: SentEmailWhereInput
    some?: SentEmailWhereInput
    none?: SentEmailWhereInput
  }

  export type SentEmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailTemplateOrderByRelevanceInput = {
    fields: EmailTemplateOrderByRelevanceFieldEnum | EmailTemplateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    category?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    variables?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    category?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    category?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EmailTemplateScalarRelationFilter = {
    is?: EmailTemplateWhereInput
    isNot?: EmailTemplateWhereInput
  }

  export type SentEmailOrderByRelevanceInput = {
    fields: SentEmailOrderByRelevanceFieldEnum | SentEmailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SentEmailCountOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    variables?: SortOrder
    messageId?: SortOrder
    sentBy?: SortOrder
    sentAt?: SortOrder
    status?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SentEmailMaxOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    variables?: SortOrder
    messageId?: SortOrder
    sentBy?: SortOrder
    sentAt?: SortOrder
    status?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SentEmailMinOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    variables?: SortOrder
    messageId?: SortOrder
    sentBy?: SortOrder
    sentAt?: SortOrder
    status?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAddressOrderByRelevanceInput = {
    fields: CustomerAddressOrderByRelevanceFieldEnum | CustomerAddressOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerAddressCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAddressAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type CustomerAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAddressMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAddressSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumRefundRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundRequestStatus | EnumRefundRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundRequestStatus[] | ListEnumRefundRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundRequestStatus[] | ListEnumRefundRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundRequestStatusFilter<$PrismaModel> | $Enums.RefundRequestStatus
  }

  export type EnumRefundReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundReason | EnumRefundReasonFieldRefInput<$PrismaModel>
    in?: $Enums.RefundReason[] | ListEnumRefundReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundReason[] | ListEnumRefundReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundReasonFilter<$PrismaModel> | $Enums.RefundReason
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type RefundRequestOrderByRelevanceInput = {
    fields: RefundRequestOrderByRelevanceFieldEnum | RefundRequestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RefundRequestCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    otherReason?: SortOrder
    requestedItems?: SortOrder
    refundAmount?: SortOrder
    approvedAmount?: SortOrder
    evidenceUrls?: SortOrder
    adminNotes?: SortOrder
    customerNotes?: SortOrder
    businessNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    refundedAt?: SortOrder
  }

  export type RefundRequestAvgOrderByAggregateInput = {
    refundAmount?: SortOrder
    approvedAmount?: SortOrder
  }

  export type RefundRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    otherReason?: SortOrder
    refundAmount?: SortOrder
    approvedAmount?: SortOrder
    adminNotes?: SortOrder
    customerNotes?: SortOrder
    businessNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    refundedAt?: SortOrder
  }

  export type RefundRequestMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    otherReason?: SortOrder
    refundAmount?: SortOrder
    approvedAmount?: SortOrder
    adminNotes?: SortOrder
    customerNotes?: SortOrder
    businessNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    refundedAt?: SortOrder
  }

  export type RefundRequestSumOrderByAggregateInput = {
    refundAmount?: SortOrder
    approvedAmount?: SortOrder
  }

  export type EnumRefundRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundRequestStatus | EnumRefundRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundRequestStatus[] | ListEnumRefundRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundRequestStatus[] | ListEnumRefundRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRefundRequestStatusFilter<$PrismaModel>
  }

  export type EnumRefundReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundReason | EnumRefundReasonFieldRefInput<$PrismaModel>
    in?: $Enums.RefundReason[] | ListEnumRefundReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundReason[] | ListEnumRefundReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundReasonWithAggregatesFilter<$PrismaModel> | $Enums.RefundReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundReasonFilter<$PrismaModel>
    _max?: NestedEnumRefundReasonFilter<$PrismaModel>
  }

  export type EnumCancellationRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationRequestStatus | EnumCancellationRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationRequestStatus[] | ListEnumCancellationRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CancellationRequestStatus[] | ListEnumCancellationRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCancellationRequestStatusFilter<$PrismaModel> | $Enums.CancellationRequestStatus
  }

  export type EnumCancellationReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationReason | EnumCancellationReasonFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationReason[] | ListEnumCancellationReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.CancellationReason[] | ListEnumCancellationReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumCancellationReasonFilter<$PrismaModel> | $Enums.CancellationReason
  }

  export type CancellationRequestOrderByRelevanceInput = {
    fields: CancellationRequestOrderByRelevanceFieldEnum | CancellationRequestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CancellationRequestCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    otherReason?: SortOrder
    cancellationFee?: SortOrder
    autoProcessed?: SortOrder
    customerNotes?: SortOrder
    businessNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    cancelledAt?: SortOrder
  }

  export type CancellationRequestAvgOrderByAggregateInput = {
    cancellationFee?: SortOrder
  }

  export type CancellationRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    otherReason?: SortOrder
    cancellationFee?: SortOrder
    autoProcessed?: SortOrder
    customerNotes?: SortOrder
    businessNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    cancelledAt?: SortOrder
  }

  export type CancellationRequestMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    businessId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    otherReason?: SortOrder
    cancellationFee?: SortOrder
    autoProcessed?: SortOrder
    customerNotes?: SortOrder
    businessNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    cancelledAt?: SortOrder
  }

  export type CancellationRequestSumOrderByAggregateInput = {
    cancellationFee?: SortOrder
  }

  export type EnumCancellationRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationRequestStatus | EnumCancellationRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationRequestStatus[] | ListEnumCancellationRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CancellationRequestStatus[] | ListEnumCancellationRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCancellationRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.CancellationRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCancellationRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumCancellationRequestStatusFilter<$PrismaModel>
  }

  export type EnumCancellationReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationReason | EnumCancellationReasonFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationReason[] | ListEnumCancellationReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.CancellationReason[] | ListEnumCancellationReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumCancellationReasonWithAggregatesFilter<$PrismaModel> | $Enums.CancellationReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCancellationReasonFilter<$PrismaModel>
    _max?: NestedEnumCancellationReasonFilter<$PrismaModel>
  }

  export type RefundPolicyOrderByRelevanceInput = {
    fields: RefundPolicyOrderByRelevanceFieldEnum | RefundPolicyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RefundPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    autoApproveTimeline?: SortOrder
    timeLimit?: SortOrder
    orderStatusRules?: SortOrder
    productRules?: SortOrder
    cancellationFees?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefundPolicyAvgOrderByAggregateInput = {
    autoApproveTimeline?: SortOrder
    timeLimit?: SortOrder
  }

  export type RefundPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    autoApproveTimeline?: SortOrder
    timeLimit?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefundPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    autoApproveTimeline?: SortOrder
    timeLimit?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefundPolicySumOrderByAggregateInput = {
    autoApproveTimeline?: SortOrder
    timeLimit?: SortOrder
  }

  export type EnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type EnumCardBrandNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CardBrand | EnumCardBrandFieldRefInput<$PrismaModel> | null
    in?: $Enums.CardBrand[] | ListEnumCardBrandFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CardBrand[] | ListEnumCardBrandFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCardBrandNullableFilter<$PrismaModel> | $Enums.CardBrand | null
  }

  export type SavedPaymentMethodOrderByRelevanceInput = {
    fields: SavedPaymentMethodOrderByRelevanceFieldEnum | SavedPaymentMethodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SavedPaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrder
    nickName?: SortOrder
    cardBrand?: SortOrder
    cardLast4?: SortOrder
    cardExpMonth?: SortOrder
    cardExpYear?: SortOrder
    cardHolderName?: SortOrder
    bankName?: SortOrder
    bankAccountLast4?: SortOrder
    externalId?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedPaymentMethodAvgOrderByAggregateInput = {
    cardExpMonth?: SortOrder
    cardExpYear?: SortOrder
  }

  export type SavedPaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrder
    nickName?: SortOrder
    cardBrand?: SortOrder
    cardLast4?: SortOrder
    cardExpMonth?: SortOrder
    cardExpYear?: SortOrder
    cardHolderName?: SortOrder
    bankName?: SortOrder
    bankAccountLast4?: SortOrder
    externalId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedPaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrder
    nickName?: SortOrder
    cardBrand?: SortOrder
    cardLast4?: SortOrder
    cardExpMonth?: SortOrder
    cardExpYear?: SortOrder
    cardHolderName?: SortOrder
    bankName?: SortOrder
    bankAccountLast4?: SortOrder
    externalId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedPaymentMethodSumOrderByAggregateInput = {
    cardExpMonth?: SortOrder
    cardExpYear?: SortOrder
  }

  export type EnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }

  export type EnumCardBrandNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CardBrand | EnumCardBrandFieldRefInput<$PrismaModel> | null
    in?: $Enums.CardBrand[] | ListEnumCardBrandFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CardBrand[] | ListEnumCardBrandFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCardBrandNullableWithAggregatesFilter<$PrismaModel> | $Enums.CardBrand | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCardBrandNullableFilter<$PrismaModel>
    _max?: NestedEnumCardBrandNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionIntervalFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionInterval | EnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionIntervalFilter<$PrismaModel> | $Enums.SubscriptionInterval
  }

  export type SubscriptionPlanOrderByRelevanceInput = {
    fields: SubscriptionPlanOrderByRelevanceFieldEnum | SubscriptionPlanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubscriptionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessId?: SortOrder
  }

  export type SubscriptionPlanAvgOrderByAggregateInput = {
    price?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
  }

  export type SubscriptionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessId?: SortOrder
  }

  export type SubscriptionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessId?: SortOrder
  }

  export type SubscriptionPlanSumOrderByAggregateInput = {
    price?: SortOrder
    intervalCount?: SortOrder
    trialPeriodDays?: SortOrder
  }

  export type EnumSubscriptionIntervalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionInterval | EnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionIntervalWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionInterval
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionIntervalFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionIntervalFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type SubscriptionPlanScalarRelationFilter = {
    is?: SubscriptionPlanWhereInput
    isNot?: SubscriptionPlanWhereInput
  }

  export type SavedPaymentMethodNullableScalarRelationFilter = {
    is?: SavedPaymentMethodWhereInput | null
    isNot?: SavedPaymentMethodWhereInput | null
  }

  export type RecurringPaymentListRelationFilter = {
    every?: RecurringPaymentWhereInput
    some?: RecurringPaymentWhereInput
    none?: RecurringPaymentWhereInput
  }

  export type RecurringPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelevanceInput = {
    fields: SubscriptionOrderByRelevanceFieldEnum | SubscriptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trialEndDate?: SortOrder
    canceledAt?: SortOrder
    pausedAt?: SortOrder
    resumeAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrder
    savedPaymentMethodId?: SortOrder
    quantity?: SortOrder
    autoRenew?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    metadata?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessId?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trialEndDate?: SortOrder
    canceledAt?: SortOrder
    pausedAt?: SortOrder
    resumeAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrder
    savedPaymentMethodId?: SortOrder
    quantity?: SortOrder
    autoRenew?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessId?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trialEndDate?: SortOrder
    canceledAt?: SortOrder
    pausedAt?: SortOrder
    resumeAt?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrder
    savedPaymentMethodId?: SortOrder
    quantity?: SortOrder
    autoRenew?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessId?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type RecurringPaymentOrderByRelevanceInput = {
    fields: RecurringPaymentOrderByRelevanceFieldEnum | RecurringPaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RecurringPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RecurringPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DashboardMetricCountOrderByAggregateInput = {
    id?: SortOrder
    metrics?: SortOrder
    lastUpdated?: SortOrder
  }

  export type DashboardMetricAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DashboardMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    lastUpdated?: SortOrder
  }

  export type DashboardMetricMinOrderByAggregateInput = {
    id?: SortOrder
    lastUpdated?: SortOrder
  }

  export type DashboardMetricSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmailSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    settings?: SortOrder
    lastUpdated?: SortOrder
  }

  export type EmailSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmailSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    lastUpdated?: SortOrder
  }

  export type EmailSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    lastUpdated?: SortOrder
  }

  export type EmailSettingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type BusinessCreateNestedOneWithoutUserInput = {
    create?: XOR<BusinessCreateWithoutUserInput, BusinessUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutUserInput
    connect?: BusinessWhereUniqueInput
  }

  export type CourierCreateNestedOneWithoutUserInput = {
    create?: XOR<CourierCreateWithoutUserInput, CourierUncheckedCreateWithoutUserInput>
    connectOrCreate?: CourierCreateOrConnectWithoutUserInput
    connect?: CourierWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutUserInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    connect?: CustomerWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ScheduledReportCreateNestedManyWithoutUserInput = {
    create?: XOR<ScheduledReportCreateWithoutUserInput, ScheduledReportUncheckedCreateWithoutUserInput> | ScheduledReportCreateWithoutUserInput[] | ScheduledReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutUserInput | ScheduledReportCreateOrConnectWithoutUserInput[]
    createMany?: ScheduledReportCreateManyUserInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type BusinessUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<BusinessCreateWithoutUserInput, BusinessUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutUserInput
    connect?: BusinessWhereUniqueInput
  }

  export type CourierUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CourierCreateWithoutUserInput, CourierUncheckedCreateWithoutUserInput>
    connectOrCreate?: CourierCreateOrConnectWithoutUserInput
    connect?: CourierWhereUniqueInput
  }

  export type CustomerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    connect?: CustomerWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ScheduledReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ScheduledReportCreateWithoutUserInput, ScheduledReportUncheckedCreateWithoutUserInput> | ScheduledReportCreateWithoutUserInput[] | ScheduledReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutUserInput | ScheduledReportCreateOrConnectWithoutUserInput[]
    createMany?: ScheduledReportCreateManyUserInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type BusinessUpdateOneWithoutUserNestedInput = {
    create?: XOR<BusinessCreateWithoutUserInput, BusinessUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutUserInput
    upsert?: BusinessUpsertWithoutUserInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutUserInput, BusinessUpdateWithoutUserInput>, BusinessUncheckedUpdateWithoutUserInput>
  }

  export type CourierUpdateOneWithoutUserNestedInput = {
    create?: XOR<CourierCreateWithoutUserInput, CourierUncheckedCreateWithoutUserInput>
    connectOrCreate?: CourierCreateOrConnectWithoutUserInput
    upsert?: CourierUpsertWithoutUserInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutUserInput, CourierUpdateWithoutUserInput>, CourierUncheckedUpdateWithoutUserInput>
  }

  export type CustomerUpdateOneWithoutUserNestedInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    upsert?: CustomerUpsertWithoutUserInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutUserInput, CustomerUpdateWithoutUserInput>, CustomerUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput | NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    set?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    disconnect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    delete?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    update?: NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput | NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationPreferenceUpdateManyWithWhereWithoutUserInput | NotificationPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutUserInput | ReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutUserInput | ReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutUserInput | ReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ScheduledReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutUserInput, ScheduledReportUncheckedCreateWithoutUserInput> | ScheduledReportCreateWithoutUserInput[] | ScheduledReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutUserInput | ScheduledReportCreateOrConnectWithoutUserInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutUserInput | ScheduledReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScheduledReportCreateManyUserInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutUserInput | ScheduledReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutUserInput | ScheduledReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type BusinessUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<BusinessCreateWithoutUserInput, BusinessUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutUserInput
    upsert?: BusinessUpsertWithoutUserInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutUserInput, BusinessUpdateWithoutUserInput>, BusinessUncheckedUpdateWithoutUserInput>
  }

  export type CourierUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CourierCreateWithoutUserInput, CourierUncheckedCreateWithoutUserInput>
    connectOrCreate?: CourierCreateOrConnectWithoutUserInput
    upsert?: CourierUpsertWithoutUserInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutUserInput, CourierUpdateWithoutUserInput>, CourierUncheckedUpdateWithoutUserInput>
  }

  export type CustomerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    upsert?: CustomerUpsertWithoutUserInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutUserInput, CustomerUpdateWithoutUserInput>, CustomerUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput | NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    set?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    disconnect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    delete?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    update?: NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput | NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationPreferenceUpdateManyWithWhereWithoutUserInput | NotificationPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutUserInput | ReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutUserInput | ReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutUserInput | ReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ScheduledReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutUserInput, ScheduledReportUncheckedCreateWithoutUserInput> | ScheduledReportCreateWithoutUserInput[] | ScheduledReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutUserInput | ScheduledReportCreateOrConnectWithoutUserInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutUserInput | ScheduledReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScheduledReportCreateManyUserInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutUserInput | ScheduledReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutUserInput | ScheduledReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type AdminCreatepermissionsInput = {
    set: string[]
  }

  export type AdminCreateipRestrictionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput> | ActivityLogCreateWithoutAdminInput[] | ActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAdminInput | ActivityLogCreateOrConnectWithoutAdminInput[]
    createMany?: ActivityLogCreateManyAdminInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type SystemActionCreateNestedManyWithoutAdminInput = {
    create?: XOR<SystemActionCreateWithoutAdminInput, SystemActionUncheckedCreateWithoutAdminInput> | SystemActionCreateWithoutAdminInput[] | SystemActionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SystemActionCreateOrConnectWithoutAdminInput | SystemActionCreateOrConnectWithoutAdminInput[]
    createMany?: SystemActionCreateManyAdminInputEnvelope
    connect?: SystemActionWhereUniqueInput | SystemActionWhereUniqueInput[]
  }

  export type AdminDashboardWidgetCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminDashboardWidgetCreateWithoutAdminInput, AdminDashboardWidgetUncheckedCreateWithoutAdminInput> | AdminDashboardWidgetCreateWithoutAdminInput[] | AdminDashboardWidgetUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminDashboardWidgetCreateOrConnectWithoutAdminInput | AdminDashboardWidgetCreateOrConnectWithoutAdminInput[]
    createMany?: AdminDashboardWidgetCreateManyAdminInputEnvelope
    connect?: AdminDashboardWidgetWhereUniqueInput | AdminDashboardWidgetWhereUniqueInput[]
  }

  export type AdminRoleMappingCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminRoleMappingCreateWithoutAdminInput, AdminRoleMappingUncheckedCreateWithoutAdminInput> | AdminRoleMappingCreateWithoutAdminInput[] | AdminRoleMappingUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminRoleMappingCreateOrConnectWithoutAdminInput | AdminRoleMappingCreateOrConnectWithoutAdminInput[]
    createMany?: AdminRoleMappingCreateManyAdminInputEnvelope
    connect?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput> | ActivityLogCreateWithoutAdminInput[] | ActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAdminInput | ActivityLogCreateOrConnectWithoutAdminInput[]
    createMany?: ActivityLogCreateManyAdminInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type SystemActionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<SystemActionCreateWithoutAdminInput, SystemActionUncheckedCreateWithoutAdminInput> | SystemActionCreateWithoutAdminInput[] | SystemActionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SystemActionCreateOrConnectWithoutAdminInput | SystemActionCreateOrConnectWithoutAdminInput[]
    createMany?: SystemActionCreateManyAdminInputEnvelope
    connect?: SystemActionWhereUniqueInput | SystemActionWhereUniqueInput[]
  }

  export type AdminDashboardWidgetUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminDashboardWidgetCreateWithoutAdminInput, AdminDashboardWidgetUncheckedCreateWithoutAdminInput> | AdminDashboardWidgetCreateWithoutAdminInput[] | AdminDashboardWidgetUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminDashboardWidgetCreateOrConnectWithoutAdminInput | AdminDashboardWidgetCreateOrConnectWithoutAdminInput[]
    createMany?: AdminDashboardWidgetCreateManyAdminInputEnvelope
    connect?: AdminDashboardWidgetWhereUniqueInput | AdminDashboardWidgetWhereUniqueInput[]
  }

  export type AdminRoleMappingUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminRoleMappingCreateWithoutAdminInput, AdminRoleMappingUncheckedCreateWithoutAdminInput> | AdminRoleMappingCreateWithoutAdminInput[] | AdminRoleMappingUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminRoleMappingCreateOrConnectWithoutAdminInput | AdminRoleMappingCreateOrConnectWithoutAdminInput[]
    createMany?: AdminRoleMappingCreateManyAdminInputEnvelope
    connect?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdminUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AdminUpdateipRestrictionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type ActivityLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput> | ActivityLogCreateWithoutAdminInput[] | ActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAdminInput | ActivityLogCreateOrConnectWithoutAdminInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutAdminInput | ActivityLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: ActivityLogCreateManyAdminInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutAdminInput | ActivityLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutAdminInput | ActivityLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type SystemActionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<SystemActionCreateWithoutAdminInput, SystemActionUncheckedCreateWithoutAdminInput> | SystemActionCreateWithoutAdminInput[] | SystemActionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SystemActionCreateOrConnectWithoutAdminInput | SystemActionCreateOrConnectWithoutAdminInput[]
    upsert?: SystemActionUpsertWithWhereUniqueWithoutAdminInput | SystemActionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: SystemActionCreateManyAdminInputEnvelope
    set?: SystemActionWhereUniqueInput | SystemActionWhereUniqueInput[]
    disconnect?: SystemActionWhereUniqueInput | SystemActionWhereUniqueInput[]
    delete?: SystemActionWhereUniqueInput | SystemActionWhereUniqueInput[]
    connect?: SystemActionWhereUniqueInput | SystemActionWhereUniqueInput[]
    update?: SystemActionUpdateWithWhereUniqueWithoutAdminInput | SystemActionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: SystemActionUpdateManyWithWhereWithoutAdminInput | SystemActionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: SystemActionScalarWhereInput | SystemActionScalarWhereInput[]
  }

  export type AdminDashboardWidgetUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminDashboardWidgetCreateWithoutAdminInput, AdminDashboardWidgetUncheckedCreateWithoutAdminInput> | AdminDashboardWidgetCreateWithoutAdminInput[] | AdminDashboardWidgetUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminDashboardWidgetCreateOrConnectWithoutAdminInput | AdminDashboardWidgetCreateOrConnectWithoutAdminInput[]
    upsert?: AdminDashboardWidgetUpsertWithWhereUniqueWithoutAdminInput | AdminDashboardWidgetUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminDashboardWidgetCreateManyAdminInputEnvelope
    set?: AdminDashboardWidgetWhereUniqueInput | AdminDashboardWidgetWhereUniqueInput[]
    disconnect?: AdminDashboardWidgetWhereUniqueInput | AdminDashboardWidgetWhereUniqueInput[]
    delete?: AdminDashboardWidgetWhereUniqueInput | AdminDashboardWidgetWhereUniqueInput[]
    connect?: AdminDashboardWidgetWhereUniqueInput | AdminDashboardWidgetWhereUniqueInput[]
    update?: AdminDashboardWidgetUpdateWithWhereUniqueWithoutAdminInput | AdminDashboardWidgetUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminDashboardWidgetUpdateManyWithWhereWithoutAdminInput | AdminDashboardWidgetUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminDashboardWidgetScalarWhereInput | AdminDashboardWidgetScalarWhereInput[]
  }

  export type AdminRoleMappingUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminRoleMappingCreateWithoutAdminInput, AdminRoleMappingUncheckedCreateWithoutAdminInput> | AdminRoleMappingCreateWithoutAdminInput[] | AdminRoleMappingUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminRoleMappingCreateOrConnectWithoutAdminInput | AdminRoleMappingCreateOrConnectWithoutAdminInput[]
    upsert?: AdminRoleMappingUpsertWithWhereUniqueWithoutAdminInput | AdminRoleMappingUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminRoleMappingCreateManyAdminInputEnvelope
    set?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    disconnect?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    delete?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    connect?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    update?: AdminRoleMappingUpdateWithWhereUniqueWithoutAdminInput | AdminRoleMappingUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminRoleMappingUpdateManyWithWhereWithoutAdminInput | AdminRoleMappingUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminRoleMappingScalarWhereInput | AdminRoleMappingScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput> | ActivityLogCreateWithoutAdminInput[] | ActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAdminInput | ActivityLogCreateOrConnectWithoutAdminInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutAdminInput | ActivityLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: ActivityLogCreateManyAdminInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutAdminInput | ActivityLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutAdminInput | ActivityLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type SystemActionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<SystemActionCreateWithoutAdminInput, SystemActionUncheckedCreateWithoutAdminInput> | SystemActionCreateWithoutAdminInput[] | SystemActionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SystemActionCreateOrConnectWithoutAdminInput | SystemActionCreateOrConnectWithoutAdminInput[]
    upsert?: SystemActionUpsertWithWhereUniqueWithoutAdminInput | SystemActionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: SystemActionCreateManyAdminInputEnvelope
    set?: SystemActionWhereUniqueInput | SystemActionWhereUniqueInput[]
    disconnect?: SystemActionWhereUniqueInput | SystemActionWhereUniqueInput[]
    delete?: SystemActionWhereUniqueInput | SystemActionWhereUniqueInput[]
    connect?: SystemActionWhereUniqueInput | SystemActionWhereUniqueInput[]
    update?: SystemActionUpdateWithWhereUniqueWithoutAdminInput | SystemActionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: SystemActionUpdateManyWithWhereWithoutAdminInput | SystemActionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: SystemActionScalarWhereInput | SystemActionScalarWhereInput[]
  }

  export type AdminDashboardWidgetUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminDashboardWidgetCreateWithoutAdminInput, AdminDashboardWidgetUncheckedCreateWithoutAdminInput> | AdminDashboardWidgetCreateWithoutAdminInput[] | AdminDashboardWidgetUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminDashboardWidgetCreateOrConnectWithoutAdminInput | AdminDashboardWidgetCreateOrConnectWithoutAdminInput[]
    upsert?: AdminDashboardWidgetUpsertWithWhereUniqueWithoutAdminInput | AdminDashboardWidgetUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminDashboardWidgetCreateManyAdminInputEnvelope
    set?: AdminDashboardWidgetWhereUniqueInput | AdminDashboardWidgetWhereUniqueInput[]
    disconnect?: AdminDashboardWidgetWhereUniqueInput | AdminDashboardWidgetWhereUniqueInput[]
    delete?: AdminDashboardWidgetWhereUniqueInput | AdminDashboardWidgetWhereUniqueInput[]
    connect?: AdminDashboardWidgetWhereUniqueInput | AdminDashboardWidgetWhereUniqueInput[]
    update?: AdminDashboardWidgetUpdateWithWhereUniqueWithoutAdminInput | AdminDashboardWidgetUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminDashboardWidgetUpdateManyWithWhereWithoutAdminInput | AdminDashboardWidgetUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminDashboardWidgetScalarWhereInput | AdminDashboardWidgetScalarWhereInput[]
  }

  export type AdminRoleMappingUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminRoleMappingCreateWithoutAdminInput, AdminRoleMappingUncheckedCreateWithoutAdminInput> | AdminRoleMappingCreateWithoutAdminInput[] | AdminRoleMappingUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminRoleMappingCreateOrConnectWithoutAdminInput | AdminRoleMappingCreateOrConnectWithoutAdminInput[]
    upsert?: AdminRoleMappingUpsertWithWhereUniqueWithoutAdminInput | AdminRoleMappingUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminRoleMappingCreateManyAdminInputEnvelope
    set?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    disconnect?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    delete?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    connect?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    update?: AdminRoleMappingUpdateWithWhereUniqueWithoutAdminInput | AdminRoleMappingUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminRoleMappingUpdateManyWithWhereWithoutAdminInput | AdminRoleMappingUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminRoleMappingScalarWhereInput | AdminRoleMappingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCourierInput = {
    create?: XOR<UserCreateWithoutCourierInput, UserUncheckedCreateWithoutCourierInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourierInput
    connect?: UserWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutCouriersInput = {
    create?: XOR<ZoneCreateWithoutCouriersInput, ZoneUncheckedCreateWithoutCouriersInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutCouriersInput
    connect?: ZoneWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutCourierInput = {
    create?: XOR<OrderCreateWithoutCourierInput, OrderUncheckedCreateWithoutCourierInput> | OrderCreateWithoutCourierInput[] | OrderUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCourierInput | OrderCreateOrConnectWithoutCourierInput[]
    createMany?: OrderCreateManyCourierInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutCourierInput = {
    create?: XOR<NotificationCreateWithoutCourierInput, NotificationUncheckedCreateWithoutCourierInput> | NotificationCreateWithoutCourierInput[] | NotificationUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCourierInput | NotificationCreateOrConnectWithoutCourierInput[]
    createMany?: NotificationCreateManyCourierInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedManyWithoutCourierInput = {
    create?: XOR<NotificationPreferenceCreateWithoutCourierInput, NotificationPreferenceUncheckedCreateWithoutCourierInput> | NotificationPreferenceCreateWithoutCourierInput[] | NotificationPreferenceUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutCourierInput | NotificationPreferenceCreateOrConnectWithoutCourierInput[]
    createMany?: NotificationPreferenceCreateManyCourierInputEnvelope
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
  }

  export type DeliveryLogCreateNestedManyWithoutCourierInput = {
    create?: XOR<DeliveryLogCreateWithoutCourierInput, DeliveryLogUncheckedCreateWithoutCourierInput> | DeliveryLogCreateWithoutCourierInput[] | DeliveryLogUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryLogCreateOrConnectWithoutCourierInput | DeliveryLogCreateOrConnectWithoutCourierInput[]
    createMany?: DeliveryLogCreateManyCourierInputEnvelope
    connect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
  }

  export type DeliveryCreateNestedManyWithoutCourierInput = {
    create?: XOR<DeliveryCreateWithoutCourierInput, DeliveryUncheckedCreateWithoutCourierInput> | DeliveryCreateWithoutCourierInput[] | DeliveryUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCourierInput | DeliveryCreateOrConnectWithoutCourierInput[]
    createMany?: DeliveryCreateManyCourierInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutRecipientInput = {
    create?: XOR<PaymentCreateWithoutRecipientInput, PaymentUncheckedCreateWithoutRecipientInput> | PaymentCreateWithoutRecipientInput[] | PaymentUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutRecipientInput | PaymentCreateOrConnectWithoutRecipientInput[]
    createMany?: PaymentCreateManyRecipientInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CourierAvailabilityCreateNestedManyWithoutCourierInput = {
    create?: XOR<CourierAvailabilityCreateWithoutCourierInput, CourierAvailabilityUncheckedCreateWithoutCourierInput> | CourierAvailabilityCreateWithoutCourierInput[] | CourierAvailabilityUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: CourierAvailabilityCreateOrConnectWithoutCourierInput | CourierAvailabilityCreateOrConnectWithoutCourierInput[]
    createMany?: CourierAvailabilityCreateManyCourierInputEnvelope
    connect?: CourierAvailabilityWhereUniqueInput | CourierAvailabilityWhereUniqueInput[]
  }

  export type DeliveryRouteCreateNestedManyWithoutCourierInput = {
    create?: XOR<DeliveryRouteCreateWithoutCourierInput, DeliveryRouteUncheckedCreateWithoutCourierInput> | DeliveryRouteCreateWithoutCourierInput[] | DeliveryRouteUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryRouteCreateOrConnectWithoutCourierInput | DeliveryRouteCreateOrConnectWithoutCourierInput[]
    createMany?: DeliveryRouteCreateManyCourierInputEnvelope
    connect?: DeliveryRouteWhereUniqueInput | DeliveryRouteWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCourierInput = {
    create?: XOR<OrderCreateWithoutCourierInput, OrderUncheckedCreateWithoutCourierInput> | OrderCreateWithoutCourierInput[] | OrderUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCourierInput | OrderCreateOrConnectWithoutCourierInput[]
    createMany?: OrderCreateManyCourierInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutCourierInput = {
    create?: XOR<NotificationCreateWithoutCourierInput, NotificationUncheckedCreateWithoutCourierInput> | NotificationCreateWithoutCourierInput[] | NotificationUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCourierInput | NotificationCreateOrConnectWithoutCourierInput[]
    createMany?: NotificationCreateManyCourierInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedManyWithoutCourierInput = {
    create?: XOR<NotificationPreferenceCreateWithoutCourierInput, NotificationPreferenceUncheckedCreateWithoutCourierInput> | NotificationPreferenceCreateWithoutCourierInput[] | NotificationPreferenceUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutCourierInput | NotificationPreferenceCreateOrConnectWithoutCourierInput[]
    createMany?: NotificationPreferenceCreateManyCourierInputEnvelope
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
  }

  export type DeliveryLogUncheckedCreateNestedManyWithoutCourierInput = {
    create?: XOR<DeliveryLogCreateWithoutCourierInput, DeliveryLogUncheckedCreateWithoutCourierInput> | DeliveryLogCreateWithoutCourierInput[] | DeliveryLogUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryLogCreateOrConnectWithoutCourierInput | DeliveryLogCreateOrConnectWithoutCourierInput[]
    createMany?: DeliveryLogCreateManyCourierInputEnvelope
    connect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedManyWithoutCourierInput = {
    create?: XOR<DeliveryCreateWithoutCourierInput, DeliveryUncheckedCreateWithoutCourierInput> | DeliveryCreateWithoutCourierInput[] | DeliveryUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCourierInput | DeliveryCreateOrConnectWithoutCourierInput[]
    createMany?: DeliveryCreateManyCourierInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<PaymentCreateWithoutRecipientInput, PaymentUncheckedCreateWithoutRecipientInput> | PaymentCreateWithoutRecipientInput[] | PaymentUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutRecipientInput | PaymentCreateOrConnectWithoutRecipientInput[]
    createMany?: PaymentCreateManyRecipientInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CourierAvailabilityUncheckedCreateNestedManyWithoutCourierInput = {
    create?: XOR<CourierAvailabilityCreateWithoutCourierInput, CourierAvailabilityUncheckedCreateWithoutCourierInput> | CourierAvailabilityCreateWithoutCourierInput[] | CourierAvailabilityUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: CourierAvailabilityCreateOrConnectWithoutCourierInput | CourierAvailabilityCreateOrConnectWithoutCourierInput[]
    createMany?: CourierAvailabilityCreateManyCourierInputEnvelope
    connect?: CourierAvailabilityWhereUniqueInput | CourierAvailabilityWhereUniqueInput[]
  }

  export type DeliveryRouteUncheckedCreateNestedManyWithoutCourierInput = {
    create?: XOR<DeliveryRouteCreateWithoutCourierInput, DeliveryRouteUncheckedCreateWithoutCourierInput> | DeliveryRouteCreateWithoutCourierInput[] | DeliveryRouteUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryRouteCreateOrConnectWithoutCourierInput | DeliveryRouteCreateOrConnectWithoutCourierInput[]
    createMany?: DeliveryRouteCreateManyCourierInputEnvelope
    connect?: DeliveryRouteWhereUniqueInput | DeliveryRouteWhereUniqueInput[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput = {
    set?: $Enums.CourierAvailabilityStatus | null
  }

  export type UserUpdateOneRequiredWithoutCourierNestedInput = {
    create?: XOR<UserCreateWithoutCourierInput, UserUncheckedCreateWithoutCourierInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourierInput
    upsert?: UserUpsertWithoutCourierInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCourierInput, UserUpdateWithoutCourierInput>, UserUncheckedUpdateWithoutCourierInput>
  }

  export type ZoneUpdateOneWithoutCouriersNestedInput = {
    create?: XOR<ZoneCreateWithoutCouriersInput, ZoneUncheckedCreateWithoutCouriersInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutCouriersInput
    upsert?: ZoneUpsertWithoutCouriersInput
    disconnect?: ZoneWhereInput | boolean
    delete?: ZoneWhereInput | boolean
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutCouriersInput, ZoneUpdateWithoutCouriersInput>, ZoneUncheckedUpdateWithoutCouriersInput>
  }

  export type OrderUpdateManyWithoutCourierNestedInput = {
    create?: XOR<OrderCreateWithoutCourierInput, OrderUncheckedCreateWithoutCourierInput> | OrderCreateWithoutCourierInput[] | OrderUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCourierInput | OrderCreateOrConnectWithoutCourierInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCourierInput | OrderUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: OrderCreateManyCourierInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCourierInput | OrderUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCourierInput | OrderUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutCourierNestedInput = {
    create?: XOR<NotificationCreateWithoutCourierInput, NotificationUncheckedCreateWithoutCourierInput> | NotificationCreateWithoutCourierInput[] | NotificationUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCourierInput | NotificationCreateOrConnectWithoutCourierInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCourierInput | NotificationUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: NotificationCreateManyCourierInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCourierInput | NotificationUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCourierInput | NotificationUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateManyWithoutCourierNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutCourierInput, NotificationPreferenceUncheckedCreateWithoutCourierInput> | NotificationPreferenceCreateWithoutCourierInput[] | NotificationPreferenceUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutCourierInput | NotificationPreferenceCreateOrConnectWithoutCourierInput[]
    upsert?: NotificationPreferenceUpsertWithWhereUniqueWithoutCourierInput | NotificationPreferenceUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: NotificationPreferenceCreateManyCourierInputEnvelope
    set?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    disconnect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    delete?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    update?: NotificationPreferenceUpdateWithWhereUniqueWithoutCourierInput | NotificationPreferenceUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: NotificationPreferenceUpdateManyWithWhereWithoutCourierInput | NotificationPreferenceUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
  }

  export type DeliveryLogUpdateManyWithoutCourierNestedInput = {
    create?: XOR<DeliveryLogCreateWithoutCourierInput, DeliveryLogUncheckedCreateWithoutCourierInput> | DeliveryLogCreateWithoutCourierInput[] | DeliveryLogUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryLogCreateOrConnectWithoutCourierInput | DeliveryLogCreateOrConnectWithoutCourierInput[]
    upsert?: DeliveryLogUpsertWithWhereUniqueWithoutCourierInput | DeliveryLogUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: DeliveryLogCreateManyCourierInputEnvelope
    set?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    disconnect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    delete?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    connect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    update?: DeliveryLogUpdateWithWhereUniqueWithoutCourierInput | DeliveryLogUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: DeliveryLogUpdateManyWithWhereWithoutCourierInput | DeliveryLogUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: DeliveryLogScalarWhereInput | DeliveryLogScalarWhereInput[]
  }

  export type DeliveryUpdateManyWithoutCourierNestedInput = {
    create?: XOR<DeliveryCreateWithoutCourierInput, DeliveryUncheckedCreateWithoutCourierInput> | DeliveryCreateWithoutCourierInput[] | DeliveryUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCourierInput | DeliveryCreateOrConnectWithoutCourierInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutCourierInput | DeliveryUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: DeliveryCreateManyCourierInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutCourierInput | DeliveryUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutCourierInput | DeliveryUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<PaymentCreateWithoutRecipientInput, PaymentUncheckedCreateWithoutRecipientInput> | PaymentCreateWithoutRecipientInput[] | PaymentUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutRecipientInput | PaymentCreateOrConnectWithoutRecipientInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutRecipientInput | PaymentUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: PaymentCreateManyRecipientInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutRecipientInput | PaymentUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutRecipientInput | PaymentUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CourierAvailabilityUpdateManyWithoutCourierNestedInput = {
    create?: XOR<CourierAvailabilityCreateWithoutCourierInput, CourierAvailabilityUncheckedCreateWithoutCourierInput> | CourierAvailabilityCreateWithoutCourierInput[] | CourierAvailabilityUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: CourierAvailabilityCreateOrConnectWithoutCourierInput | CourierAvailabilityCreateOrConnectWithoutCourierInput[]
    upsert?: CourierAvailabilityUpsertWithWhereUniqueWithoutCourierInput | CourierAvailabilityUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: CourierAvailabilityCreateManyCourierInputEnvelope
    set?: CourierAvailabilityWhereUniqueInput | CourierAvailabilityWhereUniqueInput[]
    disconnect?: CourierAvailabilityWhereUniqueInput | CourierAvailabilityWhereUniqueInput[]
    delete?: CourierAvailabilityWhereUniqueInput | CourierAvailabilityWhereUniqueInput[]
    connect?: CourierAvailabilityWhereUniqueInput | CourierAvailabilityWhereUniqueInput[]
    update?: CourierAvailabilityUpdateWithWhereUniqueWithoutCourierInput | CourierAvailabilityUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: CourierAvailabilityUpdateManyWithWhereWithoutCourierInput | CourierAvailabilityUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: CourierAvailabilityScalarWhereInput | CourierAvailabilityScalarWhereInput[]
  }

  export type DeliveryRouteUpdateManyWithoutCourierNestedInput = {
    create?: XOR<DeliveryRouteCreateWithoutCourierInput, DeliveryRouteUncheckedCreateWithoutCourierInput> | DeliveryRouteCreateWithoutCourierInput[] | DeliveryRouteUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryRouteCreateOrConnectWithoutCourierInput | DeliveryRouteCreateOrConnectWithoutCourierInput[]
    upsert?: DeliveryRouteUpsertWithWhereUniqueWithoutCourierInput | DeliveryRouteUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: DeliveryRouteCreateManyCourierInputEnvelope
    set?: DeliveryRouteWhereUniqueInput | DeliveryRouteWhereUniqueInput[]
    disconnect?: DeliveryRouteWhereUniqueInput | DeliveryRouteWhereUniqueInput[]
    delete?: DeliveryRouteWhereUniqueInput | DeliveryRouteWhereUniqueInput[]
    connect?: DeliveryRouteWhereUniqueInput | DeliveryRouteWhereUniqueInput[]
    update?: DeliveryRouteUpdateWithWhereUniqueWithoutCourierInput | DeliveryRouteUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: DeliveryRouteUpdateManyWithWhereWithoutCourierInput | DeliveryRouteUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: DeliveryRouteScalarWhereInput | DeliveryRouteScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCourierNestedInput = {
    create?: XOR<OrderCreateWithoutCourierInput, OrderUncheckedCreateWithoutCourierInput> | OrderCreateWithoutCourierInput[] | OrderUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCourierInput | OrderCreateOrConnectWithoutCourierInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCourierInput | OrderUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: OrderCreateManyCourierInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCourierInput | OrderUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCourierInput | OrderUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutCourierNestedInput = {
    create?: XOR<NotificationCreateWithoutCourierInput, NotificationUncheckedCreateWithoutCourierInput> | NotificationCreateWithoutCourierInput[] | NotificationUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCourierInput | NotificationCreateOrConnectWithoutCourierInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCourierInput | NotificationUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: NotificationCreateManyCourierInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCourierInput | NotificationUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCourierInput | NotificationUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateManyWithoutCourierNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutCourierInput, NotificationPreferenceUncheckedCreateWithoutCourierInput> | NotificationPreferenceCreateWithoutCourierInput[] | NotificationPreferenceUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutCourierInput | NotificationPreferenceCreateOrConnectWithoutCourierInput[]
    upsert?: NotificationPreferenceUpsertWithWhereUniqueWithoutCourierInput | NotificationPreferenceUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: NotificationPreferenceCreateManyCourierInputEnvelope
    set?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    disconnect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    delete?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    update?: NotificationPreferenceUpdateWithWhereUniqueWithoutCourierInput | NotificationPreferenceUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: NotificationPreferenceUpdateManyWithWhereWithoutCourierInput | NotificationPreferenceUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
  }

  export type DeliveryLogUncheckedUpdateManyWithoutCourierNestedInput = {
    create?: XOR<DeliveryLogCreateWithoutCourierInput, DeliveryLogUncheckedCreateWithoutCourierInput> | DeliveryLogCreateWithoutCourierInput[] | DeliveryLogUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryLogCreateOrConnectWithoutCourierInput | DeliveryLogCreateOrConnectWithoutCourierInput[]
    upsert?: DeliveryLogUpsertWithWhereUniqueWithoutCourierInput | DeliveryLogUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: DeliveryLogCreateManyCourierInputEnvelope
    set?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    disconnect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    delete?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    connect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    update?: DeliveryLogUpdateWithWhereUniqueWithoutCourierInput | DeliveryLogUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: DeliveryLogUpdateManyWithWhereWithoutCourierInput | DeliveryLogUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: DeliveryLogScalarWhereInput | DeliveryLogScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateManyWithoutCourierNestedInput = {
    create?: XOR<DeliveryCreateWithoutCourierInput, DeliveryUncheckedCreateWithoutCourierInput> | DeliveryCreateWithoutCourierInput[] | DeliveryUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCourierInput | DeliveryCreateOrConnectWithoutCourierInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutCourierInput | DeliveryUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: DeliveryCreateManyCourierInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutCourierInput | DeliveryUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutCourierInput | DeliveryUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<PaymentCreateWithoutRecipientInput, PaymentUncheckedCreateWithoutRecipientInput> | PaymentCreateWithoutRecipientInput[] | PaymentUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutRecipientInput | PaymentCreateOrConnectWithoutRecipientInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutRecipientInput | PaymentUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: PaymentCreateManyRecipientInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutRecipientInput | PaymentUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutRecipientInput | PaymentUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CourierAvailabilityUncheckedUpdateManyWithoutCourierNestedInput = {
    create?: XOR<CourierAvailabilityCreateWithoutCourierInput, CourierAvailabilityUncheckedCreateWithoutCourierInput> | CourierAvailabilityCreateWithoutCourierInput[] | CourierAvailabilityUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: CourierAvailabilityCreateOrConnectWithoutCourierInput | CourierAvailabilityCreateOrConnectWithoutCourierInput[]
    upsert?: CourierAvailabilityUpsertWithWhereUniqueWithoutCourierInput | CourierAvailabilityUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: CourierAvailabilityCreateManyCourierInputEnvelope
    set?: CourierAvailabilityWhereUniqueInput | CourierAvailabilityWhereUniqueInput[]
    disconnect?: CourierAvailabilityWhereUniqueInput | CourierAvailabilityWhereUniqueInput[]
    delete?: CourierAvailabilityWhereUniqueInput | CourierAvailabilityWhereUniqueInput[]
    connect?: CourierAvailabilityWhereUniqueInput | CourierAvailabilityWhereUniqueInput[]
    update?: CourierAvailabilityUpdateWithWhereUniqueWithoutCourierInput | CourierAvailabilityUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: CourierAvailabilityUpdateManyWithWhereWithoutCourierInput | CourierAvailabilityUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: CourierAvailabilityScalarWhereInput | CourierAvailabilityScalarWhereInput[]
  }

  export type DeliveryRouteUncheckedUpdateManyWithoutCourierNestedInput = {
    create?: XOR<DeliveryRouteCreateWithoutCourierInput, DeliveryRouteUncheckedCreateWithoutCourierInput> | DeliveryRouteCreateWithoutCourierInput[] | DeliveryRouteUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryRouteCreateOrConnectWithoutCourierInput | DeliveryRouteCreateOrConnectWithoutCourierInput[]
    upsert?: DeliveryRouteUpsertWithWhereUniqueWithoutCourierInput | DeliveryRouteUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: DeliveryRouteCreateManyCourierInputEnvelope
    set?: DeliveryRouteWhereUniqueInput | DeliveryRouteWhereUniqueInput[]
    disconnect?: DeliveryRouteWhereUniqueInput | DeliveryRouteWhereUniqueInput[]
    delete?: DeliveryRouteWhereUniqueInput | DeliveryRouteWhereUniqueInput[]
    connect?: DeliveryRouteWhereUniqueInput | DeliveryRouteWhereUniqueInput[]
    update?: DeliveryRouteUpdateWithWhereUniqueWithoutCourierInput | DeliveryRouteUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: DeliveryRouteUpdateManyWithWhereWithoutCourierInput | DeliveryRouteUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: DeliveryRouteScalarWhereInput | DeliveryRouteScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type BusinessCreateNestedOneWithoutOrdersInput = {
    create?: XOR<BusinessCreateWithoutOrdersInput, BusinessUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutOrdersInput
    connect?: BusinessWhereUniqueInput
  }

  export type CourierCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CourierCreateWithoutOrdersInput, CourierUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CourierCreateOrConnectWithoutOrdersInput
    connect?: CourierWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutOrderInput = {
    create?: XOR<NotificationCreateWithoutOrderInput, NotificationUncheckedCreateWithoutOrderInput> | NotificationCreateWithoutOrderInput[] | NotificationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrderInput | NotificationCreateOrConnectWithoutOrderInput[]
    createMany?: NotificationCreateManyOrderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DeliveryTimeWindowCreateNestedOneWithoutOrdersInput = {
    create?: XOR<DeliveryTimeWindowCreateWithoutOrdersInput, DeliveryTimeWindowUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: DeliveryTimeWindowCreateOrConnectWithoutOrdersInput
    connect?: DeliveryTimeWindowWhereUniqueInput
  }

  export type DeliveryCreateNestedOneWithoutOrderInput = {
    create?: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutOrderInput
    connect?: DeliveryWhereUniqueInput
  }

  export type RefundRequestCreateNestedManyWithoutOrderInput = {
    create?: XOR<RefundRequestCreateWithoutOrderInput, RefundRequestUncheckedCreateWithoutOrderInput> | RefundRequestCreateWithoutOrderInput[] | RefundRequestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutOrderInput | RefundRequestCreateOrConnectWithoutOrderInput[]
    createMany?: RefundRequestCreateManyOrderInputEnvelope
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
  }

  export type CancellationRequestCreateNestedManyWithoutOrderInput = {
    create?: XOR<CancellationRequestCreateWithoutOrderInput, CancellationRequestUncheckedCreateWithoutOrderInput> | CancellationRequestCreateWithoutOrderInput[] | CancellationRequestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CancellationRequestCreateOrConnectWithoutOrderInput | CancellationRequestCreateOrConnectWithoutOrderInput[]
    createMany?: CancellationRequestCreateManyOrderInputEnvelope
    connect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<NotificationCreateWithoutOrderInput, NotificationUncheckedCreateWithoutOrderInput> | NotificationCreateWithoutOrderInput[] | NotificationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrderInput | NotificationCreateOrConnectWithoutOrderInput[]
    createMany?: NotificationCreateManyOrderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutOrderInput
    connect?: DeliveryWhereUniqueInput
  }

  export type RefundRequestUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<RefundRequestCreateWithoutOrderInput, RefundRequestUncheckedCreateWithoutOrderInput> | RefundRequestCreateWithoutOrderInput[] | RefundRequestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutOrderInput | RefundRequestCreateOrConnectWithoutOrderInput[]
    createMany?: RefundRequestCreateManyOrderInputEnvelope
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
  }

  export type CancellationRequestUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<CancellationRequestCreateWithoutOrderInput, CancellationRequestUncheckedCreateWithoutOrderInput> | CancellationRequestCreateWithoutOrderInput[] | CancellationRequestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CancellationRequestCreateOrConnectWithoutOrderInput | CancellationRequestCreateOrConnectWithoutOrderInput[]
    createMany?: CancellationRequestCreateManyOrderInputEnvelope
    connect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumDeliveryPriorityFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryPriority
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type BusinessUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<BusinessCreateWithoutOrdersInput, BusinessUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutOrdersInput
    upsert?: BusinessUpsertWithoutOrdersInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutOrdersInput, BusinessUpdateWithoutOrdersInput>, BusinessUncheckedUpdateWithoutOrdersInput>
  }

  export type CourierUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<CourierCreateWithoutOrdersInput, CourierUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CourierCreateOrConnectWithoutOrdersInput
    upsert?: CourierUpsertWithoutOrdersInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutOrdersInput, CourierUpdateWithoutOrdersInput>, CourierUncheckedUpdateWithoutOrdersInput>
  }

  export type NotificationUpdateManyWithoutOrderNestedInput = {
    create?: XOR<NotificationCreateWithoutOrderInput, NotificationUncheckedCreateWithoutOrderInput> | NotificationCreateWithoutOrderInput[] | NotificationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrderInput | NotificationCreateOrConnectWithoutOrderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutOrderInput | NotificationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: NotificationCreateManyOrderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutOrderInput | NotificationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutOrderInput | NotificationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DeliveryTimeWindowUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<DeliveryTimeWindowCreateWithoutOrdersInput, DeliveryTimeWindowUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: DeliveryTimeWindowCreateOrConnectWithoutOrdersInput
    upsert?: DeliveryTimeWindowUpsertWithoutOrdersInput
    disconnect?: DeliveryTimeWindowWhereInput | boolean
    delete?: DeliveryTimeWindowWhereInput | boolean
    connect?: DeliveryTimeWindowWhereUniqueInput
    update?: XOR<XOR<DeliveryTimeWindowUpdateToOneWithWhereWithoutOrdersInput, DeliveryTimeWindowUpdateWithoutOrdersInput>, DeliveryTimeWindowUncheckedUpdateWithoutOrdersInput>
  }

  export type DeliveryUpdateOneWithoutOrderNestedInput = {
    create?: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutOrderInput
    upsert?: DeliveryUpsertWithoutOrderInput
    disconnect?: DeliveryWhereInput | boolean
    delete?: DeliveryWhereInput | boolean
    connect?: DeliveryWhereUniqueInput
    update?: XOR<XOR<DeliveryUpdateToOneWithWhereWithoutOrderInput, DeliveryUpdateWithoutOrderInput>, DeliveryUncheckedUpdateWithoutOrderInput>
  }

  export type RefundRequestUpdateManyWithoutOrderNestedInput = {
    create?: XOR<RefundRequestCreateWithoutOrderInput, RefundRequestUncheckedCreateWithoutOrderInput> | RefundRequestCreateWithoutOrderInput[] | RefundRequestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutOrderInput | RefundRequestCreateOrConnectWithoutOrderInput[]
    upsert?: RefundRequestUpsertWithWhereUniqueWithoutOrderInput | RefundRequestUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: RefundRequestCreateManyOrderInputEnvelope
    set?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    disconnect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    delete?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    update?: RefundRequestUpdateWithWhereUniqueWithoutOrderInput | RefundRequestUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: RefundRequestUpdateManyWithWhereWithoutOrderInput | RefundRequestUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: RefundRequestScalarWhereInput | RefundRequestScalarWhereInput[]
  }

  export type CancellationRequestUpdateManyWithoutOrderNestedInput = {
    create?: XOR<CancellationRequestCreateWithoutOrderInput, CancellationRequestUncheckedCreateWithoutOrderInput> | CancellationRequestCreateWithoutOrderInput[] | CancellationRequestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CancellationRequestCreateOrConnectWithoutOrderInput | CancellationRequestCreateOrConnectWithoutOrderInput[]
    upsert?: CancellationRequestUpsertWithWhereUniqueWithoutOrderInput | CancellationRequestUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: CancellationRequestCreateManyOrderInputEnvelope
    set?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    disconnect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    delete?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    connect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    update?: CancellationRequestUpdateWithWhereUniqueWithoutOrderInput | CancellationRequestUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: CancellationRequestUpdateManyWithWhereWithoutOrderInput | CancellationRequestUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: CancellationRequestScalarWhereInput | CancellationRequestScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<NotificationCreateWithoutOrderInput, NotificationUncheckedCreateWithoutOrderInput> | NotificationCreateWithoutOrderInput[] | NotificationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrderInput | NotificationCreateOrConnectWithoutOrderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutOrderInput | NotificationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: NotificationCreateManyOrderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutOrderInput | NotificationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutOrderInput | NotificationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutOrderInput
    upsert?: DeliveryUpsertWithoutOrderInput
    disconnect?: DeliveryWhereInput | boolean
    delete?: DeliveryWhereInput | boolean
    connect?: DeliveryWhereUniqueInput
    update?: XOR<XOR<DeliveryUpdateToOneWithWhereWithoutOrderInput, DeliveryUpdateWithoutOrderInput>, DeliveryUncheckedUpdateWithoutOrderInput>
  }

  export type RefundRequestUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<RefundRequestCreateWithoutOrderInput, RefundRequestUncheckedCreateWithoutOrderInput> | RefundRequestCreateWithoutOrderInput[] | RefundRequestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutOrderInput | RefundRequestCreateOrConnectWithoutOrderInput[]
    upsert?: RefundRequestUpsertWithWhereUniqueWithoutOrderInput | RefundRequestUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: RefundRequestCreateManyOrderInputEnvelope
    set?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    disconnect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    delete?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    update?: RefundRequestUpdateWithWhereUniqueWithoutOrderInput | RefundRequestUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: RefundRequestUpdateManyWithWhereWithoutOrderInput | RefundRequestUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: RefundRequestScalarWhereInput | RefundRequestScalarWhereInput[]
  }

  export type CancellationRequestUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<CancellationRequestCreateWithoutOrderInput, CancellationRequestUncheckedCreateWithoutOrderInput> | CancellationRequestCreateWithoutOrderInput[] | CancellationRequestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CancellationRequestCreateOrConnectWithoutOrderInput | CancellationRequestCreateOrConnectWithoutOrderInput[]
    upsert?: CancellationRequestUpsertWithWhereUniqueWithoutOrderInput | CancellationRequestUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: CancellationRequestCreateManyOrderInputEnvelope
    set?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    disconnect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    delete?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    connect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    update?: CancellationRequestUpdateWithWhereUniqueWithoutOrderInput | CancellationRequestUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: CancellationRequestUpdateManyWithWhereWithoutOrderInput | CancellationRequestUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: CancellationRequestScalarWhereInput | CancellationRequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCustomerInput = {
    create?: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type DeliveryCreateNestedManyWithoutCustomerInput = {
    create?: XOR<DeliveryCreateWithoutCustomerInput, DeliveryUncheckedCreateWithoutCustomerInput> | DeliveryCreateWithoutCustomerInput[] | DeliveryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCustomerInput | DeliveryCreateOrConnectWithoutCustomerInput[]
    createMany?: DeliveryCreateManyCustomerInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type CustomerAddressCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
  }

  export type RefundRequestCreateNestedManyWithoutCustomerInput = {
    create?: XOR<RefundRequestCreateWithoutCustomerInput, RefundRequestUncheckedCreateWithoutCustomerInput> | RefundRequestCreateWithoutCustomerInput[] | RefundRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutCustomerInput | RefundRequestCreateOrConnectWithoutCustomerInput[]
    createMany?: RefundRequestCreateManyCustomerInputEnvelope
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
  }

  export type CancellationRequestCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CancellationRequestCreateWithoutCustomerInput, CancellationRequestUncheckedCreateWithoutCustomerInput> | CancellationRequestCreateWithoutCustomerInput[] | CancellationRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CancellationRequestCreateOrConnectWithoutCustomerInput | CancellationRequestCreateOrConnectWithoutCustomerInput[]
    createMany?: CancellationRequestCreateManyCustomerInputEnvelope
    connect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
  }

  export type SavedPaymentMethodCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SavedPaymentMethodCreateWithoutCustomerInput, SavedPaymentMethodUncheckedCreateWithoutCustomerInput> | SavedPaymentMethodCreateWithoutCustomerInput[] | SavedPaymentMethodUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SavedPaymentMethodCreateOrConnectWithoutCustomerInput | SavedPaymentMethodCreateOrConnectWithoutCustomerInput[]
    createMany?: SavedPaymentMethodCreateManyCustomerInputEnvelope
    connect?: SavedPaymentMethodWhereUniqueInput | SavedPaymentMethodWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<DeliveryCreateWithoutCustomerInput, DeliveryUncheckedCreateWithoutCustomerInput> | DeliveryCreateWithoutCustomerInput[] | DeliveryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCustomerInput | DeliveryCreateOrConnectWithoutCustomerInput[]
    createMany?: DeliveryCreateManyCustomerInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
  }

  export type RefundRequestUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<RefundRequestCreateWithoutCustomerInput, RefundRequestUncheckedCreateWithoutCustomerInput> | RefundRequestCreateWithoutCustomerInput[] | RefundRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutCustomerInput | RefundRequestCreateOrConnectWithoutCustomerInput[]
    createMany?: RefundRequestCreateManyCustomerInputEnvelope
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
  }

  export type CancellationRequestUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CancellationRequestCreateWithoutCustomerInput, CancellationRequestUncheckedCreateWithoutCustomerInput> | CancellationRequestCreateWithoutCustomerInput[] | CancellationRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CancellationRequestCreateOrConnectWithoutCustomerInput | CancellationRequestCreateOrConnectWithoutCustomerInput[]
    createMany?: CancellationRequestCreateManyCustomerInputEnvelope
    connect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
  }

  export type SavedPaymentMethodUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SavedPaymentMethodCreateWithoutCustomerInput, SavedPaymentMethodUncheckedCreateWithoutCustomerInput> | SavedPaymentMethodCreateWithoutCustomerInput[] | SavedPaymentMethodUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SavedPaymentMethodCreateOrConnectWithoutCustomerInput | SavedPaymentMethodCreateOrConnectWithoutCustomerInput[]
    createMany?: SavedPaymentMethodCreateManyCustomerInputEnvelope
    connect?: SavedPaymentMethodWhereUniqueInput | SavedPaymentMethodWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCustomerNestedInput = {
    create?: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerInput
    upsert?: UserUpsertWithoutCustomerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomerInput, UserUpdateWithoutCustomerInput>, UserUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type DeliveryUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<DeliveryCreateWithoutCustomerInput, DeliveryUncheckedCreateWithoutCustomerInput> | DeliveryCreateWithoutCustomerInput[] | DeliveryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCustomerInput | DeliveryCreateOrConnectWithoutCustomerInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutCustomerInput | DeliveryUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: DeliveryCreateManyCustomerInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutCustomerInput | DeliveryUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutCustomerInput | DeliveryUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type CustomerAddressUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput | CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    set?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    disconnect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    delete?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    update?: CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput | CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerAddressUpdateManyWithWhereWithoutCustomerInput | CustomerAddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
  }

  export type RefundRequestUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<RefundRequestCreateWithoutCustomerInput, RefundRequestUncheckedCreateWithoutCustomerInput> | RefundRequestCreateWithoutCustomerInput[] | RefundRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutCustomerInput | RefundRequestCreateOrConnectWithoutCustomerInput[]
    upsert?: RefundRequestUpsertWithWhereUniqueWithoutCustomerInput | RefundRequestUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: RefundRequestCreateManyCustomerInputEnvelope
    set?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    disconnect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    delete?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    update?: RefundRequestUpdateWithWhereUniqueWithoutCustomerInput | RefundRequestUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: RefundRequestUpdateManyWithWhereWithoutCustomerInput | RefundRequestUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: RefundRequestScalarWhereInput | RefundRequestScalarWhereInput[]
  }

  export type CancellationRequestUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CancellationRequestCreateWithoutCustomerInput, CancellationRequestUncheckedCreateWithoutCustomerInput> | CancellationRequestCreateWithoutCustomerInput[] | CancellationRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CancellationRequestCreateOrConnectWithoutCustomerInput | CancellationRequestCreateOrConnectWithoutCustomerInput[]
    upsert?: CancellationRequestUpsertWithWhereUniqueWithoutCustomerInput | CancellationRequestUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CancellationRequestCreateManyCustomerInputEnvelope
    set?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    disconnect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    delete?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    connect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    update?: CancellationRequestUpdateWithWhereUniqueWithoutCustomerInput | CancellationRequestUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CancellationRequestUpdateManyWithWhereWithoutCustomerInput | CancellationRequestUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CancellationRequestScalarWhereInput | CancellationRequestScalarWhereInput[]
  }

  export type SavedPaymentMethodUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SavedPaymentMethodCreateWithoutCustomerInput, SavedPaymentMethodUncheckedCreateWithoutCustomerInput> | SavedPaymentMethodCreateWithoutCustomerInput[] | SavedPaymentMethodUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SavedPaymentMethodCreateOrConnectWithoutCustomerInput | SavedPaymentMethodCreateOrConnectWithoutCustomerInput[]
    upsert?: SavedPaymentMethodUpsertWithWhereUniqueWithoutCustomerInput | SavedPaymentMethodUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SavedPaymentMethodCreateManyCustomerInputEnvelope
    set?: SavedPaymentMethodWhereUniqueInput | SavedPaymentMethodWhereUniqueInput[]
    disconnect?: SavedPaymentMethodWhereUniqueInput | SavedPaymentMethodWhereUniqueInput[]
    delete?: SavedPaymentMethodWhereUniqueInput | SavedPaymentMethodWhereUniqueInput[]
    connect?: SavedPaymentMethodWhereUniqueInput | SavedPaymentMethodWhereUniqueInput[]
    update?: SavedPaymentMethodUpdateWithWhereUniqueWithoutCustomerInput | SavedPaymentMethodUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SavedPaymentMethodUpdateManyWithWhereWithoutCustomerInput | SavedPaymentMethodUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SavedPaymentMethodScalarWhereInput | SavedPaymentMethodScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutCustomerInput | SubscriptionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutCustomerInput | SubscriptionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutCustomerInput | SubscriptionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<DeliveryCreateWithoutCustomerInput, DeliveryUncheckedCreateWithoutCustomerInput> | DeliveryCreateWithoutCustomerInput[] | DeliveryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCustomerInput | DeliveryCreateOrConnectWithoutCustomerInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutCustomerInput | DeliveryUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: DeliveryCreateManyCustomerInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutCustomerInput | DeliveryUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutCustomerInput | DeliveryUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput | CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    set?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    disconnect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    delete?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    update?: CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput | CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerAddressUpdateManyWithWhereWithoutCustomerInput | CustomerAddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
  }

  export type RefundRequestUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<RefundRequestCreateWithoutCustomerInput, RefundRequestUncheckedCreateWithoutCustomerInput> | RefundRequestCreateWithoutCustomerInput[] | RefundRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutCustomerInput | RefundRequestCreateOrConnectWithoutCustomerInput[]
    upsert?: RefundRequestUpsertWithWhereUniqueWithoutCustomerInput | RefundRequestUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: RefundRequestCreateManyCustomerInputEnvelope
    set?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    disconnect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    delete?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    update?: RefundRequestUpdateWithWhereUniqueWithoutCustomerInput | RefundRequestUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: RefundRequestUpdateManyWithWhereWithoutCustomerInput | RefundRequestUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: RefundRequestScalarWhereInput | RefundRequestScalarWhereInput[]
  }

  export type CancellationRequestUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CancellationRequestCreateWithoutCustomerInput, CancellationRequestUncheckedCreateWithoutCustomerInput> | CancellationRequestCreateWithoutCustomerInput[] | CancellationRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CancellationRequestCreateOrConnectWithoutCustomerInput | CancellationRequestCreateOrConnectWithoutCustomerInput[]
    upsert?: CancellationRequestUpsertWithWhereUniqueWithoutCustomerInput | CancellationRequestUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CancellationRequestCreateManyCustomerInputEnvelope
    set?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    disconnect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    delete?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    connect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    update?: CancellationRequestUpdateWithWhereUniqueWithoutCustomerInput | CancellationRequestUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CancellationRequestUpdateManyWithWhereWithoutCustomerInput | CancellationRequestUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CancellationRequestScalarWhereInput | CancellationRequestScalarWhereInput[]
  }

  export type SavedPaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SavedPaymentMethodCreateWithoutCustomerInput, SavedPaymentMethodUncheckedCreateWithoutCustomerInput> | SavedPaymentMethodCreateWithoutCustomerInput[] | SavedPaymentMethodUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SavedPaymentMethodCreateOrConnectWithoutCustomerInput | SavedPaymentMethodCreateOrConnectWithoutCustomerInput[]
    upsert?: SavedPaymentMethodUpsertWithWhereUniqueWithoutCustomerInput | SavedPaymentMethodUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SavedPaymentMethodCreateManyCustomerInputEnvelope
    set?: SavedPaymentMethodWhereUniqueInput | SavedPaymentMethodWhereUniqueInput[]
    disconnect?: SavedPaymentMethodWhereUniqueInput | SavedPaymentMethodWhereUniqueInput[]
    delete?: SavedPaymentMethodWhereUniqueInput | SavedPaymentMethodWhereUniqueInput[]
    connect?: SavedPaymentMethodWhereUniqueInput | SavedPaymentMethodWhereUniqueInput[]
    update?: SavedPaymentMethodUpdateWithWhereUniqueWithoutCustomerInput | SavedPaymentMethodUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SavedPaymentMethodUpdateManyWithWhereWithoutCustomerInput | SavedPaymentMethodUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SavedPaymentMethodScalarWhereInput | SavedPaymentMethodScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutCustomerInput | SubscriptionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutCustomerInput | SubscriptionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutCustomerInput | SubscriptionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type BusinessCreatetagsInput = {
    set: string[]
  }

  export type BusinessCreatefeaturesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutBusinessInput = {
    create?: XOR<UserCreateWithoutBusinessInput, UserUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: UserCreateOrConnectWithoutBusinessInput
    connect?: UserWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutBusinessesInput = {
    create?: XOR<ZoneCreateWithoutBusinessesInput, ZoneUncheckedCreateWithoutBusinessesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutBusinessesInput
    connect?: ZoneWhereUniqueInput
  }

  export type InventoryCreateNestedManyWithoutBusinessInput = {
    create?: XOR<InventoryCreateWithoutBusinessInput, InventoryUncheckedCreateWithoutBusinessInput> | InventoryCreateWithoutBusinessInput[] | InventoryUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutBusinessInput | InventoryCreateOrConnectWithoutBusinessInput[]
    createMany?: InventoryCreateManyBusinessInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutBusinessInput = {
    create?: XOR<OrderCreateWithoutBusinessInput, OrderUncheckedCreateWithoutBusinessInput> | OrderCreateWithoutBusinessInput[] | OrderUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBusinessInput | OrderCreateOrConnectWithoutBusinessInput[]
    createMany?: OrderCreateManyBusinessInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type MenuItemCreateNestedManyWithoutBusinessInput = {
    create?: XOR<MenuItemCreateWithoutBusinessInput, MenuItemUncheckedCreateWithoutBusinessInput> | MenuItemCreateWithoutBusinessInput[] | MenuItemUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutBusinessInput | MenuItemCreateOrConnectWithoutBusinessInput[]
    createMany?: MenuItemCreateManyBusinessInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type ProductCategoryCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ProductCategoryCreateWithoutBusinessInput, ProductCategoryUncheckedCreateWithoutBusinessInput> | ProductCategoryCreateWithoutBusinessInput[] | ProductCategoryUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutBusinessInput | ProductCategoryCreateOrConnectWithoutBusinessInput[]
    createMany?: ProductCategoryCreateManyBusinessInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutBusinessInput = {
    create?: XOR<PaymentCreateWithoutBusinessInput, PaymentUncheckedCreateWithoutBusinessInput> | PaymentCreateWithoutBusinessInput[] | PaymentUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBusinessInput | PaymentCreateOrConnectWithoutBusinessInput[]
    createMany?: PaymentCreateManyBusinessInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RefundPolicyCreateNestedManyWithoutBusinessInput = {
    create?: XOR<RefundPolicyCreateWithoutBusinessInput, RefundPolicyUncheckedCreateWithoutBusinessInput> | RefundPolicyCreateWithoutBusinessInput[] | RefundPolicyUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RefundPolicyCreateOrConnectWithoutBusinessInput | RefundPolicyCreateOrConnectWithoutBusinessInput[]
    createMany?: RefundPolicyCreateManyBusinessInputEnvelope
    connect?: RefundPolicyWhereUniqueInput | RefundPolicyWhereUniqueInput[]
  }

  export type RefundRequestCreateNestedManyWithoutBusinessInput = {
    create?: XOR<RefundRequestCreateWithoutBusinessInput, RefundRequestUncheckedCreateWithoutBusinessInput> | RefundRequestCreateWithoutBusinessInput[] | RefundRequestUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutBusinessInput | RefundRequestCreateOrConnectWithoutBusinessInput[]
    createMany?: RefundRequestCreateManyBusinessInputEnvelope
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
  }

  export type CancellationRequestCreateNestedManyWithoutBusinessInput = {
    create?: XOR<CancellationRequestCreateWithoutBusinessInput, CancellationRequestUncheckedCreateWithoutBusinessInput> | CancellationRequestCreateWithoutBusinessInput[] | CancellationRequestUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: CancellationRequestCreateOrConnectWithoutBusinessInput | CancellationRequestCreateOrConnectWithoutBusinessInput[]
    createMany?: CancellationRequestCreateManyBusinessInputEnvelope
    connect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
  }

  export type SubscriptionPlanCreateNestedManyWithoutBusinessInput = {
    create?: XOR<SubscriptionPlanCreateWithoutBusinessInput, SubscriptionPlanUncheckedCreateWithoutBusinessInput> | SubscriptionPlanCreateWithoutBusinessInput[] | SubscriptionPlanUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutBusinessInput | SubscriptionPlanCreateOrConnectWithoutBusinessInput[]
    createMany?: SubscriptionPlanCreateManyBusinessInputEnvelope
    connect?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutBusinessInput = {
    create?: XOR<SubscriptionCreateWithoutBusinessInput, SubscriptionUncheckedCreateWithoutBusinessInput> | SubscriptionCreateWithoutBusinessInput[] | SubscriptionUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutBusinessInput | SubscriptionCreateOrConnectWithoutBusinessInput[]
    createMany?: SubscriptionCreateManyBusinessInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<InventoryCreateWithoutBusinessInput, InventoryUncheckedCreateWithoutBusinessInput> | InventoryCreateWithoutBusinessInput[] | InventoryUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutBusinessInput | InventoryCreateOrConnectWithoutBusinessInput[]
    createMany?: InventoryCreateManyBusinessInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<OrderCreateWithoutBusinessInput, OrderUncheckedCreateWithoutBusinessInput> | OrderCreateWithoutBusinessInput[] | OrderUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBusinessInput | OrderCreateOrConnectWithoutBusinessInput[]
    createMany?: OrderCreateManyBusinessInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type MenuItemUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<MenuItemCreateWithoutBusinessInput, MenuItemUncheckedCreateWithoutBusinessInput> | MenuItemCreateWithoutBusinessInput[] | MenuItemUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutBusinessInput | MenuItemCreateOrConnectWithoutBusinessInput[]
    createMany?: MenuItemCreateManyBusinessInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ProductCategoryCreateWithoutBusinessInput, ProductCategoryUncheckedCreateWithoutBusinessInput> | ProductCategoryCreateWithoutBusinessInput[] | ProductCategoryUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutBusinessInput | ProductCategoryCreateOrConnectWithoutBusinessInput[]
    createMany?: ProductCategoryCreateManyBusinessInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<PaymentCreateWithoutBusinessInput, PaymentUncheckedCreateWithoutBusinessInput> | PaymentCreateWithoutBusinessInput[] | PaymentUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBusinessInput | PaymentCreateOrConnectWithoutBusinessInput[]
    createMany?: PaymentCreateManyBusinessInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RefundPolicyUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<RefundPolicyCreateWithoutBusinessInput, RefundPolicyUncheckedCreateWithoutBusinessInput> | RefundPolicyCreateWithoutBusinessInput[] | RefundPolicyUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RefundPolicyCreateOrConnectWithoutBusinessInput | RefundPolicyCreateOrConnectWithoutBusinessInput[]
    createMany?: RefundPolicyCreateManyBusinessInputEnvelope
    connect?: RefundPolicyWhereUniqueInput | RefundPolicyWhereUniqueInput[]
  }

  export type RefundRequestUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<RefundRequestCreateWithoutBusinessInput, RefundRequestUncheckedCreateWithoutBusinessInput> | RefundRequestCreateWithoutBusinessInput[] | RefundRequestUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutBusinessInput | RefundRequestCreateOrConnectWithoutBusinessInput[]
    createMany?: RefundRequestCreateManyBusinessInputEnvelope
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
  }

  export type CancellationRequestUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<CancellationRequestCreateWithoutBusinessInput, CancellationRequestUncheckedCreateWithoutBusinessInput> | CancellationRequestCreateWithoutBusinessInput[] | CancellationRequestUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: CancellationRequestCreateOrConnectWithoutBusinessInput | CancellationRequestCreateOrConnectWithoutBusinessInput[]
    createMany?: CancellationRequestCreateManyBusinessInputEnvelope
    connect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
  }

  export type SubscriptionPlanUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<SubscriptionPlanCreateWithoutBusinessInput, SubscriptionPlanUncheckedCreateWithoutBusinessInput> | SubscriptionPlanCreateWithoutBusinessInput[] | SubscriptionPlanUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutBusinessInput | SubscriptionPlanCreateOrConnectWithoutBusinessInput[]
    createMany?: SubscriptionPlanCreateManyBusinessInputEnvelope
    connect?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<SubscriptionCreateWithoutBusinessInput, SubscriptionUncheckedCreateWithoutBusinessInput> | SubscriptionCreateWithoutBusinessInput[] | SubscriptionUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutBusinessInput | SubscriptionCreateOrConnectWithoutBusinessInput[]
    createMany?: SubscriptionCreateManyBusinessInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type BusinessUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BusinessUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutBusinessNestedInput = {
    create?: XOR<UserCreateWithoutBusinessInput, UserUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: UserCreateOrConnectWithoutBusinessInput
    upsert?: UserUpsertWithoutBusinessInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBusinessInput, UserUpdateWithoutBusinessInput>, UserUncheckedUpdateWithoutBusinessInput>
  }

  export type ZoneUpdateOneWithoutBusinessesNestedInput = {
    create?: XOR<ZoneCreateWithoutBusinessesInput, ZoneUncheckedCreateWithoutBusinessesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutBusinessesInput
    upsert?: ZoneUpsertWithoutBusinessesInput
    disconnect?: ZoneWhereInput | boolean
    delete?: ZoneWhereInput | boolean
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutBusinessesInput, ZoneUpdateWithoutBusinessesInput>, ZoneUncheckedUpdateWithoutBusinessesInput>
  }

  export type InventoryUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<InventoryCreateWithoutBusinessInput, InventoryUncheckedCreateWithoutBusinessInput> | InventoryCreateWithoutBusinessInput[] | InventoryUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutBusinessInput | InventoryCreateOrConnectWithoutBusinessInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutBusinessInput | InventoryUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: InventoryCreateManyBusinessInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutBusinessInput | InventoryUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutBusinessInput | InventoryUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<OrderCreateWithoutBusinessInput, OrderUncheckedCreateWithoutBusinessInput> | OrderCreateWithoutBusinessInput[] | OrderUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBusinessInput | OrderCreateOrConnectWithoutBusinessInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutBusinessInput | OrderUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: OrderCreateManyBusinessInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutBusinessInput | OrderUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutBusinessInput | OrderUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type MenuItemUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<MenuItemCreateWithoutBusinessInput, MenuItemUncheckedCreateWithoutBusinessInput> | MenuItemCreateWithoutBusinessInput[] | MenuItemUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutBusinessInput | MenuItemCreateOrConnectWithoutBusinessInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutBusinessInput | MenuItemUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: MenuItemCreateManyBusinessInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutBusinessInput | MenuItemUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutBusinessInput | MenuItemUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type ProductCategoryUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutBusinessInput, ProductCategoryUncheckedCreateWithoutBusinessInput> | ProductCategoryCreateWithoutBusinessInput[] | ProductCategoryUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutBusinessInput | ProductCategoryCreateOrConnectWithoutBusinessInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutBusinessInput | ProductCategoryUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ProductCategoryCreateManyBusinessInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutBusinessInput | ProductCategoryUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutBusinessInput | ProductCategoryUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<PaymentCreateWithoutBusinessInput, PaymentUncheckedCreateWithoutBusinessInput> | PaymentCreateWithoutBusinessInput[] | PaymentUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBusinessInput | PaymentCreateOrConnectWithoutBusinessInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBusinessInput | PaymentUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: PaymentCreateManyBusinessInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBusinessInput | PaymentUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBusinessInput | PaymentUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RefundPolicyUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<RefundPolicyCreateWithoutBusinessInput, RefundPolicyUncheckedCreateWithoutBusinessInput> | RefundPolicyCreateWithoutBusinessInput[] | RefundPolicyUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RefundPolicyCreateOrConnectWithoutBusinessInput | RefundPolicyCreateOrConnectWithoutBusinessInput[]
    upsert?: RefundPolicyUpsertWithWhereUniqueWithoutBusinessInput | RefundPolicyUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: RefundPolicyCreateManyBusinessInputEnvelope
    set?: RefundPolicyWhereUniqueInput | RefundPolicyWhereUniqueInput[]
    disconnect?: RefundPolicyWhereUniqueInput | RefundPolicyWhereUniqueInput[]
    delete?: RefundPolicyWhereUniqueInput | RefundPolicyWhereUniqueInput[]
    connect?: RefundPolicyWhereUniqueInput | RefundPolicyWhereUniqueInput[]
    update?: RefundPolicyUpdateWithWhereUniqueWithoutBusinessInput | RefundPolicyUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: RefundPolicyUpdateManyWithWhereWithoutBusinessInput | RefundPolicyUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: RefundPolicyScalarWhereInput | RefundPolicyScalarWhereInput[]
  }

  export type RefundRequestUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<RefundRequestCreateWithoutBusinessInput, RefundRequestUncheckedCreateWithoutBusinessInput> | RefundRequestCreateWithoutBusinessInput[] | RefundRequestUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutBusinessInput | RefundRequestCreateOrConnectWithoutBusinessInput[]
    upsert?: RefundRequestUpsertWithWhereUniqueWithoutBusinessInput | RefundRequestUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: RefundRequestCreateManyBusinessInputEnvelope
    set?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    disconnect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    delete?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    update?: RefundRequestUpdateWithWhereUniqueWithoutBusinessInput | RefundRequestUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: RefundRequestUpdateManyWithWhereWithoutBusinessInput | RefundRequestUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: RefundRequestScalarWhereInput | RefundRequestScalarWhereInput[]
  }

  export type CancellationRequestUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<CancellationRequestCreateWithoutBusinessInput, CancellationRequestUncheckedCreateWithoutBusinessInput> | CancellationRequestCreateWithoutBusinessInput[] | CancellationRequestUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: CancellationRequestCreateOrConnectWithoutBusinessInput | CancellationRequestCreateOrConnectWithoutBusinessInput[]
    upsert?: CancellationRequestUpsertWithWhereUniqueWithoutBusinessInput | CancellationRequestUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: CancellationRequestCreateManyBusinessInputEnvelope
    set?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    disconnect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    delete?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    connect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    update?: CancellationRequestUpdateWithWhereUniqueWithoutBusinessInput | CancellationRequestUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: CancellationRequestUpdateManyWithWhereWithoutBusinessInput | CancellationRequestUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: CancellationRequestScalarWhereInput | CancellationRequestScalarWhereInput[]
  }

  export type SubscriptionPlanUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutBusinessInput, SubscriptionPlanUncheckedCreateWithoutBusinessInput> | SubscriptionPlanCreateWithoutBusinessInput[] | SubscriptionPlanUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutBusinessInput | SubscriptionPlanCreateOrConnectWithoutBusinessInput[]
    upsert?: SubscriptionPlanUpsertWithWhereUniqueWithoutBusinessInput | SubscriptionPlanUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: SubscriptionPlanCreateManyBusinessInputEnvelope
    set?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    disconnect?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    delete?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    connect?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    update?: SubscriptionPlanUpdateWithWhereUniqueWithoutBusinessInput | SubscriptionPlanUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: SubscriptionPlanUpdateManyWithWhereWithoutBusinessInput | SubscriptionPlanUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: SubscriptionPlanScalarWhereInput | SubscriptionPlanScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<SubscriptionCreateWithoutBusinessInput, SubscriptionUncheckedCreateWithoutBusinessInput> | SubscriptionCreateWithoutBusinessInput[] | SubscriptionUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutBusinessInput | SubscriptionCreateOrConnectWithoutBusinessInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutBusinessInput | SubscriptionUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: SubscriptionCreateManyBusinessInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutBusinessInput | SubscriptionUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutBusinessInput | SubscriptionUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<InventoryCreateWithoutBusinessInput, InventoryUncheckedCreateWithoutBusinessInput> | InventoryCreateWithoutBusinessInput[] | InventoryUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutBusinessInput | InventoryCreateOrConnectWithoutBusinessInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutBusinessInput | InventoryUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: InventoryCreateManyBusinessInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutBusinessInput | InventoryUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutBusinessInput | InventoryUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<OrderCreateWithoutBusinessInput, OrderUncheckedCreateWithoutBusinessInput> | OrderCreateWithoutBusinessInput[] | OrderUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBusinessInput | OrderCreateOrConnectWithoutBusinessInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutBusinessInput | OrderUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: OrderCreateManyBusinessInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutBusinessInput | OrderUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutBusinessInput | OrderUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type MenuItemUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<MenuItemCreateWithoutBusinessInput, MenuItemUncheckedCreateWithoutBusinessInput> | MenuItemCreateWithoutBusinessInput[] | MenuItemUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutBusinessInput | MenuItemCreateOrConnectWithoutBusinessInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutBusinessInput | MenuItemUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: MenuItemCreateManyBusinessInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutBusinessInput | MenuItemUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutBusinessInput | MenuItemUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutBusinessInput, ProductCategoryUncheckedCreateWithoutBusinessInput> | ProductCategoryCreateWithoutBusinessInput[] | ProductCategoryUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutBusinessInput | ProductCategoryCreateOrConnectWithoutBusinessInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutBusinessInput | ProductCategoryUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ProductCategoryCreateManyBusinessInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutBusinessInput | ProductCategoryUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutBusinessInput | ProductCategoryUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<PaymentCreateWithoutBusinessInput, PaymentUncheckedCreateWithoutBusinessInput> | PaymentCreateWithoutBusinessInput[] | PaymentUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBusinessInput | PaymentCreateOrConnectWithoutBusinessInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBusinessInput | PaymentUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: PaymentCreateManyBusinessInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBusinessInput | PaymentUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBusinessInput | PaymentUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RefundPolicyUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<RefundPolicyCreateWithoutBusinessInput, RefundPolicyUncheckedCreateWithoutBusinessInput> | RefundPolicyCreateWithoutBusinessInput[] | RefundPolicyUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RefundPolicyCreateOrConnectWithoutBusinessInput | RefundPolicyCreateOrConnectWithoutBusinessInput[]
    upsert?: RefundPolicyUpsertWithWhereUniqueWithoutBusinessInput | RefundPolicyUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: RefundPolicyCreateManyBusinessInputEnvelope
    set?: RefundPolicyWhereUniqueInput | RefundPolicyWhereUniqueInput[]
    disconnect?: RefundPolicyWhereUniqueInput | RefundPolicyWhereUniqueInput[]
    delete?: RefundPolicyWhereUniqueInput | RefundPolicyWhereUniqueInput[]
    connect?: RefundPolicyWhereUniqueInput | RefundPolicyWhereUniqueInput[]
    update?: RefundPolicyUpdateWithWhereUniqueWithoutBusinessInput | RefundPolicyUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: RefundPolicyUpdateManyWithWhereWithoutBusinessInput | RefundPolicyUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: RefundPolicyScalarWhereInput | RefundPolicyScalarWhereInput[]
  }

  export type RefundRequestUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<RefundRequestCreateWithoutBusinessInput, RefundRequestUncheckedCreateWithoutBusinessInput> | RefundRequestCreateWithoutBusinessInput[] | RefundRequestUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutBusinessInput | RefundRequestCreateOrConnectWithoutBusinessInput[]
    upsert?: RefundRequestUpsertWithWhereUniqueWithoutBusinessInput | RefundRequestUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: RefundRequestCreateManyBusinessInputEnvelope
    set?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    disconnect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    delete?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    update?: RefundRequestUpdateWithWhereUniqueWithoutBusinessInput | RefundRequestUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: RefundRequestUpdateManyWithWhereWithoutBusinessInput | RefundRequestUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: RefundRequestScalarWhereInput | RefundRequestScalarWhereInput[]
  }

  export type CancellationRequestUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<CancellationRequestCreateWithoutBusinessInput, CancellationRequestUncheckedCreateWithoutBusinessInput> | CancellationRequestCreateWithoutBusinessInput[] | CancellationRequestUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: CancellationRequestCreateOrConnectWithoutBusinessInput | CancellationRequestCreateOrConnectWithoutBusinessInput[]
    upsert?: CancellationRequestUpsertWithWhereUniqueWithoutBusinessInput | CancellationRequestUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: CancellationRequestCreateManyBusinessInputEnvelope
    set?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    disconnect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    delete?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    connect?: CancellationRequestWhereUniqueInput | CancellationRequestWhereUniqueInput[]
    update?: CancellationRequestUpdateWithWhereUniqueWithoutBusinessInput | CancellationRequestUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: CancellationRequestUpdateManyWithWhereWithoutBusinessInput | CancellationRequestUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: CancellationRequestScalarWhereInput | CancellationRequestScalarWhereInput[]
  }

  export type SubscriptionPlanUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutBusinessInput, SubscriptionPlanUncheckedCreateWithoutBusinessInput> | SubscriptionPlanCreateWithoutBusinessInput[] | SubscriptionPlanUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutBusinessInput | SubscriptionPlanCreateOrConnectWithoutBusinessInput[]
    upsert?: SubscriptionPlanUpsertWithWhereUniqueWithoutBusinessInput | SubscriptionPlanUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: SubscriptionPlanCreateManyBusinessInputEnvelope
    set?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    disconnect?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    delete?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    connect?: SubscriptionPlanWhereUniqueInput | SubscriptionPlanWhereUniqueInput[]
    update?: SubscriptionPlanUpdateWithWhereUniqueWithoutBusinessInput | SubscriptionPlanUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: SubscriptionPlanUpdateManyWithWhereWithoutBusinessInput | SubscriptionPlanUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: SubscriptionPlanScalarWhereInput | SubscriptionPlanScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<SubscriptionCreateWithoutBusinessInput, SubscriptionUncheckedCreateWithoutBusinessInput> | SubscriptionCreateWithoutBusinessInput[] | SubscriptionUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutBusinessInput | SubscriptionCreateOrConnectWithoutBusinessInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutBusinessInput | SubscriptionUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: SubscriptionCreateManyBusinessInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutBusinessInput | SubscriptionUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutBusinessInput | SubscriptionUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type BusinessCreateNestedManyWithoutZoneInput = {
    create?: XOR<BusinessCreateWithoutZoneInput, BusinessUncheckedCreateWithoutZoneInput> | BusinessCreateWithoutZoneInput[] | BusinessUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutZoneInput | BusinessCreateOrConnectWithoutZoneInput[]
    createMany?: BusinessCreateManyZoneInputEnvelope
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type CourierCreateNestedManyWithoutZoneInput = {
    create?: XOR<CourierCreateWithoutZoneInput, CourierUncheckedCreateWithoutZoneInput> | CourierCreateWithoutZoneInput[] | CourierUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: CourierCreateOrConnectWithoutZoneInput | CourierCreateOrConnectWithoutZoneInput[]
    createMany?: CourierCreateManyZoneInputEnvelope
    connect?: CourierWhereUniqueInput | CourierWhereUniqueInput[]
  }

  export type DeliveryCreateNestedManyWithoutZoneInput = {
    create?: XOR<DeliveryCreateWithoutZoneInput, DeliveryUncheckedCreateWithoutZoneInput> | DeliveryCreateWithoutZoneInput[] | DeliveryUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutZoneInput | DeliveryCreateOrConnectWithoutZoneInput[]
    createMany?: DeliveryCreateManyZoneInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type BusinessUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<BusinessCreateWithoutZoneInput, BusinessUncheckedCreateWithoutZoneInput> | BusinessCreateWithoutZoneInput[] | BusinessUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutZoneInput | BusinessCreateOrConnectWithoutZoneInput[]
    createMany?: BusinessCreateManyZoneInputEnvelope
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type CourierUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<CourierCreateWithoutZoneInput, CourierUncheckedCreateWithoutZoneInput> | CourierCreateWithoutZoneInput[] | CourierUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: CourierCreateOrConnectWithoutZoneInput | CourierCreateOrConnectWithoutZoneInput[]
    createMany?: CourierCreateManyZoneInputEnvelope
    connect?: CourierWhereUniqueInput | CourierWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<DeliveryCreateWithoutZoneInput, DeliveryUncheckedCreateWithoutZoneInput> | DeliveryCreateWithoutZoneInput[] | DeliveryUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutZoneInput | DeliveryCreateOrConnectWithoutZoneInput[]
    createMany?: DeliveryCreateManyZoneInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type BusinessUpdateManyWithoutZoneNestedInput = {
    create?: XOR<BusinessCreateWithoutZoneInput, BusinessUncheckedCreateWithoutZoneInput> | BusinessCreateWithoutZoneInput[] | BusinessUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutZoneInput | BusinessCreateOrConnectWithoutZoneInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutZoneInput | BusinessUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: BusinessCreateManyZoneInputEnvelope
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutZoneInput | BusinessUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutZoneInput | BusinessUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type CourierUpdateManyWithoutZoneNestedInput = {
    create?: XOR<CourierCreateWithoutZoneInput, CourierUncheckedCreateWithoutZoneInput> | CourierCreateWithoutZoneInput[] | CourierUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: CourierCreateOrConnectWithoutZoneInput | CourierCreateOrConnectWithoutZoneInput[]
    upsert?: CourierUpsertWithWhereUniqueWithoutZoneInput | CourierUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: CourierCreateManyZoneInputEnvelope
    set?: CourierWhereUniqueInput | CourierWhereUniqueInput[]
    disconnect?: CourierWhereUniqueInput | CourierWhereUniqueInput[]
    delete?: CourierWhereUniqueInput | CourierWhereUniqueInput[]
    connect?: CourierWhereUniqueInput | CourierWhereUniqueInput[]
    update?: CourierUpdateWithWhereUniqueWithoutZoneInput | CourierUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: CourierUpdateManyWithWhereWithoutZoneInput | CourierUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: CourierScalarWhereInput | CourierScalarWhereInput[]
  }

  export type DeliveryUpdateManyWithoutZoneNestedInput = {
    create?: XOR<DeliveryCreateWithoutZoneInput, DeliveryUncheckedCreateWithoutZoneInput> | DeliveryCreateWithoutZoneInput[] | DeliveryUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutZoneInput | DeliveryCreateOrConnectWithoutZoneInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutZoneInput | DeliveryUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: DeliveryCreateManyZoneInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutZoneInput | DeliveryUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutZoneInput | DeliveryUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type BusinessUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<BusinessCreateWithoutZoneInput, BusinessUncheckedCreateWithoutZoneInput> | BusinessCreateWithoutZoneInput[] | BusinessUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutZoneInput | BusinessCreateOrConnectWithoutZoneInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutZoneInput | BusinessUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: BusinessCreateManyZoneInputEnvelope
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutZoneInput | BusinessUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutZoneInput | BusinessUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type CourierUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<CourierCreateWithoutZoneInput, CourierUncheckedCreateWithoutZoneInput> | CourierCreateWithoutZoneInput[] | CourierUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: CourierCreateOrConnectWithoutZoneInput | CourierCreateOrConnectWithoutZoneInput[]
    upsert?: CourierUpsertWithWhereUniqueWithoutZoneInput | CourierUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: CourierCreateManyZoneInputEnvelope
    set?: CourierWhereUniqueInput | CourierWhereUniqueInput[]
    disconnect?: CourierWhereUniqueInput | CourierWhereUniqueInput[]
    delete?: CourierWhereUniqueInput | CourierWhereUniqueInput[]
    connect?: CourierWhereUniqueInput | CourierWhereUniqueInput[]
    update?: CourierUpdateWithWhereUniqueWithoutZoneInput | CourierUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: CourierUpdateManyWithWhereWithoutZoneInput | CourierUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: CourierScalarWhereInput | CourierScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<DeliveryCreateWithoutZoneInput, DeliveryUncheckedCreateWithoutZoneInput> | DeliveryCreateWithoutZoneInput[] | DeliveryUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutZoneInput | DeliveryCreateOrConnectWithoutZoneInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutZoneInput | DeliveryUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: DeliveryCreateManyZoneInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutZoneInput | DeliveryUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutZoneInput | DeliveryUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationPreferencesInput = {
    create?: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type CourierCreateNestedOneWithoutNotificationPreferencesInput = {
    create?: XOR<CourierCreateWithoutNotificationPreferencesInput, CourierUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: CourierCreateOrConnectWithoutNotificationPreferencesInput
    connect?: CourierWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationChannelFieldUpdateOperationsInput = {
    set?: $Enums.NotificationChannel
  }

  export type EnumNotificationFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.NotificationFrequency
  }

  export type UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferencesInput
    upsert?: UserUpsertWithoutNotificationPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationPreferencesInput, UserUpdateWithoutNotificationPreferencesInput>, UserUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type CourierUpdateOneWithoutNotificationPreferencesNestedInput = {
    create?: XOR<CourierCreateWithoutNotificationPreferencesInput, CourierUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: CourierCreateOrConnectWithoutNotificationPreferencesInput
    upsert?: CourierUpsertWithoutNotificationPreferencesInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutNotificationPreferencesInput, CourierUpdateWithoutNotificationPreferencesInput>, CourierUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type CourierCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CourierCreateWithoutNotificationsInput, CourierUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CourierCreateOrConnectWithoutNotificationsInput
    connect?: CourierWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<OrderCreateWithoutNotificationsInput, OrderUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutNotificationsInput
    connect?: OrderWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type CourierUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<CourierCreateWithoutNotificationsInput, CourierUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CourierCreateOrConnectWithoutNotificationsInput
    upsert?: CourierUpsertWithoutNotificationsInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutNotificationsInput, CourierUpdateWithoutNotificationsInput>, CourierUncheckedUpdateWithoutNotificationsInput>
  }

  export type OrderUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<OrderCreateWithoutNotificationsInput, OrderUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutNotificationsInput
    upsert?: OrderUpsertWithoutNotificationsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutNotificationsInput, OrderUpdateWithoutNotificationsInput>, OrderUncheckedUpdateWithoutNotificationsInput>
  }

  export type CourierCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<CourierCreateWithoutDeliveriesInput, CourierUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: CourierCreateOrConnectWithoutDeliveriesInput
    connect?: CourierWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<CustomerCreateWithoutDeliveriesInput, CustomerUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutDeliveriesInput
    connect?: CustomerWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<ZoneCreateWithoutDeliveriesInput, ZoneUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutDeliveriesInput
    connect?: ZoneWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutDeliveryInput = {
    create?: XOR<OrderCreateWithoutDeliveryInput, OrderUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryInput
    connect?: OrderWhereUniqueInput
  }

  export type DeliveryRouteCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<DeliveryRouteCreateWithoutDeliveriesInput, DeliveryRouteUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: DeliveryRouteCreateOrConnectWithoutDeliveriesInput
    connect?: DeliveryRouteWhereUniqueInput
  }

  export type CourierUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<CourierCreateWithoutDeliveriesInput, CourierUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: CourierCreateOrConnectWithoutDeliveriesInput
    upsert?: CourierUpsertWithoutDeliveriesInput
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutDeliveriesInput, CourierUpdateWithoutDeliveriesInput>, CourierUncheckedUpdateWithoutDeliveriesInput>
  }

  export type CustomerUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<CustomerCreateWithoutDeliveriesInput, CustomerUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutDeliveriesInput
    upsert?: CustomerUpsertWithoutDeliveriesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutDeliveriesInput, CustomerUpdateWithoutDeliveriesInput>, CustomerUncheckedUpdateWithoutDeliveriesInput>
  }

  export type ZoneUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<ZoneCreateWithoutDeliveriesInput, ZoneUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutDeliveriesInput
    upsert?: ZoneUpsertWithoutDeliveriesInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutDeliveriesInput, ZoneUpdateWithoutDeliveriesInput>, ZoneUncheckedUpdateWithoutDeliveriesInput>
  }

  export type OrderUpdateOneWithoutDeliveryNestedInput = {
    create?: XOR<OrderCreateWithoutDeliveryInput, OrderUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryInput
    upsert?: OrderUpsertWithoutDeliveryInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutDeliveryInput, OrderUpdateWithoutDeliveryInput>, OrderUncheckedUpdateWithoutDeliveryInput>
  }

  export type DeliveryRouteUpdateOneWithoutDeliveriesNestedInput = {
    create?: XOR<DeliveryRouteCreateWithoutDeliveriesInput, DeliveryRouteUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: DeliveryRouteCreateOrConnectWithoutDeliveriesInput
    upsert?: DeliveryRouteUpsertWithoutDeliveriesInput
    disconnect?: DeliveryRouteWhereInput | boolean
    delete?: DeliveryRouteWhereInput | boolean
    connect?: DeliveryRouteWhereUniqueInput
    update?: XOR<XOR<DeliveryRouteUpdateToOneWithWhereWithoutDeliveriesInput, DeliveryRouteUpdateWithoutDeliveriesInput>, DeliveryRouteUncheckedUpdateWithoutDeliveriesInput>
  }

  export type BusinessCreateNestedOneWithoutInventoryInput = {
    create?: XOR<BusinessCreateWithoutInventoryInput, BusinessUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutInventoryInput
    connect?: BusinessWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type BusinessUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<BusinessCreateWithoutInventoryInput, BusinessUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutInventoryInput
    upsert?: BusinessUpsertWithoutInventoryInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutInventoryInput, BusinessUpdateWithoutInventoryInput>, BusinessUncheckedUpdateWithoutInventoryInput>
  }

  export type ProductCategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    upsert?: ProductCategoryUpsertWithoutProductsInput
    disconnect?: ProductCategoryWhereInput | boolean
    delete?: ProductCategoryWhereInput | boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutProductsInput, ProductCategoryUpdateWithoutProductsInput>, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CourierCreateNestedOneWithoutDeliveryLogsInput = {
    create?: XOR<CourierCreateWithoutDeliveryLogsInput, CourierUncheckedCreateWithoutDeliveryLogsInput>
    connectOrCreate?: CourierCreateOrConnectWithoutDeliveryLogsInput
    connect?: CourierWhereUniqueInput
  }

  export type CourierUpdateOneRequiredWithoutDeliveryLogsNestedInput = {
    create?: XOR<CourierCreateWithoutDeliveryLogsInput, CourierUncheckedCreateWithoutDeliveryLogsInput>
    connectOrCreate?: CourierCreateOrConnectWithoutDeliveryLogsInput
    upsert?: CourierUpsertWithoutDeliveryLogsInput
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutDeliveryLogsInput, CourierUpdateWithoutDeliveryLogsInput>, CourierUncheckedUpdateWithoutDeliveryLogsInput>
  }

  export type UserCreateNestedOneWithoutReportsInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReportTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReportType
  }

  export type EnumReportFormatFieldUpdateOperationsInput = {
    set?: $Enums.ReportFormat
  }

  export type UserUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    upsert?: UserUpsertWithoutReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsInput, UserUpdateWithoutReportsInput>, UserUncheckedUpdateWithoutReportsInput>
  }

  export type ScheduledReportCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ScheduledReportCreateWithoutScheduleInput, ScheduledReportUncheckedCreateWithoutScheduleInput> | ScheduledReportCreateWithoutScheduleInput[] | ScheduledReportUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutScheduleInput | ScheduledReportCreateOrConnectWithoutScheduleInput[]
    createMany?: ScheduledReportCreateManyScheduleInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type ScheduledReportUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ScheduledReportCreateWithoutScheduleInput, ScheduledReportUncheckedCreateWithoutScheduleInput> | ScheduledReportCreateWithoutScheduleInput[] | ScheduledReportUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutScheduleInput | ScheduledReportCreateOrConnectWithoutScheduleInput[]
    createMany?: ScheduledReportCreateManyScheduleInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type ScheduledReportUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutScheduleInput, ScheduledReportUncheckedCreateWithoutScheduleInput> | ScheduledReportCreateWithoutScheduleInput[] | ScheduledReportUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutScheduleInput | ScheduledReportCreateOrConnectWithoutScheduleInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutScheduleInput | ScheduledReportUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ScheduledReportCreateManyScheduleInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutScheduleInput | ScheduledReportUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutScheduleInput | ScheduledReportUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type ScheduledReportUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutScheduleInput, ScheduledReportUncheckedCreateWithoutScheduleInput> | ScheduledReportCreateWithoutScheduleInput[] | ScheduledReportUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutScheduleInput | ScheduledReportCreateOrConnectWithoutScheduleInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutScheduleInput | ScheduledReportUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ScheduledReportCreateManyScheduleInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutScheduleInput | ScheduledReportUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutScheduleInput | ScheduledReportUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type ScheduledReportCreaterecipientsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutScheduledReportsInput = {
    create?: XOR<UserCreateWithoutScheduledReportsInput, UserUncheckedCreateWithoutScheduledReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduledReportsInput
    connect?: UserWhereUniqueInput
  }

  export type ScheduleCreateNestedOneWithoutReportsInput = {
    create?: XOR<ScheduleCreateWithoutReportsInput, ScheduleUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutReportsInput
    connect?: ScheduleWhereUniqueInput
  }

  export type ScheduledReportUpdaterecipientsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutScheduledReportsNestedInput = {
    create?: XOR<UserCreateWithoutScheduledReportsInput, UserUncheckedCreateWithoutScheduledReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduledReportsInput
    upsert?: UserUpsertWithoutScheduledReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScheduledReportsInput, UserUpdateWithoutScheduledReportsInput>, UserUncheckedUpdateWithoutScheduledReportsInput>
  }

  export type ScheduleUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<ScheduleCreateWithoutReportsInput, ScheduleUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutReportsInput
    upsert?: ScheduleUpsertWithoutReportsInput
    connect?: ScheduleWhereUniqueInput
    update?: XOR<XOR<ScheduleUpdateToOneWithWhereWithoutReportsInput, ScheduleUpdateWithoutReportsInput>, ScheduleUncheckedUpdateWithoutReportsInput>
  }

  export type UserCreateNestedOneWithoutSettingsInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    upsert?: UserUpsertWithoutSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingsInput, UserUpdateWithoutSettingsInput>, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type MenuItemCreatetagsInput = {
    set: string[]
  }

  export type MenuItemCreateingredientsInput = {
    set: string[]
  }

  export type BusinessCreateNestedOneWithoutMenuItemsInput = {
    create?: XOR<BusinessCreateWithoutMenuItemsInput, BusinessUncheckedCreateWithoutMenuItemsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutMenuItemsInput
    connect?: BusinessWhereUniqueInput
  }

  export type MenuItemUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MenuItemUpdateingredientsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BusinessUpdateOneRequiredWithoutMenuItemsNestedInput = {
    create?: XOR<BusinessCreateWithoutMenuItemsInput, BusinessUncheckedCreateWithoutMenuItemsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutMenuItemsInput
    upsert?: BusinessUpsertWithoutMenuItemsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutMenuItemsInput, BusinessUpdateWithoutMenuItemsInput>, BusinessUncheckedUpdateWithoutMenuItemsInput>
  }

  export type CourierCreateNestedOneWithoutAvailabilityInput = {
    create?: XOR<CourierCreateWithoutAvailabilityInput, CourierUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: CourierCreateOrConnectWithoutAvailabilityInput
    connect?: CourierWhereUniqueInput
  }

  export type EnumCourierAvailabilityStatusFieldUpdateOperationsInput = {
    set?: $Enums.CourierAvailabilityStatus
  }

  export type CourierUpdateOneRequiredWithoutAvailabilityNestedInput = {
    create?: XOR<CourierCreateWithoutAvailabilityInput, CourierUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: CourierCreateOrConnectWithoutAvailabilityInput
    upsert?: CourierUpsertWithoutAvailabilityInput
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutAvailabilityInput, CourierUpdateWithoutAvailabilityInput>, CourierUncheckedUpdateWithoutAvailabilityInput>
  }

  export type OrderCreateNestedManyWithoutRequestedTimeWindowInput = {
    create?: XOR<OrderCreateWithoutRequestedTimeWindowInput, OrderUncheckedCreateWithoutRequestedTimeWindowInput> | OrderCreateWithoutRequestedTimeWindowInput[] | OrderUncheckedCreateWithoutRequestedTimeWindowInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutRequestedTimeWindowInput | OrderCreateOrConnectWithoutRequestedTimeWindowInput[]
    createMany?: OrderCreateManyRequestedTimeWindowInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutRequestedTimeWindowInput = {
    create?: XOR<OrderCreateWithoutRequestedTimeWindowInput, OrderUncheckedCreateWithoutRequestedTimeWindowInput> | OrderCreateWithoutRequestedTimeWindowInput[] | OrderUncheckedCreateWithoutRequestedTimeWindowInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutRequestedTimeWindowInput | OrderCreateOrConnectWithoutRequestedTimeWindowInput[]
    createMany?: OrderCreateManyRequestedTimeWindowInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutRequestedTimeWindowNestedInput = {
    create?: XOR<OrderCreateWithoutRequestedTimeWindowInput, OrderUncheckedCreateWithoutRequestedTimeWindowInput> | OrderCreateWithoutRequestedTimeWindowInput[] | OrderUncheckedCreateWithoutRequestedTimeWindowInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutRequestedTimeWindowInput | OrderCreateOrConnectWithoutRequestedTimeWindowInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutRequestedTimeWindowInput | OrderUpsertWithWhereUniqueWithoutRequestedTimeWindowInput[]
    createMany?: OrderCreateManyRequestedTimeWindowInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutRequestedTimeWindowInput | OrderUpdateWithWhereUniqueWithoutRequestedTimeWindowInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutRequestedTimeWindowInput | OrderUpdateManyWithWhereWithoutRequestedTimeWindowInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutRequestedTimeWindowNestedInput = {
    create?: XOR<OrderCreateWithoutRequestedTimeWindowInput, OrderUncheckedCreateWithoutRequestedTimeWindowInput> | OrderCreateWithoutRequestedTimeWindowInput[] | OrderUncheckedCreateWithoutRequestedTimeWindowInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutRequestedTimeWindowInput | OrderCreateOrConnectWithoutRequestedTimeWindowInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutRequestedTimeWindowInput | OrderUpsertWithWhereUniqueWithoutRequestedTimeWindowInput[]
    createMany?: OrderCreateManyRequestedTimeWindowInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutRequestedTimeWindowInput | OrderUpdateWithWhereUniqueWithoutRequestedTimeWindowInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutRequestedTimeWindowInput | OrderUpdateManyWithWhereWithoutRequestedTimeWindowInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CourierCreateNestedOneWithoutDeliveryRoutesInput = {
    create?: XOR<CourierCreateWithoutDeliveryRoutesInput, CourierUncheckedCreateWithoutDeliveryRoutesInput>
    connectOrCreate?: CourierCreateOrConnectWithoutDeliveryRoutesInput
    connect?: CourierWhereUniqueInput
  }

  export type DeliveryCreateNestedManyWithoutRouteInput = {
    create?: XOR<DeliveryCreateWithoutRouteInput, DeliveryUncheckedCreateWithoutRouteInput> | DeliveryCreateWithoutRouteInput[] | DeliveryUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutRouteInput | DeliveryCreateOrConnectWithoutRouteInput[]
    createMany?: DeliveryCreateManyRouteInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<DeliveryCreateWithoutRouteInput, DeliveryUncheckedCreateWithoutRouteInput> | DeliveryCreateWithoutRouteInput[] | DeliveryUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutRouteInput | DeliveryCreateOrConnectWithoutRouteInput[]
    createMany?: DeliveryCreateManyRouteInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type CourierUpdateOneRequiredWithoutDeliveryRoutesNestedInput = {
    create?: XOR<CourierCreateWithoutDeliveryRoutesInput, CourierUncheckedCreateWithoutDeliveryRoutesInput>
    connectOrCreate?: CourierCreateOrConnectWithoutDeliveryRoutesInput
    upsert?: CourierUpsertWithoutDeliveryRoutesInput
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutDeliveryRoutesInput, CourierUpdateWithoutDeliveryRoutesInput>, CourierUncheckedUpdateWithoutDeliveryRoutesInput>
  }

  export type DeliveryUpdateManyWithoutRouteNestedInput = {
    create?: XOR<DeliveryCreateWithoutRouteInput, DeliveryUncheckedCreateWithoutRouteInput> | DeliveryCreateWithoutRouteInput[] | DeliveryUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutRouteInput | DeliveryCreateOrConnectWithoutRouteInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutRouteInput | DeliveryUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: DeliveryCreateManyRouteInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutRouteInput | DeliveryUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutRouteInput | DeliveryUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<DeliveryCreateWithoutRouteInput, DeliveryUncheckedCreateWithoutRouteInput> | DeliveryCreateWithoutRouteInput[] | DeliveryUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutRouteInput | DeliveryCreateOrConnectWithoutRouteInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutRouteInput | DeliveryUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: DeliveryCreateManyRouteInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutRouteInput | DeliveryUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutRouteInput | DeliveryUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
  }

  export type CourierCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CourierCreateWithoutPaymentsInput, CourierUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CourierCreateOrConnectWithoutPaymentsInput
    connect?: CourierWhereUniqueInput
  }

  export type BusinessCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BusinessCreateWithoutPaymentsInput, BusinessUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutPaymentsInput
    connect?: BusinessWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type OrderUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    upsert?: OrderUpsertWithoutPaymentsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentsInput, OrderUpdateWithoutPaymentsInput>, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type CourierUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<CourierCreateWithoutPaymentsInput, CourierUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CourierCreateOrConnectWithoutPaymentsInput
    upsert?: CourierUpsertWithoutPaymentsInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutPaymentsInput, CourierUpdateWithoutPaymentsInput>, CourierUncheckedUpdateWithoutPaymentsInput>
  }

  export type BusinessUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<BusinessCreateWithoutPaymentsInput, BusinessUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutPaymentsInput
    upsert?: BusinessUpsertWithoutPaymentsInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutPaymentsInput, BusinessUpdateWithoutPaymentsInput>, BusinessUncheckedUpdateWithoutPaymentsInput>
  }

  export type BusinessCreateNestedOneWithoutProductCategoriesInput = {
    create?: XOR<BusinessCreateWithoutProductCategoriesInput, BusinessUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutProductCategoriesInput
    connect?: BusinessWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutChildrenInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductCategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<InventoryCreateWithoutCategoryInput, InventoryUncheckedCreateWithoutCategoryInput> | InventoryCreateWithoutCategoryInput[] | InventoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCategoryInput | InventoryCreateOrConnectWithoutCategoryInput[]
    createMany?: InventoryCreateManyCategoryInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<InventoryCreateWithoutCategoryInput, InventoryUncheckedCreateWithoutCategoryInput> | InventoryCreateWithoutCategoryInput[] | InventoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCategoryInput | InventoryCreateOrConnectWithoutCategoryInput[]
    createMany?: InventoryCreateManyCategoryInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type BusinessUpdateOneRequiredWithoutProductCategoriesNestedInput = {
    create?: XOR<BusinessCreateWithoutProductCategoriesInput, BusinessUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutProductCategoriesInput
    upsert?: BusinessUpsertWithoutProductCategoriesInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutProductCategoriesInput, BusinessUpdateWithoutProductCategoriesInput>, BusinessUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type ProductCategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutChildrenInput
    upsert?: ProductCategoryUpsertWithoutChildrenInput
    disconnect?: ProductCategoryWhereInput | boolean
    delete?: ProductCategoryWhereInput | boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutChildrenInput, ProductCategoryUpdateWithoutChildrenInput>, ProductCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type ProductCategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutParentInput | ProductCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutParentInput | ProductCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutParentInput | ProductCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<InventoryCreateWithoutCategoryInput, InventoryUncheckedCreateWithoutCategoryInput> | InventoryCreateWithoutCategoryInput[] | InventoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCategoryInput | InventoryCreateOrConnectWithoutCategoryInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutCategoryInput | InventoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: InventoryCreateManyCategoryInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutCategoryInput | InventoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutCategoryInput | InventoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutParentInput | ProductCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutParentInput | ProductCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutParentInput | ProductCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<InventoryCreateWithoutCategoryInput, InventoryUncheckedCreateWithoutCategoryInput> | InventoryCreateWithoutCategoryInput[] | InventoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCategoryInput | InventoryCreateOrConnectWithoutCategoryInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutCategoryInput | InventoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: InventoryCreateManyCategoryInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutCategoryInput | InventoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutCategoryInput | InventoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<AdminCreateWithoutActivityLogsInput, AdminUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutActivityLogsInput
    connect?: AdminWhereUniqueInput
  }

  export type UserUpdateOneWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type AdminUpdateOneWithoutActivityLogsNestedInput = {
    create?: XOR<AdminCreateWithoutActivityLogsInput, AdminUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutActivityLogsInput
    upsert?: AdminUpsertWithoutActivityLogsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutActivityLogsInput, AdminUpdateWithoutActivityLogsInput>, AdminUncheckedUpdateWithoutActivityLogsInput>
  }

  export type AdminCreateNestedOneWithoutSystemActionsInput = {
    create?: XOR<AdminCreateWithoutSystemActionsInput, AdminUncheckedCreateWithoutSystemActionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSystemActionsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneWithoutSystemActionsNestedInput = {
    create?: XOR<AdminCreateWithoutSystemActionsInput, AdminUncheckedCreateWithoutSystemActionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSystemActionsInput
    upsert?: AdminUpsertWithoutSystemActionsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutSystemActionsInput, AdminUpdateWithoutSystemActionsInput>, AdminUncheckedUpdateWithoutSystemActionsInput>
  }

  export type AdminCreateNestedOneWithoutDashboardWidgetsInput = {
    create?: XOR<AdminCreateWithoutDashboardWidgetsInput, AdminUncheckedCreateWithoutDashboardWidgetsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutDashboardWidgetsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutDashboardWidgetsNestedInput = {
    create?: XOR<AdminCreateWithoutDashboardWidgetsInput, AdminUncheckedCreateWithoutDashboardWidgetsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutDashboardWidgetsInput
    upsert?: AdminUpsertWithoutDashboardWidgetsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutDashboardWidgetsInput, AdminUpdateWithoutDashboardWidgetsInput>, AdminUncheckedUpdateWithoutDashboardWidgetsInput>
  }

  export type AdminRoleCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<AdminRoleCreateWithoutPermissionsInput, AdminRoleUncheckedCreateWithoutPermissionsInput> | AdminRoleCreateWithoutPermissionsInput[] | AdminRoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: AdminRoleCreateOrConnectWithoutPermissionsInput | AdminRoleCreateOrConnectWithoutPermissionsInput[]
    connect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
  }

  export type AdminRoleUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<AdminRoleCreateWithoutPermissionsInput, AdminRoleUncheckedCreateWithoutPermissionsInput> | AdminRoleCreateWithoutPermissionsInput[] | AdminRoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: AdminRoleCreateOrConnectWithoutPermissionsInput | AdminRoleCreateOrConnectWithoutPermissionsInput[]
    connect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
  }

  export type AdminRoleUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<AdminRoleCreateWithoutPermissionsInput, AdminRoleUncheckedCreateWithoutPermissionsInput> | AdminRoleCreateWithoutPermissionsInput[] | AdminRoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: AdminRoleCreateOrConnectWithoutPermissionsInput | AdminRoleCreateOrConnectWithoutPermissionsInput[]
    upsert?: AdminRoleUpsertWithWhereUniqueWithoutPermissionsInput | AdminRoleUpsertWithWhereUniqueWithoutPermissionsInput[]
    set?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    disconnect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    delete?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    connect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    update?: AdminRoleUpdateWithWhereUniqueWithoutPermissionsInput | AdminRoleUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: AdminRoleUpdateManyWithWhereWithoutPermissionsInput | AdminRoleUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: AdminRoleScalarWhereInput | AdminRoleScalarWhereInput[]
  }

  export type AdminRoleUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<AdminRoleCreateWithoutPermissionsInput, AdminRoleUncheckedCreateWithoutPermissionsInput> | AdminRoleCreateWithoutPermissionsInput[] | AdminRoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: AdminRoleCreateOrConnectWithoutPermissionsInput | AdminRoleCreateOrConnectWithoutPermissionsInput[]
    upsert?: AdminRoleUpsertWithWhereUniqueWithoutPermissionsInput | AdminRoleUpsertWithWhereUniqueWithoutPermissionsInput[]
    set?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    disconnect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    delete?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    connect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    update?: AdminRoleUpdateWithWhereUniqueWithoutPermissionsInput | AdminRoleUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: AdminRoleUpdateManyWithWhereWithoutPermissionsInput | AdminRoleUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: AdminRoleScalarWhereInput | AdminRoleScalarWhereInput[]
  }

  export type AdminPermissionCreateNestedManyWithoutAdminRolesInput = {
    create?: XOR<AdminPermissionCreateWithoutAdminRolesInput, AdminPermissionUncheckedCreateWithoutAdminRolesInput> | AdminPermissionCreateWithoutAdminRolesInput[] | AdminPermissionUncheckedCreateWithoutAdminRolesInput[]
    connectOrCreate?: AdminPermissionCreateOrConnectWithoutAdminRolesInput | AdminPermissionCreateOrConnectWithoutAdminRolesInput[]
    connect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
  }

  export type AdminRoleMappingCreateNestedManyWithoutRoleInput = {
    create?: XOR<AdminRoleMappingCreateWithoutRoleInput, AdminRoleMappingUncheckedCreateWithoutRoleInput> | AdminRoleMappingCreateWithoutRoleInput[] | AdminRoleMappingUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AdminRoleMappingCreateOrConnectWithoutRoleInput | AdminRoleMappingCreateOrConnectWithoutRoleInput[]
    createMany?: AdminRoleMappingCreateManyRoleInputEnvelope
    connect?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
  }

  export type AdminPermissionUncheckedCreateNestedManyWithoutAdminRolesInput = {
    create?: XOR<AdminPermissionCreateWithoutAdminRolesInput, AdminPermissionUncheckedCreateWithoutAdminRolesInput> | AdminPermissionCreateWithoutAdminRolesInput[] | AdminPermissionUncheckedCreateWithoutAdminRolesInput[]
    connectOrCreate?: AdminPermissionCreateOrConnectWithoutAdminRolesInput | AdminPermissionCreateOrConnectWithoutAdminRolesInput[]
    connect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
  }

  export type AdminRoleMappingUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<AdminRoleMappingCreateWithoutRoleInput, AdminRoleMappingUncheckedCreateWithoutRoleInput> | AdminRoleMappingCreateWithoutRoleInput[] | AdminRoleMappingUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AdminRoleMappingCreateOrConnectWithoutRoleInput | AdminRoleMappingCreateOrConnectWithoutRoleInput[]
    createMany?: AdminRoleMappingCreateManyRoleInputEnvelope
    connect?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
  }

  export type AdminPermissionUpdateManyWithoutAdminRolesNestedInput = {
    create?: XOR<AdminPermissionCreateWithoutAdminRolesInput, AdminPermissionUncheckedCreateWithoutAdminRolesInput> | AdminPermissionCreateWithoutAdminRolesInput[] | AdminPermissionUncheckedCreateWithoutAdminRolesInput[]
    connectOrCreate?: AdminPermissionCreateOrConnectWithoutAdminRolesInput | AdminPermissionCreateOrConnectWithoutAdminRolesInput[]
    upsert?: AdminPermissionUpsertWithWhereUniqueWithoutAdminRolesInput | AdminPermissionUpsertWithWhereUniqueWithoutAdminRolesInput[]
    set?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    disconnect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    delete?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    connect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    update?: AdminPermissionUpdateWithWhereUniqueWithoutAdminRolesInput | AdminPermissionUpdateWithWhereUniqueWithoutAdminRolesInput[]
    updateMany?: AdminPermissionUpdateManyWithWhereWithoutAdminRolesInput | AdminPermissionUpdateManyWithWhereWithoutAdminRolesInput[]
    deleteMany?: AdminPermissionScalarWhereInput | AdminPermissionScalarWhereInput[]
  }

  export type AdminRoleMappingUpdateManyWithoutRoleNestedInput = {
    create?: XOR<AdminRoleMappingCreateWithoutRoleInput, AdminRoleMappingUncheckedCreateWithoutRoleInput> | AdminRoleMappingCreateWithoutRoleInput[] | AdminRoleMappingUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AdminRoleMappingCreateOrConnectWithoutRoleInput | AdminRoleMappingCreateOrConnectWithoutRoleInput[]
    upsert?: AdminRoleMappingUpsertWithWhereUniqueWithoutRoleInput | AdminRoleMappingUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: AdminRoleMappingCreateManyRoleInputEnvelope
    set?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    disconnect?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    delete?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    connect?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    update?: AdminRoleMappingUpdateWithWhereUniqueWithoutRoleInput | AdminRoleMappingUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: AdminRoleMappingUpdateManyWithWhereWithoutRoleInput | AdminRoleMappingUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: AdminRoleMappingScalarWhereInput | AdminRoleMappingScalarWhereInput[]
  }

  export type AdminPermissionUncheckedUpdateManyWithoutAdminRolesNestedInput = {
    create?: XOR<AdminPermissionCreateWithoutAdminRolesInput, AdminPermissionUncheckedCreateWithoutAdminRolesInput> | AdminPermissionCreateWithoutAdminRolesInput[] | AdminPermissionUncheckedCreateWithoutAdminRolesInput[]
    connectOrCreate?: AdminPermissionCreateOrConnectWithoutAdminRolesInput | AdminPermissionCreateOrConnectWithoutAdminRolesInput[]
    upsert?: AdminPermissionUpsertWithWhereUniqueWithoutAdminRolesInput | AdminPermissionUpsertWithWhereUniqueWithoutAdminRolesInput[]
    set?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    disconnect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    delete?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    connect?: AdminPermissionWhereUniqueInput | AdminPermissionWhereUniqueInput[]
    update?: AdminPermissionUpdateWithWhereUniqueWithoutAdminRolesInput | AdminPermissionUpdateWithWhereUniqueWithoutAdminRolesInput[]
    updateMany?: AdminPermissionUpdateManyWithWhereWithoutAdminRolesInput | AdminPermissionUpdateManyWithWhereWithoutAdminRolesInput[]
    deleteMany?: AdminPermissionScalarWhereInput | AdminPermissionScalarWhereInput[]
  }

  export type AdminRoleMappingUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<AdminRoleMappingCreateWithoutRoleInput, AdminRoleMappingUncheckedCreateWithoutRoleInput> | AdminRoleMappingCreateWithoutRoleInput[] | AdminRoleMappingUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AdminRoleMappingCreateOrConnectWithoutRoleInput | AdminRoleMappingCreateOrConnectWithoutRoleInput[]
    upsert?: AdminRoleMappingUpsertWithWhereUniqueWithoutRoleInput | AdminRoleMappingUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: AdminRoleMappingCreateManyRoleInputEnvelope
    set?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    disconnect?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    delete?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    connect?: AdminRoleMappingWhereUniqueInput | AdminRoleMappingWhereUniqueInput[]
    update?: AdminRoleMappingUpdateWithWhereUniqueWithoutRoleInput | AdminRoleMappingUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: AdminRoleMappingUpdateManyWithWhereWithoutRoleInput | AdminRoleMappingUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: AdminRoleMappingScalarWhereInput | AdminRoleMappingScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutRoleMappingsInput = {
    create?: XOR<AdminCreateWithoutRoleMappingsInput, AdminUncheckedCreateWithoutRoleMappingsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutRoleMappingsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminRoleCreateNestedOneWithoutAdminsInput = {
    create?: XOR<AdminRoleCreateWithoutAdminsInput, AdminRoleUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: AdminRoleCreateOrConnectWithoutAdminsInput
    connect?: AdminRoleWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutRoleMappingsNestedInput = {
    create?: XOR<AdminCreateWithoutRoleMappingsInput, AdminUncheckedCreateWithoutRoleMappingsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutRoleMappingsInput
    upsert?: AdminUpsertWithoutRoleMappingsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutRoleMappingsInput, AdminUpdateWithoutRoleMappingsInput>, AdminUncheckedUpdateWithoutRoleMappingsInput>
  }

  export type AdminRoleUpdateOneRequiredWithoutAdminsNestedInput = {
    create?: XOR<AdminRoleCreateWithoutAdminsInput, AdminRoleUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: AdminRoleCreateOrConnectWithoutAdminsInput
    upsert?: AdminRoleUpsertWithoutAdminsInput
    connect?: AdminRoleWhereUniqueInput
    update?: XOR<XOR<AdminRoleUpdateToOneWithWhereWithoutAdminsInput, AdminRoleUpdateWithoutAdminsInput>, AdminRoleUncheckedUpdateWithoutAdminsInput>
  }

  export type SentEmailCreateNestedManyWithoutTemplateInput = {
    create?: XOR<SentEmailCreateWithoutTemplateInput, SentEmailUncheckedCreateWithoutTemplateInput> | SentEmailCreateWithoutTemplateInput[] | SentEmailUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutTemplateInput | SentEmailCreateOrConnectWithoutTemplateInput[]
    createMany?: SentEmailCreateManyTemplateInputEnvelope
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
  }

  export type SentEmailUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<SentEmailCreateWithoutTemplateInput, SentEmailUncheckedCreateWithoutTemplateInput> | SentEmailCreateWithoutTemplateInput[] | SentEmailUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutTemplateInput | SentEmailCreateOrConnectWithoutTemplateInput[]
    createMany?: SentEmailCreateManyTemplateInputEnvelope
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
  }

  export type SentEmailUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<SentEmailCreateWithoutTemplateInput, SentEmailUncheckedCreateWithoutTemplateInput> | SentEmailCreateWithoutTemplateInput[] | SentEmailUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutTemplateInput | SentEmailCreateOrConnectWithoutTemplateInput[]
    upsert?: SentEmailUpsertWithWhereUniqueWithoutTemplateInput | SentEmailUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: SentEmailCreateManyTemplateInputEnvelope
    set?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    disconnect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    delete?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    update?: SentEmailUpdateWithWhereUniqueWithoutTemplateInput | SentEmailUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: SentEmailUpdateManyWithWhereWithoutTemplateInput | SentEmailUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
  }

  export type SentEmailUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<SentEmailCreateWithoutTemplateInput, SentEmailUncheckedCreateWithoutTemplateInput> | SentEmailCreateWithoutTemplateInput[] | SentEmailUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: SentEmailCreateOrConnectWithoutTemplateInput | SentEmailCreateOrConnectWithoutTemplateInput[]
    upsert?: SentEmailUpsertWithWhereUniqueWithoutTemplateInput | SentEmailUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: SentEmailCreateManyTemplateInputEnvelope
    set?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    disconnect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    delete?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    connect?: SentEmailWhereUniqueInput | SentEmailWhereUniqueInput[]
    update?: SentEmailUpdateWithWhereUniqueWithoutTemplateInput | SentEmailUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: SentEmailUpdateManyWithWhereWithoutTemplateInput | SentEmailUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
  }

  export type EmailTemplateCreateNestedOneWithoutSentEmailsInput = {
    create?: XOR<EmailTemplateCreateWithoutSentEmailsInput, EmailTemplateUncheckedCreateWithoutSentEmailsInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutSentEmailsInput
    connect?: EmailTemplateWhereUniqueInput
  }

  export type EmailTemplateUpdateOneRequiredWithoutSentEmailsNestedInput = {
    create?: XOR<EmailTemplateCreateWithoutSentEmailsInput, EmailTemplateUncheckedCreateWithoutSentEmailsInput>
    connectOrCreate?: EmailTemplateCreateOrConnectWithoutSentEmailsInput
    upsert?: EmailTemplateUpsertWithoutSentEmailsInput
    connect?: EmailTemplateWhereUniqueInput
    update?: XOR<XOR<EmailTemplateUpdateToOneWithWhereWithoutSentEmailsInput, EmailTemplateUpdateWithoutSentEmailsInput>, EmailTemplateUncheckedUpdateWithoutSentEmailsInput>
  }

  export type CustomerCreateNestedOneWithoutAddressesInput = {
    create?: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressesInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressesInput
    upsert?: CustomerUpsertWithoutAddressesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutAddressesInput, CustomerUpdateWithoutAddressesInput>, CustomerUncheckedUpdateWithoutAddressesInput>
  }

  export type RefundRequestCreateevidenceUrlsInput = {
    set: string[]
  }

  export type OrderCreateNestedOneWithoutRefundRequestsInput = {
    create?: XOR<OrderCreateWithoutRefundRequestsInput, OrderUncheckedCreateWithoutRefundRequestsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutRefundRequestsInput
    connect?: OrderWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutRefundRequestsInput = {
    create?: XOR<CustomerCreateWithoutRefundRequestsInput, CustomerUncheckedCreateWithoutRefundRequestsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutRefundRequestsInput
    connect?: CustomerWhereUniqueInput
  }

  export type BusinessCreateNestedOneWithoutRefundRequestsInput = {
    create?: XOR<BusinessCreateWithoutRefundRequestsInput, BusinessUncheckedCreateWithoutRefundRequestsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutRefundRequestsInput
    connect?: BusinessWhereUniqueInput
  }

  export type EnumRefundRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.RefundRequestStatus
  }

  export type EnumRefundReasonFieldUpdateOperationsInput = {
    set?: $Enums.RefundReason
  }

  export type RefundRequestUpdateevidenceUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrderUpdateOneRequiredWithoutRefundRequestsNestedInput = {
    create?: XOR<OrderCreateWithoutRefundRequestsInput, OrderUncheckedCreateWithoutRefundRequestsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutRefundRequestsInput
    upsert?: OrderUpsertWithoutRefundRequestsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutRefundRequestsInput, OrderUpdateWithoutRefundRequestsInput>, OrderUncheckedUpdateWithoutRefundRequestsInput>
  }

  export type CustomerUpdateOneRequiredWithoutRefundRequestsNestedInput = {
    create?: XOR<CustomerCreateWithoutRefundRequestsInput, CustomerUncheckedCreateWithoutRefundRequestsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutRefundRequestsInput
    upsert?: CustomerUpsertWithoutRefundRequestsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutRefundRequestsInput, CustomerUpdateWithoutRefundRequestsInput>, CustomerUncheckedUpdateWithoutRefundRequestsInput>
  }

  export type BusinessUpdateOneRequiredWithoutRefundRequestsNestedInput = {
    create?: XOR<BusinessCreateWithoutRefundRequestsInput, BusinessUncheckedCreateWithoutRefundRequestsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutRefundRequestsInput
    upsert?: BusinessUpsertWithoutRefundRequestsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutRefundRequestsInput, BusinessUpdateWithoutRefundRequestsInput>, BusinessUncheckedUpdateWithoutRefundRequestsInput>
  }

  export type OrderCreateNestedOneWithoutCancellationRequestsInput = {
    create?: XOR<OrderCreateWithoutCancellationRequestsInput, OrderUncheckedCreateWithoutCancellationRequestsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCancellationRequestsInput
    connect?: OrderWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutCancellationRequestsInput = {
    create?: XOR<CustomerCreateWithoutCancellationRequestsInput, CustomerUncheckedCreateWithoutCancellationRequestsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCancellationRequestsInput
    connect?: CustomerWhereUniqueInput
  }

  export type BusinessCreateNestedOneWithoutCancellationRequestsInput = {
    create?: XOR<BusinessCreateWithoutCancellationRequestsInput, BusinessUncheckedCreateWithoutCancellationRequestsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutCancellationRequestsInput
    connect?: BusinessWhereUniqueInput
  }

  export type EnumCancellationRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.CancellationRequestStatus
  }

  export type EnumCancellationReasonFieldUpdateOperationsInput = {
    set?: $Enums.CancellationReason
  }

  export type OrderUpdateOneRequiredWithoutCancellationRequestsNestedInput = {
    create?: XOR<OrderCreateWithoutCancellationRequestsInput, OrderUncheckedCreateWithoutCancellationRequestsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCancellationRequestsInput
    upsert?: OrderUpsertWithoutCancellationRequestsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutCancellationRequestsInput, OrderUpdateWithoutCancellationRequestsInput>, OrderUncheckedUpdateWithoutCancellationRequestsInput>
  }

  export type CustomerUpdateOneRequiredWithoutCancellationRequestsNestedInput = {
    create?: XOR<CustomerCreateWithoutCancellationRequestsInput, CustomerUncheckedCreateWithoutCancellationRequestsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCancellationRequestsInput
    upsert?: CustomerUpsertWithoutCancellationRequestsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCancellationRequestsInput, CustomerUpdateWithoutCancellationRequestsInput>, CustomerUncheckedUpdateWithoutCancellationRequestsInput>
  }

  export type BusinessUpdateOneRequiredWithoutCancellationRequestsNestedInput = {
    create?: XOR<BusinessCreateWithoutCancellationRequestsInput, BusinessUncheckedCreateWithoutCancellationRequestsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutCancellationRequestsInput
    upsert?: BusinessUpsertWithoutCancellationRequestsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutCancellationRequestsInput, BusinessUpdateWithoutCancellationRequestsInput>, BusinessUncheckedUpdateWithoutCancellationRequestsInput>
  }

  export type BusinessCreateNestedOneWithoutRefundPoliciesInput = {
    create?: XOR<BusinessCreateWithoutRefundPoliciesInput, BusinessUncheckedCreateWithoutRefundPoliciesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutRefundPoliciesInput
    connect?: BusinessWhereUniqueInput
  }

  export type BusinessUpdateOneRequiredWithoutRefundPoliciesNestedInput = {
    create?: XOR<BusinessCreateWithoutRefundPoliciesInput, BusinessUncheckedCreateWithoutRefundPoliciesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutRefundPoliciesInput
    upsert?: BusinessUpsertWithoutRefundPoliciesInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutRefundPoliciesInput, BusinessUpdateWithoutRefundPoliciesInput>, BusinessUncheckedUpdateWithoutRefundPoliciesInput>
  }

  export type CustomerCreateNestedOneWithoutSavedPaymentMethodsInput = {
    create?: XOR<CustomerCreateWithoutSavedPaymentMethodsInput, CustomerUncheckedCreateWithoutSavedPaymentMethodsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSavedPaymentMethodsInput
    connect?: CustomerWhereUniqueInput
  }

  export type SubscriptionCreateNestedManyWithoutSavedPaymentMethodInput = {
    create?: XOR<SubscriptionCreateWithoutSavedPaymentMethodInput, SubscriptionUncheckedCreateWithoutSavedPaymentMethodInput> | SubscriptionCreateWithoutSavedPaymentMethodInput[] | SubscriptionUncheckedCreateWithoutSavedPaymentMethodInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSavedPaymentMethodInput | SubscriptionCreateOrConnectWithoutSavedPaymentMethodInput[]
    createMany?: SubscriptionCreateManySavedPaymentMethodInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutSavedPaymentMethodInput = {
    create?: XOR<SubscriptionCreateWithoutSavedPaymentMethodInput, SubscriptionUncheckedCreateWithoutSavedPaymentMethodInput> | SubscriptionCreateWithoutSavedPaymentMethodInput[] | SubscriptionUncheckedCreateWithoutSavedPaymentMethodInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSavedPaymentMethodInput | SubscriptionCreateOrConnectWithoutSavedPaymentMethodInput[]
    createMany?: SubscriptionCreateManySavedPaymentMethodInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type EnumPaymentProviderFieldUpdateOperationsInput = {
    set?: $Enums.PaymentProvider
  }

  export type NullableEnumCardBrandFieldUpdateOperationsInput = {
    set?: $Enums.CardBrand | null
  }

  export type CustomerUpdateOneRequiredWithoutSavedPaymentMethodsNestedInput = {
    create?: XOR<CustomerCreateWithoutSavedPaymentMethodsInput, CustomerUncheckedCreateWithoutSavedPaymentMethodsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSavedPaymentMethodsInput
    upsert?: CustomerUpsertWithoutSavedPaymentMethodsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSavedPaymentMethodsInput, CustomerUpdateWithoutSavedPaymentMethodsInput>, CustomerUncheckedUpdateWithoutSavedPaymentMethodsInput>
  }

  export type SubscriptionUpdateManyWithoutSavedPaymentMethodNestedInput = {
    create?: XOR<SubscriptionCreateWithoutSavedPaymentMethodInput, SubscriptionUncheckedCreateWithoutSavedPaymentMethodInput> | SubscriptionCreateWithoutSavedPaymentMethodInput[] | SubscriptionUncheckedCreateWithoutSavedPaymentMethodInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSavedPaymentMethodInput | SubscriptionCreateOrConnectWithoutSavedPaymentMethodInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutSavedPaymentMethodInput | SubscriptionUpsertWithWhereUniqueWithoutSavedPaymentMethodInput[]
    createMany?: SubscriptionCreateManySavedPaymentMethodInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutSavedPaymentMethodInput | SubscriptionUpdateWithWhereUniqueWithoutSavedPaymentMethodInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutSavedPaymentMethodInput | SubscriptionUpdateManyWithWhereWithoutSavedPaymentMethodInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutSavedPaymentMethodNestedInput = {
    create?: XOR<SubscriptionCreateWithoutSavedPaymentMethodInput, SubscriptionUncheckedCreateWithoutSavedPaymentMethodInput> | SubscriptionCreateWithoutSavedPaymentMethodInput[] | SubscriptionUncheckedCreateWithoutSavedPaymentMethodInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutSavedPaymentMethodInput | SubscriptionCreateOrConnectWithoutSavedPaymentMethodInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutSavedPaymentMethodInput | SubscriptionUpsertWithWhereUniqueWithoutSavedPaymentMethodInput[]
    createMany?: SubscriptionCreateManySavedPaymentMethodInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutSavedPaymentMethodInput | SubscriptionUpdateWithWhereUniqueWithoutSavedPaymentMethodInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutSavedPaymentMethodInput | SubscriptionUpdateManyWithWhereWithoutSavedPaymentMethodInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type BusinessCreateNestedOneWithoutSubscriptionPlansInput = {
    create?: XOR<BusinessCreateWithoutSubscriptionPlansInput, BusinessUncheckedCreateWithoutSubscriptionPlansInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriptionPlansInput
    connect?: BusinessWhereUniqueInput
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type EnumSubscriptionIntervalFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionInterval
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type BusinessUpdateOneWithoutSubscriptionPlansNestedInput = {
    create?: XOR<BusinessCreateWithoutSubscriptionPlansInput, BusinessUncheckedCreateWithoutSubscriptionPlansInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriptionPlansInput
    upsert?: BusinessUpsertWithoutSubscriptionPlansInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutSubscriptionPlansInput, BusinessUpdateWithoutSubscriptionPlansInput>, BusinessUncheckedUpdateWithoutSubscriptionPlansInput>
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSubscriptionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type SavedPaymentMethodCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<SavedPaymentMethodCreateWithoutSubscriptionsInput, SavedPaymentMethodUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SavedPaymentMethodCreateOrConnectWithoutSubscriptionsInput
    connect?: SavedPaymentMethodWhereUniqueInput
  }

  export type RecurringPaymentCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<RecurringPaymentCreateWithoutSubscriptionInput, RecurringPaymentUncheckedCreateWithoutSubscriptionInput> | RecurringPaymentCreateWithoutSubscriptionInput[] | RecurringPaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: RecurringPaymentCreateOrConnectWithoutSubscriptionInput | RecurringPaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: RecurringPaymentCreateManySubscriptionInputEnvelope
    connect?: RecurringPaymentWhereUniqueInput | RecurringPaymentWhereUniqueInput[]
  }

  export type BusinessCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<BusinessCreateWithoutSubscriptionsInput, BusinessUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriptionsInput
    connect?: BusinessWhereUniqueInput
  }

  export type RecurringPaymentUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<RecurringPaymentCreateWithoutSubscriptionInput, RecurringPaymentUncheckedCreateWithoutSubscriptionInput> | RecurringPaymentCreateWithoutSubscriptionInput[] | RecurringPaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: RecurringPaymentCreateOrConnectWithoutSubscriptionInput | RecurringPaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: RecurringPaymentCreateManySubscriptionInputEnvelope
    connect?: RecurringPaymentWhereUniqueInput | RecurringPaymentWhereUniqueInput[]
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSubscriptionsInput
    upsert?: CustomerUpsertWithoutSubscriptionsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSubscriptionsInput, CustomerUpdateWithoutSubscriptionsInput>, CustomerUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: SubscriptionPlanUpsertWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput, SubscriptionPlanUpdateWithoutSubscriptionsInput>, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SavedPaymentMethodUpdateOneWithoutSubscriptionsNestedInput = {
    create?: XOR<SavedPaymentMethodCreateWithoutSubscriptionsInput, SavedPaymentMethodUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SavedPaymentMethodCreateOrConnectWithoutSubscriptionsInput
    upsert?: SavedPaymentMethodUpsertWithoutSubscriptionsInput
    disconnect?: SavedPaymentMethodWhereInput | boolean
    delete?: SavedPaymentMethodWhereInput | boolean
    connect?: SavedPaymentMethodWhereUniqueInput
    update?: XOR<XOR<SavedPaymentMethodUpdateToOneWithWhereWithoutSubscriptionsInput, SavedPaymentMethodUpdateWithoutSubscriptionsInput>, SavedPaymentMethodUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type RecurringPaymentUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<RecurringPaymentCreateWithoutSubscriptionInput, RecurringPaymentUncheckedCreateWithoutSubscriptionInput> | RecurringPaymentCreateWithoutSubscriptionInput[] | RecurringPaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: RecurringPaymentCreateOrConnectWithoutSubscriptionInput | RecurringPaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: RecurringPaymentUpsertWithWhereUniqueWithoutSubscriptionInput | RecurringPaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: RecurringPaymentCreateManySubscriptionInputEnvelope
    set?: RecurringPaymentWhereUniqueInput | RecurringPaymentWhereUniqueInput[]
    disconnect?: RecurringPaymentWhereUniqueInput | RecurringPaymentWhereUniqueInput[]
    delete?: RecurringPaymentWhereUniqueInput | RecurringPaymentWhereUniqueInput[]
    connect?: RecurringPaymentWhereUniqueInput | RecurringPaymentWhereUniqueInput[]
    update?: RecurringPaymentUpdateWithWhereUniqueWithoutSubscriptionInput | RecurringPaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: RecurringPaymentUpdateManyWithWhereWithoutSubscriptionInput | RecurringPaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: RecurringPaymentScalarWhereInput | RecurringPaymentScalarWhereInput[]
  }

  export type BusinessUpdateOneWithoutSubscriptionsNestedInput = {
    create?: XOR<BusinessCreateWithoutSubscriptionsInput, BusinessUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutSubscriptionsInput
    upsert?: BusinessUpsertWithoutSubscriptionsInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutSubscriptionsInput, BusinessUpdateWithoutSubscriptionsInput>, BusinessUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type RecurringPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<RecurringPaymentCreateWithoutSubscriptionInput, RecurringPaymentUncheckedCreateWithoutSubscriptionInput> | RecurringPaymentCreateWithoutSubscriptionInput[] | RecurringPaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: RecurringPaymentCreateOrConnectWithoutSubscriptionInput | RecurringPaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: RecurringPaymentUpsertWithWhereUniqueWithoutSubscriptionInput | RecurringPaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: RecurringPaymentCreateManySubscriptionInputEnvelope
    set?: RecurringPaymentWhereUniqueInput | RecurringPaymentWhereUniqueInput[]
    disconnect?: RecurringPaymentWhereUniqueInput | RecurringPaymentWhereUniqueInput[]
    delete?: RecurringPaymentWhereUniqueInput | RecurringPaymentWhereUniqueInput[]
    connect?: RecurringPaymentWhereUniqueInput | RecurringPaymentWhereUniqueInput[]
    update?: RecurringPaymentUpdateWithWhereUniqueWithoutSubscriptionInput | RecurringPaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: RecurringPaymentUpdateManyWithWhereWithoutSubscriptionInput | RecurringPaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: RecurringPaymentScalarWhereInput | RecurringPaymentScalarWhereInput[]
  }

  export type SubscriptionCreateNestedOneWithoutRecurringPaymentsInput = {
    create?: XOR<SubscriptionCreateWithoutRecurringPaymentsInput, SubscriptionUncheckedCreateWithoutRecurringPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutRecurringPaymentsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type SubscriptionUpdateOneRequiredWithoutRecurringPaymentsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutRecurringPaymentsInput, SubscriptionUncheckedCreateWithoutRecurringPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutRecurringPaymentsInput
    upsert?: SubscriptionUpsertWithoutRecurringPaymentsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutRecurringPaymentsInput, SubscriptionUpdateWithoutRecurringPaymentsInput>, SubscriptionUncheckedUpdateWithoutRecurringPaymentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCourierAvailabilityStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CourierAvailabilityStatus | EnumCourierAvailabilityStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCourierAvailabilityStatusNullableFilter<$PrismaModel> | $Enums.CourierAvailabilityStatus | null
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCourierAvailabilityStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourierAvailabilityStatus | EnumCourierAvailabilityStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCourierAvailabilityStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.CourierAvailabilityStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCourierAvailabilityStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumCourierAvailabilityStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryPriority | EnumDeliveryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryPriority[] | ListEnumDeliveryPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryPriority[] | ListEnumDeliveryPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryPriorityFilter<$PrismaModel> | $Enums.DeliveryPriority
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumDeliveryPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryPriority | EnumDeliveryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryPriority[] | ListEnumDeliveryPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryPriority[] | ListEnumDeliveryPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryPriorityWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryPriorityFilter<$PrismaModel>
    _max?: NestedEnumDeliveryPriorityFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelFilter<$PrismaModel> | $Enums.NotificationChannel
  }

  export type NestedEnumNotificationFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationFrequency | EnumNotificationFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationFrequency[] | ListEnumNotificationFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationFrequency[] | ListEnumNotificationFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationFrequencyFilter<$PrismaModel> | $Enums.NotificationFrequency
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelFilter<$PrismaModel>
  }

  export type NestedEnumNotificationFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationFrequency | EnumNotificationFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationFrequency[] | ListEnumNotificationFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationFrequency[] | ListEnumNotificationFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.NotificationFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationFrequencyFilter<$PrismaModel>
    _max?: NestedEnumNotificationFrequencyFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type NestedEnumReportFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFormat | EnumReportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFormatFilter<$PrismaModel> | $Enums.ReportFormat
  }

  export type NestedEnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type NestedEnumReportFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFormat | EnumReportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFormat[] | ListEnumReportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFormatWithAggregatesFilter<$PrismaModel> | $Enums.ReportFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportFormatFilter<$PrismaModel>
    _max?: NestedEnumReportFormatFilter<$PrismaModel>
  }

  export type NestedEnumCourierAvailabilityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CourierAvailabilityStatus | EnumCourierAvailabilityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourierAvailabilityStatusFilter<$PrismaModel> | $Enums.CourierAvailabilityStatus
  }

  export type NestedEnumCourierAvailabilityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourierAvailabilityStatus | EnumCourierAvailabilityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourierAvailabilityStatus[] | ListEnumCourierAvailabilityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourierAvailabilityStatusWithAggregatesFilter<$PrismaModel> | $Enums.CourierAvailabilityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourierAvailabilityStatusFilter<$PrismaModel>
    _max?: NestedEnumCourierAvailabilityStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumRefundRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundRequestStatus | EnumRefundRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundRequestStatus[] | ListEnumRefundRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundRequestStatus[] | ListEnumRefundRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundRequestStatusFilter<$PrismaModel> | $Enums.RefundRequestStatus
  }

  export type NestedEnumRefundReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundReason | EnumRefundReasonFieldRefInput<$PrismaModel>
    in?: $Enums.RefundReason[] | ListEnumRefundReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundReason[] | ListEnumRefundReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundReasonFilter<$PrismaModel> | $Enums.RefundReason
  }

  export type NestedEnumRefundRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundRequestStatus | EnumRefundRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundRequestStatus[] | ListEnumRefundRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundRequestStatus[] | ListEnumRefundRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRefundRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumRefundReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundReason | EnumRefundReasonFieldRefInput<$PrismaModel>
    in?: $Enums.RefundReason[] | ListEnumRefundReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundReason[] | ListEnumRefundReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundReasonWithAggregatesFilter<$PrismaModel> | $Enums.RefundReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundReasonFilter<$PrismaModel>
    _max?: NestedEnumRefundReasonFilter<$PrismaModel>
  }

  export type NestedEnumCancellationRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationRequestStatus | EnumCancellationRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationRequestStatus[] | ListEnumCancellationRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CancellationRequestStatus[] | ListEnumCancellationRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCancellationRequestStatusFilter<$PrismaModel> | $Enums.CancellationRequestStatus
  }

  export type NestedEnumCancellationReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationReason | EnumCancellationReasonFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationReason[] | ListEnumCancellationReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.CancellationReason[] | ListEnumCancellationReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumCancellationReasonFilter<$PrismaModel> | $Enums.CancellationReason
  }

  export type NestedEnumCancellationRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationRequestStatus | EnumCancellationRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationRequestStatus[] | ListEnumCancellationRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CancellationRequestStatus[] | ListEnumCancellationRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCancellationRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.CancellationRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCancellationRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumCancellationRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumCancellationReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationReason | EnumCancellationReasonFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationReason[] | ListEnumCancellationReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.CancellationReason[] | ListEnumCancellationReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumCancellationReasonWithAggregatesFilter<$PrismaModel> | $Enums.CancellationReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCancellationReasonFilter<$PrismaModel>
    _max?: NestedEnumCancellationReasonFilter<$PrismaModel>
  }

  export type NestedEnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type NestedEnumCardBrandNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CardBrand | EnumCardBrandFieldRefInput<$PrismaModel> | null
    in?: $Enums.CardBrand[] | ListEnumCardBrandFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CardBrand[] | ListEnumCardBrandFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCardBrandNullableFilter<$PrismaModel> | $Enums.CardBrand | null
  }

  export type NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }

  export type NestedEnumCardBrandNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CardBrand | EnumCardBrandFieldRefInput<$PrismaModel> | null
    in?: $Enums.CardBrand[] | ListEnumCardBrandFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CardBrand[] | ListEnumCardBrandFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCardBrandNullableWithAggregatesFilter<$PrismaModel> | $Enums.CardBrand | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCardBrandNullableFilter<$PrismaModel>
    _max?: NestedEnumCardBrandNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionIntervalFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionInterval | EnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionIntervalFilter<$PrismaModel> | $Enums.SubscriptionInterval
  }

  export type NestedEnumSubscriptionIntervalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionInterval | EnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionIntervalWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionInterval
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionIntervalFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionIntervalFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    department?: string | null
    level?: number
    permissions?: AdminCreatepermissionsInput | string[]
    title?: string | null
    phone?: string | null
    profileImage?: string | null
    lastLogin?: Date | string | null
    loginAttempts?: number
    isSuperAdmin?: boolean
    ipRestrictions?: AdminCreateipRestrictionsInput | string[]
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    systemActions?: SystemActionCreateNestedManyWithoutAdminInput
    dashboardWidgets?: AdminDashboardWidgetCreateNestedManyWithoutAdminInput
    roleMappings?: AdminRoleMappingCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    department?: string | null
    level?: number
    permissions?: AdminCreatepermissionsInput | string[]
    title?: string | null
    phone?: string | null
    profileImage?: string | null
    lastLogin?: Date | string | null
    loginAttempts?: number
    isSuperAdmin?: boolean
    ipRestrictions?: AdminCreateipRestrictionsInput | string[]
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    systemActions?: SystemActionUncheckedCreateNestedManyWithoutAdminInput
    dashboardWidgets?: AdminDashboardWidgetUncheckedCreateNestedManyWithoutAdminInput
    roleMappings?: AdminRoleMappingUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type BusinessCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    zone?: ZoneCreateNestedOneWithoutBusinessesInput
    inventory?: InventoryCreateNestedManyWithoutBusinessInput
    orders?: OrderCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBusinessInput
    payments?: PaymentCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    zoneId?: string | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    inventory?: InventoryUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrderUncheckedCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBusinessInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyUncheckedCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutUserInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutUserInput, BusinessUncheckedCreateWithoutUserInput>
  }

  export type CourierCreateWithoutUserInput = {
    id?: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    zone?: ZoneCreateNestedOneWithoutCouriersInput
    orders?: OrderCreateNestedManyWithoutCourierInput
    notifications?: NotificationCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    payments?: PaymentCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteCreateNestedManyWithoutCourierInput
  }

  export type CourierUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    zoneId?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedCreateNestedManyWithoutCourierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityUncheckedCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteUncheckedCreateNestedManyWithoutCourierInput
  }

  export type CourierCreateOrConnectWithoutUserInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutUserInput, CourierUncheckedCreateWithoutUserInput>
  }

  export type CustomerCreateWithoutUserInput = {
    id?: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutCustomerInput
    deliveries?: DeliveryCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutUserInput = {
    id?: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutUserInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    courier?: CourierCreateNestedOneWithoutNotificationsInput
    order?: OrderCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    courierId?: string | null
    orderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
    frequency?: $Enums.NotificationFrequency
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courier?: CourierCreateNestedOneWithoutNotificationPreferencesInput
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    courierId?: string | null
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
    frequency?: $Enums.NotificationFrequency
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type NotificationPreferenceCreateManyUserInputEnvelope = {
    data: NotificationPreferenceCreateManyUserInput | NotificationPreferenceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutUserInput = {
    id?: string
    name: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    expiresAt?: Date | string | null
  }

  export type ReportUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    expiresAt?: Date | string | null
  }

  export type ReportCreateOrConnectWithoutUserInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput>
  }

  export type ReportCreateManyUserInputEnvelope = {
    data: ReportCreateManyUserInput | ReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledReportCreateWithoutUserInput = {
    id?: string
    reportName: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    recipients?: ScheduledReportCreaterecipientsInput | string[]
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schedule: ScheduleCreateNestedOneWithoutReportsInput
  }

  export type ScheduledReportUncheckedCreateWithoutUserInput = {
    id?: string
    scheduleId: string
    reportName: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    recipients?: ScheduledReportCreaterecipientsInput | string[]
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportCreateOrConnectWithoutUserInput = {
    where: ScheduledReportWhereUniqueInput
    create: XOR<ScheduledReportCreateWithoutUserInput, ScheduledReportUncheckedCreateWithoutUserInput>
  }

  export type ScheduledReportCreateManyUserInputEnvelope = {
    data: ScheduledReportCreateManyUserInput | ScheduledReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingsCreateWithoutUserInput = {
    id?: string
    language?: string
    theme?: string
    notifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    language?: string
    theme?: string
    notifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateWithoutUserInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    targetId?: string | null
    targetType?: string | null
    ip?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: string | null
    category?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    admin?: AdminCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    targetId?: string | null
    targetType?: string | null
    ip?: string | null
    userAgent?: string | null
    adminId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: string | null
    category?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    permissions?: AdminUpdatepermissionsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    ipRestrictions?: AdminUpdateipRestrictionsInput | string[]
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    systemActions?: SystemActionUpdateManyWithoutAdminNestedInput
    dashboardWidgets?: AdminDashboardWidgetUpdateManyWithoutAdminNestedInput
    roleMappings?: AdminRoleMappingUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    permissions?: AdminUpdatepermissionsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    ipRestrictions?: AdminUpdateipRestrictionsInput | string[]
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    systemActions?: SystemActionUncheckedUpdateManyWithoutAdminNestedInput
    dashboardWidgets?: AdminDashboardWidgetUncheckedUpdateManyWithoutAdminNestedInput
    roleMappings?: AdminRoleMappingUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type BusinessUpsertWithoutUserInput = {
    update: XOR<BusinessUpdateWithoutUserInput, BusinessUncheckedUpdateWithoutUserInput>
    create: XOR<BusinessCreateWithoutUserInput, BusinessUncheckedCreateWithoutUserInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutUserInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutUserInput, BusinessUncheckedUpdateWithoutUserInput>
  }

  export type BusinessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    zone?: ZoneUpdateOneWithoutBusinessesNestedInput
    inventory?: InventoryUpdateManyWithoutBusinessNestedInput
    orders?: OrderUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    inventory?: InventoryUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUncheckedUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type CourierUpsertWithoutUserInput = {
    update: XOR<CourierUpdateWithoutUserInput, CourierUncheckedUpdateWithoutUserInput>
    create: XOR<CourierCreateWithoutUserInput, CourierUncheckedCreateWithoutUserInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutUserInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutUserInput, CourierUncheckedUpdateWithoutUserInput>
  }

  export type CourierUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    zone?: ZoneUpdateOneWithoutCouriersNestedInput
    orders?: OrderUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    payments?: PaymentUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUpdateManyWithoutCourierNestedInput
  }

  export type CourierUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUncheckedUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUncheckedUpdateManyWithoutCourierNestedInput
  }

  export type CustomerUpsertWithoutUserInput = {
    update: XOR<CustomerUpdateWithoutUserInput, CustomerUncheckedUpdateWithoutUserInput>
    create: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutUserInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutUserInput, CustomerUncheckedUpdateWithoutUserInput>
  }

  export type CustomerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    deliveries?: DeliveryUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
    courierId?: StringNullableFilter<"Notification"> | string | null
    orderId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
  }

  export type NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateManyWithWhereWithoutUserInput = {
    where: NotificationPreferenceScalarWhereInput
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationPreferenceScalarWhereInput = {
    AND?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
    OR?: NotificationPreferenceScalarWhereInput[]
    NOT?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    userId?: StringFilter<"NotificationPreference"> | string
    courierId?: StringNullableFilter<"NotificationPreference"> | string | null
    type?: EnumNotificationTypeFilter<"NotificationPreference"> | $Enums.NotificationType
    channel?: EnumNotificationChannelFilter<"NotificationPreference"> | $Enums.NotificationChannel
    frequency?: EnumNotificationFrequencyFilter<"NotificationPreference"> | $Enums.NotificationFrequency
    enabled?: BoolFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutUserInput, ReportUncheckedUpdateWithoutUserInput>
    create: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutUserInput, ReportUncheckedUpdateWithoutUserInput>
  }

  export type ReportUpdateManyWithWhereWithoutUserInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutUserInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    userId?: StringFilter<"Report"> | string
    name?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    format?: EnumReportFormatFilter<"Report"> | $Enums.ReportFormat
    parameters?: JsonNullableFilter<"Report">
    createdAt?: DateTimeFilter<"Report"> | Date | string
    data?: JsonNullableFilter<"Report">
    url?: StringNullableFilter<"Report"> | string | null
    expiresAt?: DateTimeNullableFilter<"Report"> | Date | string | null
  }

  export type ScheduledReportUpsertWithWhereUniqueWithoutUserInput = {
    where: ScheduledReportWhereUniqueInput
    update: XOR<ScheduledReportUpdateWithoutUserInput, ScheduledReportUncheckedUpdateWithoutUserInput>
    create: XOR<ScheduledReportCreateWithoutUserInput, ScheduledReportUncheckedCreateWithoutUserInput>
  }

  export type ScheduledReportUpdateWithWhereUniqueWithoutUserInput = {
    where: ScheduledReportWhereUniqueInput
    data: XOR<ScheduledReportUpdateWithoutUserInput, ScheduledReportUncheckedUpdateWithoutUserInput>
  }

  export type ScheduledReportUpdateManyWithWhereWithoutUserInput = {
    where: ScheduledReportScalarWhereInput
    data: XOR<ScheduledReportUpdateManyMutationInput, ScheduledReportUncheckedUpdateManyWithoutUserInput>
  }

  export type ScheduledReportScalarWhereInput = {
    AND?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
    OR?: ScheduledReportScalarWhereInput[]
    NOT?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
    id?: StringFilter<"ScheduledReport"> | string
    userId?: StringFilter<"ScheduledReport"> | string
    scheduleId?: StringFilter<"ScheduledReport"> | string
    reportName?: StringFilter<"ScheduledReport"> | string
    type?: EnumReportTypeFilter<"ScheduledReport"> | $Enums.ReportType
    format?: EnumReportFormatFilter<"ScheduledReport"> | $Enums.ReportFormat
    parameters?: JsonNullableFilter<"ScheduledReport">
    enabled?: BoolFilter<"ScheduledReport"> | boolean
    recipients?: StringNullableListFilter<"ScheduledReport">
    nextRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    createdAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledReport"> | Date | string
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    description?: StringFilter<"ActivityLog"> | string
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    targetId?: StringNullableFilter<"ActivityLog"> | string | null
    targetType?: StringNullableFilter<"ActivityLog"> | string | null
    ip?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    adminId?: StringNullableFilter<"ActivityLog"> | string | null
    metadata?: JsonNullableFilter<"ActivityLog">
    severity?: StringNullableFilter<"ActivityLog"> | string | null
    category?: StringNullableFilter<"ActivityLog"> | string | null
    isResolved?: BoolFilter<"ActivityLog"> | boolean
    resolvedAt?: DateTimeNullableFilter<"ActivityLog"> | Date | string | null
    resolvedBy?: StringNullableFilter<"ActivityLog"> | string | null
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    business?: BusinessCreateNestedOneWithoutUserInput
    courier?: CourierCreateNestedOneWithoutUserInput
    customer?: CustomerCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    business?: BusinessUncheckedCreateNestedOneWithoutUserInput
    courier?: CourierUncheckedCreateNestedOneWithoutUserInput
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type ActivityLogCreateWithoutAdminInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    targetId?: string | null
    targetType?: string | null
    ip?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: string | null
    category?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    user?: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateWithoutAdminInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    userId?: string | null
    targetId?: string | null
    targetType?: string | null
    ip?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: string | null
    category?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type ActivityLogCreateOrConnectWithoutAdminInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput>
  }

  export type ActivityLogCreateManyAdminInputEnvelope = {
    data: ActivityLogCreateManyAdminInput | ActivityLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type SystemActionCreateWithoutAdminInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    status?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    executionTime?: number | null
  }

  export type SystemActionUncheckedCreateWithoutAdminInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    status?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    executionTime?: number | null
  }

  export type SystemActionCreateOrConnectWithoutAdminInput = {
    where: SystemActionWhereUniqueInput
    create: XOR<SystemActionCreateWithoutAdminInput, SystemActionUncheckedCreateWithoutAdminInput>
  }

  export type SystemActionCreateManyAdminInputEnvelope = {
    data: SystemActionCreateManyAdminInput | SystemActionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminDashboardWidgetCreateWithoutAdminInput = {
    id?: string
    name: string
    type: string
    position?: number
    size?: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminDashboardWidgetUncheckedCreateWithoutAdminInput = {
    id?: string
    name: string
    type: string
    position?: number
    size?: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminDashboardWidgetCreateOrConnectWithoutAdminInput = {
    where: AdminDashboardWidgetWhereUniqueInput
    create: XOR<AdminDashboardWidgetCreateWithoutAdminInput, AdminDashboardWidgetUncheckedCreateWithoutAdminInput>
  }

  export type AdminDashboardWidgetCreateManyAdminInputEnvelope = {
    data: AdminDashboardWidgetCreateManyAdminInput | AdminDashboardWidgetCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminRoleMappingCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role: AdminRoleCreateNestedOneWithoutAdminsInput
  }

  export type AdminRoleMappingUncheckedCreateWithoutAdminInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminRoleMappingCreateOrConnectWithoutAdminInput = {
    where: AdminRoleMappingWhereUniqueInput
    create: XOR<AdminRoleMappingCreateWithoutAdminInput, AdminRoleMappingUncheckedCreateWithoutAdminInput>
  }

  export type AdminRoleMappingCreateManyAdminInputEnvelope = {
    data: AdminRoleMappingCreateManyAdminInput | AdminRoleMappingCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneWithoutUserNestedInput
    courier?: CourierUpdateOneWithoutUserNestedInput
    customer?: CustomerUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUncheckedUpdateOneWithoutUserNestedInput
    courier?: CourierUncheckedUpdateOneWithoutUserNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutAdminInput, ActivityLogUncheckedUpdateWithoutAdminInput>
    create: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutAdminInput, ActivityLogUncheckedUpdateWithoutAdminInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutAdminInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type SystemActionUpsertWithWhereUniqueWithoutAdminInput = {
    where: SystemActionWhereUniqueInput
    update: XOR<SystemActionUpdateWithoutAdminInput, SystemActionUncheckedUpdateWithoutAdminInput>
    create: XOR<SystemActionCreateWithoutAdminInput, SystemActionUncheckedCreateWithoutAdminInput>
  }

  export type SystemActionUpdateWithWhereUniqueWithoutAdminInput = {
    where: SystemActionWhereUniqueInput
    data: XOR<SystemActionUpdateWithoutAdminInput, SystemActionUncheckedUpdateWithoutAdminInput>
  }

  export type SystemActionUpdateManyWithWhereWithoutAdminInput = {
    where: SystemActionScalarWhereInput
    data: XOR<SystemActionUpdateManyMutationInput, SystemActionUncheckedUpdateManyWithoutAdminInput>
  }

  export type SystemActionScalarWhereInput = {
    AND?: SystemActionScalarWhereInput | SystemActionScalarWhereInput[]
    OR?: SystemActionScalarWhereInput[]
    NOT?: SystemActionScalarWhereInput | SystemActionScalarWhereInput[]
    id?: StringFilter<"SystemAction"> | string
    action?: StringFilter<"SystemAction"> | string
    description?: StringFilter<"SystemAction"> | string
    createdAt?: DateTimeFilter<"SystemAction"> | Date | string
    adminId?: StringNullableFilter<"SystemAction"> | string | null
    status?: StringFilter<"SystemAction"> | string
    payload?: JsonNullableFilter<"SystemAction">
    result?: JsonNullableFilter<"SystemAction">
    error?: StringNullableFilter<"SystemAction"> | string | null
    executionTime?: IntNullableFilter<"SystemAction"> | number | null
  }

  export type AdminDashboardWidgetUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminDashboardWidgetWhereUniqueInput
    update: XOR<AdminDashboardWidgetUpdateWithoutAdminInput, AdminDashboardWidgetUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminDashboardWidgetCreateWithoutAdminInput, AdminDashboardWidgetUncheckedCreateWithoutAdminInput>
  }

  export type AdminDashboardWidgetUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminDashboardWidgetWhereUniqueInput
    data: XOR<AdminDashboardWidgetUpdateWithoutAdminInput, AdminDashboardWidgetUncheckedUpdateWithoutAdminInput>
  }

  export type AdminDashboardWidgetUpdateManyWithWhereWithoutAdminInput = {
    where: AdminDashboardWidgetScalarWhereInput
    data: XOR<AdminDashboardWidgetUpdateManyMutationInput, AdminDashboardWidgetUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminDashboardWidgetScalarWhereInput = {
    AND?: AdminDashboardWidgetScalarWhereInput | AdminDashboardWidgetScalarWhereInput[]
    OR?: AdminDashboardWidgetScalarWhereInput[]
    NOT?: AdminDashboardWidgetScalarWhereInput | AdminDashboardWidgetScalarWhereInput[]
    id?: StringFilter<"AdminDashboardWidget"> | string
    name?: StringFilter<"AdminDashboardWidget"> | string
    type?: StringFilter<"AdminDashboardWidget"> | string
    position?: IntFilter<"AdminDashboardWidget"> | number
    size?: StringFilter<"AdminDashboardWidget"> | string
    config?: JsonFilter<"AdminDashboardWidget">
    isActive?: BoolFilter<"AdminDashboardWidget"> | boolean
    adminId?: StringFilter<"AdminDashboardWidget"> | string
    createdAt?: DateTimeFilter<"AdminDashboardWidget"> | Date | string
    updatedAt?: DateTimeFilter<"AdminDashboardWidget"> | Date | string
  }

  export type AdminRoleMappingUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminRoleMappingWhereUniqueInput
    update: XOR<AdminRoleMappingUpdateWithoutAdminInput, AdminRoleMappingUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminRoleMappingCreateWithoutAdminInput, AdminRoleMappingUncheckedCreateWithoutAdminInput>
  }

  export type AdminRoleMappingUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminRoleMappingWhereUniqueInput
    data: XOR<AdminRoleMappingUpdateWithoutAdminInput, AdminRoleMappingUncheckedUpdateWithoutAdminInput>
  }

  export type AdminRoleMappingUpdateManyWithWhereWithoutAdminInput = {
    where: AdminRoleMappingScalarWhereInput
    data: XOR<AdminRoleMappingUpdateManyMutationInput, AdminRoleMappingUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminRoleMappingScalarWhereInput = {
    AND?: AdminRoleMappingScalarWhereInput | AdminRoleMappingScalarWhereInput[]
    OR?: AdminRoleMappingScalarWhereInput[]
    NOT?: AdminRoleMappingScalarWhereInput | AdminRoleMappingScalarWhereInput[]
    id?: StringFilter<"AdminRoleMapping"> | string
    adminId?: StringFilter<"AdminRoleMapping"> | string
    roleId?: StringFilter<"AdminRoleMapping"> | string
    createdAt?: DateTimeFilter<"AdminRoleMapping"> | Date | string
    updatedAt?: DateTimeFilter<"AdminRoleMapping"> | Date | string
  }

  export type UserCreateWithoutCourierInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutUserInput
    business?: BusinessCreateNestedOneWithoutUserInput
    customer?: CustomerCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCourierInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    business?: BusinessUncheckedCreateNestedOneWithoutUserInput
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCourierInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourierInput, UserUncheckedCreateWithoutCourierInput>
  }

  export type ZoneCreateWithoutCouriersInput = {
    id?: string
    name: string
    description?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    averageDeliveryTime?: number | null
    orderVolume?: number | null
    activeBusinesses?: number | null
    businesses?: BusinessCreateNestedManyWithoutZoneInput
    deliveries?: DeliveryCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutCouriersInput = {
    id?: string
    name: string
    description?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    averageDeliveryTime?: number | null
    orderVolume?: number | null
    activeBusinesses?: number | null
    businesses?: BusinessUncheckedCreateNestedManyWithoutZoneInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutCouriersInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutCouriersInput, ZoneUncheckedCreateWithoutCouriersInput>
  }

  export type OrderCreateWithoutCourierInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    priority?: $Enums.DeliveryPriority
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    business: BusinessCreateNestedOneWithoutOrdersInput
    notifications?: NotificationCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    requestedTimeWindow?: DeliveryTimeWindowCreateNestedOneWithoutOrdersInput
    delivery?: DeliveryCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCourierInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    customerId: string
    businessId: string
    priority?: $Enums.DeliveryPriority
    timeWindowId?: string | null
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    delivery?: DeliveryUncheckedCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCourierInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCourierInput, OrderUncheckedCreateWithoutCourierInput>
  }

  export type OrderCreateManyCourierInputEnvelope = {
    data: OrderCreateManyCourierInput | OrderCreateManyCourierInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutCourierInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutNotificationsInput
    order?: OrderCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutCourierInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    userId: string
    orderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateOrConnectWithoutCourierInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutCourierInput, NotificationUncheckedCreateWithoutCourierInput>
  }

  export type NotificationCreateManyCourierInputEnvelope = {
    data: NotificationCreateManyCourierInput | NotificationCreateManyCourierInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutCourierInput = {
    id?: string
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
    frequency?: $Enums.NotificationFrequency
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationPreferencesInput
  }

  export type NotificationPreferenceUncheckedCreateWithoutCourierInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
    frequency?: $Enums.NotificationFrequency
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutCourierInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutCourierInput, NotificationPreferenceUncheckedCreateWithoutCourierInput>
  }

  export type NotificationPreferenceCreateManyCourierInputEnvelope = {
    data: NotificationPreferenceCreateManyCourierInput | NotificationPreferenceCreateManyCourierInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryLogCreateWithoutCourierInput = {
    id?: string
    action: string
    timestamp?: Date | string
    latitude?: number | null
    longitude?: number | null
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DeliveryLogUncheckedCreateWithoutCourierInput = {
    id?: string
    action: string
    timestamp?: Date | string
    latitude?: number | null
    longitude?: number | null
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DeliveryLogCreateOrConnectWithoutCourierInput = {
    where: DeliveryLogWhereUniqueInput
    create: XOR<DeliveryLogCreateWithoutCourierInput, DeliveryLogUncheckedCreateWithoutCourierInput>
  }

  export type DeliveryLogCreateManyCourierInputEnvelope = {
    data: DeliveryLogCreateManyCourierInput | DeliveryLogCreateManyCourierInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryCreateWithoutCourierInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
    customer: CustomerCreateNestedOneWithoutDeliveriesInput
    zone: ZoneCreateNestedOneWithoutDeliveriesInput
    order?: OrderCreateNestedOneWithoutDeliveryInput
    route?: DeliveryRouteCreateNestedOneWithoutDeliveriesInput
  }

  export type DeliveryUncheckedCreateWithoutCourierInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    customerId: string
    zoneId: string
    orderId?: string | null
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    routeId?: string | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
  }

  export type DeliveryCreateOrConnectWithoutCourierInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutCourierInput, DeliveryUncheckedCreateWithoutCourierInput>
  }

  export type DeliveryCreateManyCourierInputEnvelope = {
    data: DeliveryCreateManyCourierInput | DeliveryCreateManyCourierInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutRecipientInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    order?: OrderCreateNestedOneWithoutPaymentsInput
    business?: BusinessCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutRecipientInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    orderId?: string | null
    businessId?: string | null
  }

  export type PaymentCreateOrConnectWithoutRecipientInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutRecipientInput, PaymentUncheckedCreateWithoutRecipientInput>
  }

  export type PaymentCreateManyRecipientInputEnvelope = {
    data: PaymentCreateManyRecipientInput | PaymentCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type CourierAvailabilityCreateWithoutCourierInput = {
    id?: string
    status: $Enums.CourierAvailabilityStatus
    startTime: Date | string
    endTime?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type CourierAvailabilityUncheckedCreateWithoutCourierInput = {
    id?: string
    status: $Enums.CourierAvailabilityStatus
    startTime: Date | string
    endTime?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type CourierAvailabilityCreateOrConnectWithoutCourierInput = {
    where: CourierAvailabilityWhereUniqueInput
    create: XOR<CourierAvailabilityCreateWithoutCourierInput, CourierAvailabilityUncheckedCreateWithoutCourierInput>
  }

  export type CourierAvailabilityCreateManyCourierInputEnvelope = {
    data: CourierAvailabilityCreateManyCourierInput | CourierAvailabilityCreateManyCourierInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryRouteCreateWithoutCourierInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.Status
    totalDistance?: number | null
    totalDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
    deliveries?: DeliveryCreateNestedManyWithoutRouteInput
  }

  export type DeliveryRouteUncheckedCreateWithoutCourierInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.Status
    totalDistance?: number | null
    totalDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutRouteInput
  }

  export type DeliveryRouteCreateOrConnectWithoutCourierInput = {
    where: DeliveryRouteWhereUniqueInput
    create: XOR<DeliveryRouteCreateWithoutCourierInput, DeliveryRouteUncheckedCreateWithoutCourierInput>
  }

  export type DeliveryRouteCreateManyCourierInputEnvelope = {
    data: DeliveryRouteCreateManyCourierInput | DeliveryRouteCreateManyCourierInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCourierInput = {
    update: XOR<UserUpdateWithoutCourierInput, UserUncheckedUpdateWithoutCourierInput>
    create: XOR<UserCreateWithoutCourierInput, UserUncheckedCreateWithoutCourierInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCourierInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCourierInput, UserUncheckedUpdateWithoutCourierInput>
  }

  export type UserUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    business?: BusinessUpdateOneWithoutUserNestedInput
    customer?: CustomerUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    business?: BusinessUncheckedUpdateOneWithoutUserNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ZoneUpsertWithoutCouriersInput = {
    update: XOR<ZoneUpdateWithoutCouriersInput, ZoneUncheckedUpdateWithoutCouriersInput>
    create: XOR<ZoneCreateWithoutCouriersInput, ZoneUncheckedCreateWithoutCouriersInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutCouriersInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutCouriersInput, ZoneUncheckedUpdateWithoutCouriersInput>
  }

  export type ZoneUpdateWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    averageDeliveryTime?: NullableIntFieldUpdateOperationsInput | number | null
    orderVolume?: NullableIntFieldUpdateOperationsInput | number | null
    activeBusinesses?: NullableIntFieldUpdateOperationsInput | number | null
    businesses?: BusinessUpdateManyWithoutZoneNestedInput
    deliveries?: DeliveryUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    averageDeliveryTime?: NullableIntFieldUpdateOperationsInput | number | null
    orderVolume?: NullableIntFieldUpdateOperationsInput | number | null
    activeBusinesses?: NullableIntFieldUpdateOperationsInput | number | null
    businesses?: BusinessUncheckedUpdateManyWithoutZoneNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutCourierInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCourierInput, OrderUncheckedUpdateWithoutCourierInput>
    create: XOR<OrderCreateWithoutCourierInput, OrderUncheckedCreateWithoutCourierInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCourierInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCourierInput, OrderUncheckedUpdateWithoutCourierInput>
  }

  export type OrderUpdateManyWithWhereWithoutCourierInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCourierInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    status?: EnumStatusFilter<"Order"> | $Enums.Status
    totalPrice?: FloatFilter<"Order"> | number
    items?: JsonFilter<"Order">
    address?: StringFilter<"Order"> | string
    notes?: StringNullableFilter<"Order"> | string | null
    estimatedDelivery?: DateTimeNullableFilter<"Order"> | Date | string | null
    actualDelivery?: DateTimeNullableFilter<"Order"> | Date | string | null
    latitude?: FloatNullableFilter<"Order"> | number | null
    longitude?: FloatNullableFilter<"Order"> | number | null
    customerId?: StringFilter<"Order"> | string
    businessId?: StringFilter<"Order"> | string
    courierId?: StringNullableFilter<"Order"> | string | null
    priority?: EnumDeliveryPriorityFilter<"Order"> | $Enums.DeliveryPriority
    timeWindowId?: StringNullableFilter<"Order"> | string | null
    estimatedDuration?: IntNullableFilter<"Order"> | number | null
    estimatedDistance?: FloatNullableFilter<"Order"> | number | null
    sequenceNumber?: IntNullableFilter<"Order"> | number | null
    refundStatus?: StringNullableFilter<"Order"> | string | null
    cancellationStatus?: StringNullableFilter<"Order"> | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutCourierInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutCourierInput, NotificationUncheckedUpdateWithoutCourierInput>
    create: XOR<NotificationCreateWithoutCourierInput, NotificationUncheckedCreateWithoutCourierInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutCourierInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutCourierInput, NotificationUncheckedUpdateWithoutCourierInput>
  }

  export type NotificationUpdateManyWithWhereWithoutCourierInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutCourierInput>
  }

  export type NotificationPreferenceUpsertWithWhereUniqueWithoutCourierInput = {
    where: NotificationPreferenceWhereUniqueInput
    update: XOR<NotificationPreferenceUpdateWithoutCourierInput, NotificationPreferenceUncheckedUpdateWithoutCourierInput>
    create: XOR<NotificationPreferenceCreateWithoutCourierInput, NotificationPreferenceUncheckedCreateWithoutCourierInput>
  }

  export type NotificationPreferenceUpdateWithWhereUniqueWithoutCourierInput = {
    where: NotificationPreferenceWhereUniqueInput
    data: XOR<NotificationPreferenceUpdateWithoutCourierInput, NotificationPreferenceUncheckedUpdateWithoutCourierInput>
  }

  export type NotificationPreferenceUpdateManyWithWhereWithoutCourierInput = {
    where: NotificationPreferenceScalarWhereInput
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyWithoutCourierInput>
  }

  export type DeliveryLogUpsertWithWhereUniqueWithoutCourierInput = {
    where: DeliveryLogWhereUniqueInput
    update: XOR<DeliveryLogUpdateWithoutCourierInput, DeliveryLogUncheckedUpdateWithoutCourierInput>
    create: XOR<DeliveryLogCreateWithoutCourierInput, DeliveryLogUncheckedCreateWithoutCourierInput>
  }

  export type DeliveryLogUpdateWithWhereUniqueWithoutCourierInput = {
    where: DeliveryLogWhereUniqueInput
    data: XOR<DeliveryLogUpdateWithoutCourierInput, DeliveryLogUncheckedUpdateWithoutCourierInput>
  }

  export type DeliveryLogUpdateManyWithWhereWithoutCourierInput = {
    where: DeliveryLogScalarWhereInput
    data: XOR<DeliveryLogUpdateManyMutationInput, DeliveryLogUncheckedUpdateManyWithoutCourierInput>
  }

  export type DeliveryLogScalarWhereInput = {
    AND?: DeliveryLogScalarWhereInput | DeliveryLogScalarWhereInput[]
    OR?: DeliveryLogScalarWhereInput[]
    NOT?: DeliveryLogScalarWhereInput | DeliveryLogScalarWhereInput[]
    id?: StringFilter<"DeliveryLog"> | string
    courierId?: StringFilter<"DeliveryLog"> | string
    action?: StringFilter<"DeliveryLog"> | string
    timestamp?: DateTimeFilter<"DeliveryLog"> | Date | string
    latitude?: FloatNullableFilter<"DeliveryLog"> | number | null
    longitude?: FloatNullableFilter<"DeliveryLog"> | number | null
    note?: StringNullableFilter<"DeliveryLog"> | string | null
    metadata?: JsonNullableFilter<"DeliveryLog">
  }

  export type DeliveryUpsertWithWhereUniqueWithoutCourierInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutCourierInput, DeliveryUncheckedUpdateWithoutCourierInput>
    create: XOR<DeliveryCreateWithoutCourierInput, DeliveryUncheckedCreateWithoutCourierInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutCourierInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutCourierInput, DeliveryUncheckedUpdateWithoutCourierInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutCourierInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutCourierInput>
  }

  export type DeliveryScalarWhereInput = {
    AND?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
    OR?: DeliveryScalarWhereInput[]
    NOT?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
    id?: StringFilter<"Delivery"> | string
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
    status?: StringFilter<"Delivery"> | string
    courierId?: StringFilter<"Delivery"> | string
    customerId?: StringFilter<"Delivery"> | string
    zoneId?: StringFilter<"Delivery"> | string
    orderId?: StringNullableFilter<"Delivery"> | string | null
    assignedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    pickedUpAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    estimatedPickupTime?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    estimatedDeliveryTime?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    duration?: IntNullableFilter<"Delivery"> | number | null
    actualDuration?: IntNullableFilter<"Delivery"> | number | null
    distance?: FloatNullableFilter<"Delivery"> | number | null
    actualDistance?: FloatNullableFilter<"Delivery"> | number | null
    pickupLatitude?: FloatNullableFilter<"Delivery"> | number | null
    pickupLongitude?: FloatNullableFilter<"Delivery"> | number | null
    dropoffLatitude?: FloatNullableFilter<"Delivery"> | number | null
    dropoffLongitude?: FloatNullableFilter<"Delivery"> | number | null
    routeId?: StringNullableFilter<"Delivery"> | string | null
    sequenceNumber?: IntNullableFilter<"Delivery"> | number | null
    priority?: EnumDeliveryPriorityFilter<"Delivery"> | $Enums.DeliveryPriority
  }

  export type PaymentUpsertWithWhereUniqueWithoutRecipientInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutRecipientInput, PaymentUncheckedUpdateWithoutRecipientInput>
    create: XOR<PaymentCreateWithoutRecipientInput, PaymentUncheckedCreateWithoutRecipientInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutRecipientInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutRecipientInput, PaymentUncheckedUpdateWithoutRecipientInput>
  }

  export type PaymentUpdateManyWithWhereWithoutRecipientInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutRecipientInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    reference?: StringNullableFilter<"Payment"> | string | null
    description?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    orderId?: StringNullableFilter<"Payment"> | string | null
    recipientId?: StringNullableFilter<"Payment"> | string | null
    businessId?: StringNullableFilter<"Payment"> | string | null
  }

  export type CourierAvailabilityUpsertWithWhereUniqueWithoutCourierInput = {
    where: CourierAvailabilityWhereUniqueInput
    update: XOR<CourierAvailabilityUpdateWithoutCourierInput, CourierAvailabilityUncheckedUpdateWithoutCourierInput>
    create: XOR<CourierAvailabilityCreateWithoutCourierInput, CourierAvailabilityUncheckedCreateWithoutCourierInput>
  }

  export type CourierAvailabilityUpdateWithWhereUniqueWithoutCourierInput = {
    where: CourierAvailabilityWhereUniqueInput
    data: XOR<CourierAvailabilityUpdateWithoutCourierInput, CourierAvailabilityUncheckedUpdateWithoutCourierInput>
  }

  export type CourierAvailabilityUpdateManyWithWhereWithoutCourierInput = {
    where: CourierAvailabilityScalarWhereInput
    data: XOR<CourierAvailabilityUpdateManyMutationInput, CourierAvailabilityUncheckedUpdateManyWithoutCourierInput>
  }

  export type CourierAvailabilityScalarWhereInput = {
    AND?: CourierAvailabilityScalarWhereInput | CourierAvailabilityScalarWhereInput[]
    OR?: CourierAvailabilityScalarWhereInput[]
    NOT?: CourierAvailabilityScalarWhereInput | CourierAvailabilityScalarWhereInput[]
    id?: StringFilter<"CourierAvailability"> | string
    courierId?: StringFilter<"CourierAvailability"> | string
    status?: EnumCourierAvailabilityStatusFilter<"CourierAvailability"> | $Enums.CourierAvailabilityStatus
    startTime?: DateTimeFilter<"CourierAvailability"> | Date | string
    endTime?: DateTimeNullableFilter<"CourierAvailability"> | Date | string | null
    note?: StringNullableFilter<"CourierAvailability"> | string | null
    createdAt?: DateTimeFilter<"CourierAvailability"> | Date | string
  }

  export type DeliveryRouteUpsertWithWhereUniqueWithoutCourierInput = {
    where: DeliveryRouteWhereUniqueInput
    update: XOR<DeliveryRouteUpdateWithoutCourierInput, DeliveryRouteUncheckedUpdateWithoutCourierInput>
    create: XOR<DeliveryRouteCreateWithoutCourierInput, DeliveryRouteUncheckedCreateWithoutCourierInput>
  }

  export type DeliveryRouteUpdateWithWhereUniqueWithoutCourierInput = {
    where: DeliveryRouteWhereUniqueInput
    data: XOR<DeliveryRouteUpdateWithoutCourierInput, DeliveryRouteUncheckedUpdateWithoutCourierInput>
  }

  export type DeliveryRouteUpdateManyWithWhereWithoutCourierInput = {
    where: DeliveryRouteScalarWhereInput
    data: XOR<DeliveryRouteUpdateManyMutationInput, DeliveryRouteUncheckedUpdateManyWithoutCourierInput>
  }

  export type DeliveryRouteScalarWhereInput = {
    AND?: DeliveryRouteScalarWhereInput | DeliveryRouteScalarWhereInput[]
    OR?: DeliveryRouteScalarWhereInput[]
    NOT?: DeliveryRouteScalarWhereInput | DeliveryRouteScalarWhereInput[]
    id?: StringFilter<"DeliveryRoute"> | string
    courierId?: StringFilter<"DeliveryRoute"> | string
    name?: StringNullableFilter<"DeliveryRoute"> | string | null
    createdAt?: DateTimeFilter<"DeliveryRoute"> | Date | string
    startedAt?: DateTimeNullableFilter<"DeliveryRoute"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DeliveryRoute"> | Date | string | null
    status?: EnumStatusFilter<"DeliveryRoute"> | $Enums.Status
    totalDistance?: FloatNullableFilter<"DeliveryRoute"> | number | null
    totalDuration?: IntNullableFilter<"DeliveryRoute"> | number | null
    startLatitude?: FloatNullableFilter<"DeliveryRoute"> | number | null
    startLongitude?: FloatNullableFilter<"DeliveryRoute"> | number | null
    endLatitude?: FloatNullableFilter<"DeliveryRoute"> | number | null
    endLongitude?: FloatNullableFilter<"DeliveryRoute"> | number | null
    routePath?: JsonNullableFilter<"DeliveryRoute">
  }

  export type CustomerCreateWithoutOrdersInput = {
    id?: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    deliveries?: DeliveryCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: string
    userId: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type BusinessCreateWithoutOrdersInput = {
    id?: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    user: UserCreateNestedOneWithoutBusinessInput
    zone?: ZoneCreateNestedOneWithoutBusinessesInput
    inventory?: InventoryCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBusinessInput
    payments?: PaymentCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutOrdersInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    zoneId?: string | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    inventory?: InventoryUncheckedCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBusinessInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyUncheckedCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutOrdersInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutOrdersInput, BusinessUncheckedCreateWithoutOrdersInput>
  }

  export type CourierCreateWithoutOrdersInput = {
    id?: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    user: UserCreateNestedOneWithoutCourierInput
    zone?: ZoneCreateNestedOneWithoutCouriersInput
    notifications?: NotificationCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    payments?: PaymentCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteCreateNestedManyWithoutCourierInput
  }

  export type CourierUncheckedCreateWithoutOrdersInput = {
    id?: string
    userId: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    zoneId?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityUncheckedCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteUncheckedCreateNestedManyWithoutCourierInput
  }

  export type CourierCreateOrConnectWithoutOrdersInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutOrdersInput, CourierUncheckedCreateWithoutOrdersInput>
  }

  export type NotificationCreateWithoutOrderInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutNotificationsInput
    courier?: CourierCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutOrderInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    userId: string
    courierId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateOrConnectWithoutOrderInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutOrderInput, NotificationUncheckedCreateWithoutOrderInput>
  }

  export type NotificationCreateManyOrderInputEnvelope = {
    data: NotificationCreateManyOrderInput | NotificationCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    recipient?: CourierCreateNestedOneWithoutPaymentsInput
    business?: BusinessCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    recipientId?: string | null
    businessId?: string | null
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentCreateManyOrderInputEnvelope = {
    data: PaymentCreateManyOrderInput | PaymentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryTimeWindowCreateWithoutOrdersInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    description?: string | null
    priorityFactor?: number
  }

  export type DeliveryTimeWindowUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    description?: string | null
    priorityFactor?: number
  }

  export type DeliveryTimeWindowCreateOrConnectWithoutOrdersInput = {
    where: DeliveryTimeWindowWhereUniqueInput
    create: XOR<DeliveryTimeWindowCreateWithoutOrdersInput, DeliveryTimeWindowUncheckedCreateWithoutOrdersInput>
  }

  export type DeliveryCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
    courier: CourierCreateNestedOneWithoutDeliveriesInput
    customer: CustomerCreateNestedOneWithoutDeliveriesInput
    zone: ZoneCreateNestedOneWithoutDeliveriesInput
    route?: DeliveryRouteCreateNestedOneWithoutDeliveriesInput
  }

  export type DeliveryUncheckedCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    courierId: string
    customerId: string
    zoneId: string
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    routeId?: string | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
  }

  export type DeliveryCreateOrConnectWithoutOrderInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput>
  }

  export type RefundRequestCreateWithoutOrderInput = {
    id?: string
    status?: $Enums.RefundRequestStatus
    reason: $Enums.RefundReason
    otherReason?: string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: number | null
    approvedAmount?: number | null
    evidenceUrls?: RefundRequestCreateevidenceUrlsInput | string[]
    adminNotes?: string | null
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    refundedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutRefundRequestsInput
    business: BusinessCreateNestedOneWithoutRefundRequestsInput
  }

  export type RefundRequestUncheckedCreateWithoutOrderInput = {
    id?: string
    customerId: string
    businessId: string
    status?: $Enums.RefundRequestStatus
    reason: $Enums.RefundReason
    otherReason?: string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: number | null
    approvedAmount?: number | null
    evidenceUrls?: RefundRequestCreateevidenceUrlsInput | string[]
    adminNotes?: string | null
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    refundedAt?: Date | string | null
  }

  export type RefundRequestCreateOrConnectWithoutOrderInput = {
    where: RefundRequestWhereUniqueInput
    create: XOR<RefundRequestCreateWithoutOrderInput, RefundRequestUncheckedCreateWithoutOrderInput>
  }

  export type RefundRequestCreateManyOrderInputEnvelope = {
    data: RefundRequestCreateManyOrderInput | RefundRequestCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CancellationRequestCreateWithoutOrderInput = {
    id?: string
    status?: $Enums.CancellationRequestStatus
    reason: $Enums.CancellationReason
    otherReason?: string | null
    cancellationFee?: number | null
    autoProcessed?: boolean
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    cancelledAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutCancellationRequestsInput
    business: BusinessCreateNestedOneWithoutCancellationRequestsInput
  }

  export type CancellationRequestUncheckedCreateWithoutOrderInput = {
    id?: string
    customerId: string
    businessId: string
    status?: $Enums.CancellationRequestStatus
    reason: $Enums.CancellationReason
    otherReason?: string | null
    cancellationFee?: number | null
    autoProcessed?: boolean
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    cancelledAt?: Date | string | null
  }

  export type CancellationRequestCreateOrConnectWithoutOrderInput = {
    where: CancellationRequestWhereUniqueInput
    create: XOR<CancellationRequestCreateWithoutOrderInput, CancellationRequestUncheckedCreateWithoutOrderInput>
  }

  export type CancellationRequestCreateManyOrderInputEnvelope = {
    data: CancellationRequestCreateManyOrderInput | CancellationRequestCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    deliveries?: DeliveryUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: DeliveryUncheckedUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type BusinessUpsertWithoutOrdersInput = {
    update: XOR<BusinessUpdateWithoutOrdersInput, BusinessUncheckedUpdateWithoutOrdersInput>
    create: XOR<BusinessCreateWithoutOrdersInput, BusinessUncheckedCreateWithoutOrdersInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutOrdersInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutOrdersInput, BusinessUncheckedUpdateWithoutOrdersInput>
  }

  export type BusinessUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    zone?: ZoneUpdateOneWithoutBusinessesNestedInput
    inventory?: InventoryUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    inventory?: InventoryUncheckedUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUncheckedUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type CourierUpsertWithoutOrdersInput = {
    update: XOR<CourierUpdateWithoutOrdersInput, CourierUncheckedUpdateWithoutOrdersInput>
    create: XOR<CourierCreateWithoutOrdersInput, CourierUncheckedCreateWithoutOrdersInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutOrdersInput, CourierUncheckedUpdateWithoutOrdersInput>
  }

  export type CourierUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    zone?: ZoneUpdateOneWithoutCouriersNestedInput
    notifications?: NotificationUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    payments?: PaymentUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUpdateManyWithoutCourierNestedInput
  }

  export type CourierUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    notifications?: NotificationUncheckedUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUncheckedUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUncheckedUpdateManyWithoutCourierNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutOrderInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutOrderInput, NotificationUncheckedUpdateWithoutOrderInput>
    create: XOR<NotificationCreateWithoutOrderInput, NotificationUncheckedCreateWithoutOrderInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutOrderInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutOrderInput, NotificationUncheckedUpdateWithoutOrderInput>
  }

  export type NotificationUpdateManyWithWhereWithoutOrderInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrderInput>
  }

  export type DeliveryTimeWindowUpsertWithoutOrdersInput = {
    update: XOR<DeliveryTimeWindowUpdateWithoutOrdersInput, DeliveryTimeWindowUncheckedUpdateWithoutOrdersInput>
    create: XOR<DeliveryTimeWindowCreateWithoutOrdersInput, DeliveryTimeWindowUncheckedCreateWithoutOrdersInput>
    where?: DeliveryTimeWindowWhereInput
  }

  export type DeliveryTimeWindowUpdateToOneWithWhereWithoutOrdersInput = {
    where?: DeliveryTimeWindowWhereInput
    data: XOR<DeliveryTimeWindowUpdateWithoutOrdersInput, DeliveryTimeWindowUncheckedUpdateWithoutOrdersInput>
  }

  export type DeliveryTimeWindowUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorityFactor?: FloatFieldUpdateOperationsInput | number
  }

  export type DeliveryTimeWindowUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priorityFactor?: FloatFieldUpdateOperationsInput | number
  }

  export type DeliveryUpsertWithoutOrderInput = {
    update: XOR<DeliveryUpdateWithoutOrderInput, DeliveryUncheckedUpdateWithoutOrderInput>
    create: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput>
    where?: DeliveryWhereInput
  }

  export type DeliveryUpdateToOneWithWhereWithoutOrderInput = {
    where?: DeliveryWhereInput
    data: XOR<DeliveryUpdateWithoutOrderInput, DeliveryUncheckedUpdateWithoutOrderInput>
  }

  export type DeliveryUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    courier?: CourierUpdateOneRequiredWithoutDeliveriesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutDeliveriesNestedInput
    zone?: ZoneUpdateOneRequiredWithoutDeliveriesNestedInput
    route?: DeliveryRouteUpdateOneWithoutDeliveriesNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
  }

  export type RefundRequestUpsertWithWhereUniqueWithoutOrderInput = {
    where: RefundRequestWhereUniqueInput
    update: XOR<RefundRequestUpdateWithoutOrderInput, RefundRequestUncheckedUpdateWithoutOrderInput>
    create: XOR<RefundRequestCreateWithoutOrderInput, RefundRequestUncheckedCreateWithoutOrderInput>
  }

  export type RefundRequestUpdateWithWhereUniqueWithoutOrderInput = {
    where: RefundRequestWhereUniqueInput
    data: XOR<RefundRequestUpdateWithoutOrderInput, RefundRequestUncheckedUpdateWithoutOrderInput>
  }

  export type RefundRequestUpdateManyWithWhereWithoutOrderInput = {
    where: RefundRequestScalarWhereInput
    data: XOR<RefundRequestUpdateManyMutationInput, RefundRequestUncheckedUpdateManyWithoutOrderInput>
  }

  export type RefundRequestScalarWhereInput = {
    AND?: RefundRequestScalarWhereInput | RefundRequestScalarWhereInput[]
    OR?: RefundRequestScalarWhereInput[]
    NOT?: RefundRequestScalarWhereInput | RefundRequestScalarWhereInput[]
    id?: StringFilter<"RefundRequest"> | string
    orderId?: StringFilter<"RefundRequest"> | string
    customerId?: StringFilter<"RefundRequest"> | string
    businessId?: StringFilter<"RefundRequest"> | string
    status?: EnumRefundRequestStatusFilter<"RefundRequest"> | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFilter<"RefundRequest"> | $Enums.RefundReason
    otherReason?: StringNullableFilter<"RefundRequest"> | string | null
    requestedItems?: JsonNullableFilter<"RefundRequest">
    refundAmount?: FloatNullableFilter<"RefundRequest"> | number | null
    approvedAmount?: FloatNullableFilter<"RefundRequest"> | number | null
    evidenceUrls?: StringNullableListFilter<"RefundRequest">
    adminNotes?: StringNullableFilter<"RefundRequest"> | string | null
    customerNotes?: StringNullableFilter<"RefundRequest"> | string | null
    businessNotes?: StringNullableFilter<"RefundRequest"> | string | null
    createdAt?: DateTimeFilter<"RefundRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RefundRequest"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"RefundRequest"> | Date | string | null
    reviewedBy?: StringNullableFilter<"RefundRequest"> | string | null
    refundedAt?: DateTimeNullableFilter<"RefundRequest"> | Date | string | null
  }

  export type CancellationRequestUpsertWithWhereUniqueWithoutOrderInput = {
    where: CancellationRequestWhereUniqueInput
    update: XOR<CancellationRequestUpdateWithoutOrderInput, CancellationRequestUncheckedUpdateWithoutOrderInput>
    create: XOR<CancellationRequestCreateWithoutOrderInput, CancellationRequestUncheckedCreateWithoutOrderInput>
  }

  export type CancellationRequestUpdateWithWhereUniqueWithoutOrderInput = {
    where: CancellationRequestWhereUniqueInput
    data: XOR<CancellationRequestUpdateWithoutOrderInput, CancellationRequestUncheckedUpdateWithoutOrderInput>
  }

  export type CancellationRequestUpdateManyWithWhereWithoutOrderInput = {
    where: CancellationRequestScalarWhereInput
    data: XOR<CancellationRequestUpdateManyMutationInput, CancellationRequestUncheckedUpdateManyWithoutOrderInput>
  }

  export type CancellationRequestScalarWhereInput = {
    AND?: CancellationRequestScalarWhereInput | CancellationRequestScalarWhereInput[]
    OR?: CancellationRequestScalarWhereInput[]
    NOT?: CancellationRequestScalarWhereInput | CancellationRequestScalarWhereInput[]
    id?: StringFilter<"CancellationRequest"> | string
    orderId?: StringFilter<"CancellationRequest"> | string
    customerId?: StringFilter<"CancellationRequest"> | string
    businessId?: StringFilter<"CancellationRequest"> | string
    status?: EnumCancellationRequestStatusFilter<"CancellationRequest"> | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFilter<"CancellationRequest"> | $Enums.CancellationReason
    otherReason?: StringNullableFilter<"CancellationRequest"> | string | null
    cancellationFee?: FloatNullableFilter<"CancellationRequest"> | number | null
    autoProcessed?: BoolFilter<"CancellationRequest"> | boolean
    customerNotes?: StringNullableFilter<"CancellationRequest"> | string | null
    businessNotes?: StringNullableFilter<"CancellationRequest"> | string | null
    createdAt?: DateTimeFilter<"CancellationRequest"> | Date | string
    updatedAt?: DateTimeFilter<"CancellationRequest"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"CancellationRequest"> | Date | string | null
    reviewedBy?: StringNullableFilter<"CancellationRequest"> | string | null
    cancelledAt?: DateTimeNullableFilter<"CancellationRequest"> | Date | string | null
  }

  export type UserCreateWithoutCustomerInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutUserInput
    business?: BusinessCreateNestedOneWithoutUserInput
    courier?: CourierCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomerInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    business?: BusinessUncheckedCreateNestedOneWithoutUserInput
    courier?: CourierUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    priority?: $Enums.DeliveryPriority
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    business: BusinessCreateNestedOneWithoutOrdersInput
    courier?: CourierCreateNestedOneWithoutOrdersInput
    notifications?: NotificationCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    requestedTimeWindow?: DeliveryTimeWindowCreateNestedOneWithoutOrdersInput
    delivery?: DeliveryCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    businessId: string
    courierId?: string | null
    priority?: $Enums.DeliveryPriority
    timeWindowId?: string | null
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    delivery?: DeliveryUncheckedCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
    courier: CourierCreateNestedOneWithoutDeliveriesInput
    zone: ZoneCreateNestedOneWithoutDeliveriesInput
    order?: OrderCreateNestedOneWithoutDeliveryInput
    route?: DeliveryRouteCreateNestedOneWithoutDeliveriesInput
  }

  export type DeliveryUncheckedCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    courierId: string
    zoneId: string
    orderId?: string | null
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    routeId?: string | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
  }

  export type DeliveryCreateOrConnectWithoutCustomerInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutCustomerInput, DeliveryUncheckedCreateWithoutCustomerInput>
  }

  export type DeliveryCreateManyCustomerInputEnvelope = {
    data: DeliveryCreateManyCustomerInput | DeliveryCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerAddressCreateWithoutCustomerInput = {
    id?: string
    title: string
    firstName: string
    lastName: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    postalCode: string
    country?: string
    phone?: string | null
    notes?: string | null
    latitude?: number | null
    longitude?: number | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressUncheckedCreateWithoutCustomerInput = {
    id?: string
    title: string
    firstName: string
    lastName: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    postalCode: string
    country?: string
    phone?: string | null
    notes?: string | null
    latitude?: number | null
    longitude?: number | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressCreateOrConnectWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    create: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAddressCreateManyCustomerInputEnvelope = {
    data: CustomerAddressCreateManyCustomerInput | CustomerAddressCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type RefundRequestCreateWithoutCustomerInput = {
    id?: string
    status?: $Enums.RefundRequestStatus
    reason: $Enums.RefundReason
    otherReason?: string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: number | null
    approvedAmount?: number | null
    evidenceUrls?: RefundRequestCreateevidenceUrlsInput | string[]
    adminNotes?: string | null
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    refundedAt?: Date | string | null
    order: OrderCreateNestedOneWithoutRefundRequestsInput
    business: BusinessCreateNestedOneWithoutRefundRequestsInput
  }

  export type RefundRequestUncheckedCreateWithoutCustomerInput = {
    id?: string
    orderId: string
    businessId: string
    status?: $Enums.RefundRequestStatus
    reason: $Enums.RefundReason
    otherReason?: string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: number | null
    approvedAmount?: number | null
    evidenceUrls?: RefundRequestCreateevidenceUrlsInput | string[]
    adminNotes?: string | null
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    refundedAt?: Date | string | null
  }

  export type RefundRequestCreateOrConnectWithoutCustomerInput = {
    where: RefundRequestWhereUniqueInput
    create: XOR<RefundRequestCreateWithoutCustomerInput, RefundRequestUncheckedCreateWithoutCustomerInput>
  }

  export type RefundRequestCreateManyCustomerInputEnvelope = {
    data: RefundRequestCreateManyCustomerInput | RefundRequestCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CancellationRequestCreateWithoutCustomerInput = {
    id?: string
    status?: $Enums.CancellationRequestStatus
    reason: $Enums.CancellationReason
    otherReason?: string | null
    cancellationFee?: number | null
    autoProcessed?: boolean
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    cancelledAt?: Date | string | null
    order: OrderCreateNestedOneWithoutCancellationRequestsInput
    business: BusinessCreateNestedOneWithoutCancellationRequestsInput
  }

  export type CancellationRequestUncheckedCreateWithoutCustomerInput = {
    id?: string
    orderId: string
    businessId: string
    status?: $Enums.CancellationRequestStatus
    reason: $Enums.CancellationReason
    otherReason?: string | null
    cancellationFee?: number | null
    autoProcessed?: boolean
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    cancelledAt?: Date | string | null
  }

  export type CancellationRequestCreateOrConnectWithoutCustomerInput = {
    where: CancellationRequestWhereUniqueInput
    create: XOR<CancellationRequestCreateWithoutCustomerInput, CancellationRequestUncheckedCreateWithoutCustomerInput>
  }

  export type CancellationRequestCreateManyCustomerInputEnvelope = {
    data: CancellationRequestCreateManyCustomerInput | CancellationRequestCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SavedPaymentMethodCreateWithoutCustomerInput = {
    id?: string
    type: $Enums.PaymentMethod
    provider: $Enums.PaymentProvider
    isDefault?: boolean
    nickName?: string | null
    cardBrand?: $Enums.CardBrand | null
    cardLast4?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    cardHolderName?: string | null
    bankName?: string | null
    bankAccountLast4?: string | null
    externalId?: string | null
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutSavedPaymentMethodInput
  }

  export type SavedPaymentMethodUncheckedCreateWithoutCustomerInput = {
    id?: string
    type: $Enums.PaymentMethod
    provider: $Enums.PaymentProvider
    isDefault?: boolean
    nickName?: string | null
    cardBrand?: $Enums.CardBrand | null
    cardLast4?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    cardHolderName?: string | null
    bankName?: string | null
    bankAccountLast4?: string | null
    externalId?: string | null
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutSavedPaymentMethodInput
  }

  export type SavedPaymentMethodCreateOrConnectWithoutCustomerInput = {
    where: SavedPaymentMethodWhereUniqueInput
    create: XOR<SavedPaymentMethodCreateWithoutCustomerInput, SavedPaymentMethodUncheckedCreateWithoutCustomerInput>
  }

  export type SavedPaymentMethodCreateManyCustomerInputEnvelope = {
    data: SavedPaymentMethodCreateManyCustomerInput | SavedPaymentMethodCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutCustomerInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    savedPaymentMethod?: SavedPaymentMethodCreateNestedOneWithoutSubscriptionsInput
    recurringPayments?: RecurringPaymentCreateNestedManyWithoutSubscriptionInput
    business?: BusinessCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutCustomerInput = {
    id?: string
    planId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    savedPaymentMethodId?: string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessId?: string | null
    recurringPayments?: RecurringPaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutCustomerInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput>
  }

  export type SubscriptionCreateManyCustomerInputEnvelope = {
    data: SubscriptionCreateManyCustomerInput | SubscriptionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCustomerInput = {
    update: XOR<UserUpdateWithoutCustomerInput, UserUncheckedUpdateWithoutCustomerInput>
    create: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomerInput, UserUncheckedUpdateWithoutCustomerInput>
  }

  export type UserUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    business?: BusinessUpdateOneWithoutUserNestedInput
    courier?: CourierUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    business?: BusinessUncheckedUpdateOneWithoutUserNestedInput
    courier?: CourierUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type DeliveryUpsertWithWhereUniqueWithoutCustomerInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutCustomerInput, DeliveryUncheckedUpdateWithoutCustomerInput>
    create: XOR<DeliveryCreateWithoutCustomerInput, DeliveryUncheckedCreateWithoutCustomerInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutCustomerInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutCustomerInput, DeliveryUncheckedUpdateWithoutCustomerInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutCustomerInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    update: XOR<CustomerAddressUpdateWithoutCustomerInput, CustomerAddressUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    data: XOR<CustomerAddressUpdateWithoutCustomerInput, CustomerAddressUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerAddressUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerAddressScalarWhereInput
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerAddressScalarWhereInput = {
    AND?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
    OR?: CustomerAddressScalarWhereInput[]
    NOT?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
    id?: StringFilter<"CustomerAddress"> | string
    customerId?: StringFilter<"CustomerAddress"> | string
    title?: StringFilter<"CustomerAddress"> | string
    firstName?: StringFilter<"CustomerAddress"> | string
    lastName?: StringFilter<"CustomerAddress"> | string
    addressLine1?: StringFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableFilter<"CustomerAddress"> | string | null
    city?: StringFilter<"CustomerAddress"> | string
    state?: StringNullableFilter<"CustomerAddress"> | string | null
    postalCode?: StringFilter<"CustomerAddress"> | string
    country?: StringFilter<"CustomerAddress"> | string
    phone?: StringNullableFilter<"CustomerAddress"> | string | null
    notes?: StringNullableFilter<"CustomerAddress"> | string | null
    latitude?: FloatNullableFilter<"CustomerAddress"> | number | null
    longitude?: FloatNullableFilter<"CustomerAddress"> | number | null
    isDefault?: BoolFilter<"CustomerAddress"> | boolean
    isActive?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
  }

  export type RefundRequestUpsertWithWhereUniqueWithoutCustomerInput = {
    where: RefundRequestWhereUniqueInput
    update: XOR<RefundRequestUpdateWithoutCustomerInput, RefundRequestUncheckedUpdateWithoutCustomerInput>
    create: XOR<RefundRequestCreateWithoutCustomerInput, RefundRequestUncheckedCreateWithoutCustomerInput>
  }

  export type RefundRequestUpdateWithWhereUniqueWithoutCustomerInput = {
    where: RefundRequestWhereUniqueInput
    data: XOR<RefundRequestUpdateWithoutCustomerInput, RefundRequestUncheckedUpdateWithoutCustomerInput>
  }

  export type RefundRequestUpdateManyWithWhereWithoutCustomerInput = {
    where: RefundRequestScalarWhereInput
    data: XOR<RefundRequestUpdateManyMutationInput, RefundRequestUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CancellationRequestUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CancellationRequestWhereUniqueInput
    update: XOR<CancellationRequestUpdateWithoutCustomerInput, CancellationRequestUncheckedUpdateWithoutCustomerInput>
    create: XOR<CancellationRequestCreateWithoutCustomerInput, CancellationRequestUncheckedCreateWithoutCustomerInput>
  }

  export type CancellationRequestUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CancellationRequestWhereUniqueInput
    data: XOR<CancellationRequestUpdateWithoutCustomerInput, CancellationRequestUncheckedUpdateWithoutCustomerInput>
  }

  export type CancellationRequestUpdateManyWithWhereWithoutCustomerInput = {
    where: CancellationRequestScalarWhereInput
    data: XOR<CancellationRequestUpdateManyMutationInput, CancellationRequestUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SavedPaymentMethodUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SavedPaymentMethodWhereUniqueInput
    update: XOR<SavedPaymentMethodUpdateWithoutCustomerInput, SavedPaymentMethodUncheckedUpdateWithoutCustomerInput>
    create: XOR<SavedPaymentMethodCreateWithoutCustomerInput, SavedPaymentMethodUncheckedCreateWithoutCustomerInput>
  }

  export type SavedPaymentMethodUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SavedPaymentMethodWhereUniqueInput
    data: XOR<SavedPaymentMethodUpdateWithoutCustomerInput, SavedPaymentMethodUncheckedUpdateWithoutCustomerInput>
  }

  export type SavedPaymentMethodUpdateManyWithWhereWithoutCustomerInput = {
    where: SavedPaymentMethodScalarWhereInput
    data: XOR<SavedPaymentMethodUpdateManyMutationInput, SavedPaymentMethodUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SavedPaymentMethodScalarWhereInput = {
    AND?: SavedPaymentMethodScalarWhereInput | SavedPaymentMethodScalarWhereInput[]
    OR?: SavedPaymentMethodScalarWhereInput[]
    NOT?: SavedPaymentMethodScalarWhereInput | SavedPaymentMethodScalarWhereInput[]
    id?: StringFilter<"SavedPaymentMethod"> | string
    customerId?: StringFilter<"SavedPaymentMethod"> | string
    type?: EnumPaymentMethodFilter<"SavedPaymentMethod"> | $Enums.PaymentMethod
    provider?: EnumPaymentProviderFilter<"SavedPaymentMethod"> | $Enums.PaymentProvider
    isDefault?: BoolFilter<"SavedPaymentMethod"> | boolean
    nickName?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    cardBrand?: EnumCardBrandNullableFilter<"SavedPaymentMethod"> | $Enums.CardBrand | null
    cardLast4?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    cardExpMonth?: IntNullableFilter<"SavedPaymentMethod"> | number | null
    cardExpYear?: IntNullableFilter<"SavedPaymentMethod"> | number | null
    cardHolderName?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    bankName?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    bankAccountLast4?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    externalId?: StringNullableFilter<"SavedPaymentMethod"> | string | null
    isActive?: BoolFilter<"SavedPaymentMethod"> | boolean
    metadata?: JsonNullableFilter<"SavedPaymentMethod">
    createdAt?: DateTimeFilter<"SavedPaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"SavedPaymentMethod"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutCustomerInput, SubscriptionUncheckedUpdateWithoutCustomerInput>
    create: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutCustomerInput, SubscriptionUncheckedUpdateWithoutCustomerInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutCustomerInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    customerId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEndDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    resumeAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    nextBillingDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    savedPaymentMethodId?: StringNullableFilter<"Subscription"> | string | null
    quantity?: IntFilter<"Subscription"> | number
    autoRenew?: BoolFilter<"Subscription"> | boolean
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    metadata?: JsonNullableFilter<"Subscription">
    externalId?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    businessId?: StringNullableFilter<"Subscription"> | string | null
  }

  export type UserCreateWithoutBusinessInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutUserInput
    courier?: CourierCreateNestedOneWithoutUserInput
    customer?: CustomerCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBusinessInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    courier?: CourierUncheckedCreateNestedOneWithoutUserInput
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBusinessInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBusinessInput, UserUncheckedCreateWithoutBusinessInput>
  }

  export type ZoneCreateWithoutBusinessesInput = {
    id?: string
    name: string
    description?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    averageDeliveryTime?: number | null
    orderVolume?: number | null
    activeBusinesses?: number | null
    couriers?: CourierCreateNestedManyWithoutZoneInput
    deliveries?: DeliveryCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutBusinessesInput = {
    id?: string
    name: string
    description?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    averageDeliveryTime?: number | null
    orderVolume?: number | null
    activeBusinesses?: number | null
    couriers?: CourierUncheckedCreateNestedManyWithoutZoneInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutBusinessesInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutBusinessesInput, ZoneUncheckedCreateWithoutBusinessesInput>
  }

  export type InventoryCreateWithoutBusinessInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    price: number
    sku?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
  }

  export type InventoryUncheckedCreateWithoutBusinessInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    price: number
    sku?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
  }

  export type InventoryCreateOrConnectWithoutBusinessInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutBusinessInput, InventoryUncheckedCreateWithoutBusinessInput>
  }

  export type InventoryCreateManyBusinessInputEnvelope = {
    data: InventoryCreateManyBusinessInput | InventoryCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutBusinessInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    priority?: $Enums.DeliveryPriority
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    courier?: CourierCreateNestedOneWithoutOrdersInput
    notifications?: NotificationCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    requestedTimeWindow?: DeliveryTimeWindowCreateNestedOneWithoutOrdersInput
    delivery?: DeliveryCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutBusinessInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    customerId: string
    courierId?: string | null
    priority?: $Enums.DeliveryPriority
    timeWindowId?: string | null
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    delivery?: DeliveryUncheckedCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutBusinessInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutBusinessInput, OrderUncheckedCreateWithoutBusinessInput>
  }

  export type OrderCreateManyBusinessInputEnvelope = {
    data: OrderCreateManyBusinessInput | OrderCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type MenuItemCreateWithoutBusinessInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    imageUrl?: string | null
    category?: string | null
    tags?: MenuItemCreatetagsInput | string[]
    ingredients?: MenuItemCreateingredientsInput | string[]
    calories?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemUncheckedCreateWithoutBusinessInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    imageUrl?: string | null
    category?: string | null
    tags?: MenuItemCreatetagsInput | string[]
    ingredients?: MenuItemCreateingredientsInput | string[]
    calories?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemCreateOrConnectWithoutBusinessInput = {
    where: MenuItemWhereUniqueInput
    create: XOR<MenuItemCreateWithoutBusinessInput, MenuItemUncheckedCreateWithoutBusinessInput>
  }

  export type MenuItemCreateManyBusinessInputEnvelope = {
    data: MenuItemCreateManyBusinessInput | MenuItemCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryCreateWithoutBusinessInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    products?: InventoryCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutBusinessInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
    products?: InventoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutBusinessInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutBusinessInput, ProductCategoryUncheckedCreateWithoutBusinessInput>
  }

  export type ProductCategoryCreateManyBusinessInputEnvelope = {
    data: ProductCategoryCreateManyBusinessInput | ProductCategoryCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutBusinessInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    order?: OrderCreateNestedOneWithoutPaymentsInput
    recipient?: CourierCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutBusinessInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    orderId?: string | null
    recipientId?: string | null
  }

  export type PaymentCreateOrConnectWithoutBusinessInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBusinessInput, PaymentUncheckedCreateWithoutBusinessInput>
  }

  export type PaymentCreateManyBusinessInputEnvelope = {
    data: PaymentCreateManyBusinessInput | PaymentCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type RefundPolicyCreateWithoutBusinessInput = {
    id?: string
    name: string
    description?: string | null
    autoApproveTimeline?: number | null
    timeLimit?: number | null
    orderStatusRules?: NullableJsonNullValueInput | InputJsonValue
    productRules?: NullableJsonNullValueInput | InputJsonValue
    cancellationFees?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundPolicyUncheckedCreateWithoutBusinessInput = {
    id?: string
    name: string
    description?: string | null
    autoApproveTimeline?: number | null
    timeLimit?: number | null
    orderStatusRules?: NullableJsonNullValueInput | InputJsonValue
    productRules?: NullableJsonNullValueInput | InputJsonValue
    cancellationFees?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundPolicyCreateOrConnectWithoutBusinessInput = {
    where: RefundPolicyWhereUniqueInput
    create: XOR<RefundPolicyCreateWithoutBusinessInput, RefundPolicyUncheckedCreateWithoutBusinessInput>
  }

  export type RefundPolicyCreateManyBusinessInputEnvelope = {
    data: RefundPolicyCreateManyBusinessInput | RefundPolicyCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type RefundRequestCreateWithoutBusinessInput = {
    id?: string
    status?: $Enums.RefundRequestStatus
    reason: $Enums.RefundReason
    otherReason?: string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: number | null
    approvedAmount?: number | null
    evidenceUrls?: RefundRequestCreateevidenceUrlsInput | string[]
    adminNotes?: string | null
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    refundedAt?: Date | string | null
    order: OrderCreateNestedOneWithoutRefundRequestsInput
    customer: CustomerCreateNestedOneWithoutRefundRequestsInput
  }

  export type RefundRequestUncheckedCreateWithoutBusinessInput = {
    id?: string
    orderId: string
    customerId: string
    status?: $Enums.RefundRequestStatus
    reason: $Enums.RefundReason
    otherReason?: string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: number | null
    approvedAmount?: number | null
    evidenceUrls?: RefundRequestCreateevidenceUrlsInput | string[]
    adminNotes?: string | null
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    refundedAt?: Date | string | null
  }

  export type RefundRequestCreateOrConnectWithoutBusinessInput = {
    where: RefundRequestWhereUniqueInput
    create: XOR<RefundRequestCreateWithoutBusinessInput, RefundRequestUncheckedCreateWithoutBusinessInput>
  }

  export type RefundRequestCreateManyBusinessInputEnvelope = {
    data: RefundRequestCreateManyBusinessInput | RefundRequestCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type CancellationRequestCreateWithoutBusinessInput = {
    id?: string
    status?: $Enums.CancellationRequestStatus
    reason: $Enums.CancellationReason
    otherReason?: string | null
    cancellationFee?: number | null
    autoProcessed?: boolean
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    cancelledAt?: Date | string | null
    order: OrderCreateNestedOneWithoutCancellationRequestsInput
    customer: CustomerCreateNestedOneWithoutCancellationRequestsInput
  }

  export type CancellationRequestUncheckedCreateWithoutBusinessInput = {
    id?: string
    orderId: string
    customerId: string
    status?: $Enums.CancellationRequestStatus
    reason: $Enums.CancellationReason
    otherReason?: string | null
    cancellationFee?: number | null
    autoProcessed?: boolean
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    cancelledAt?: Date | string | null
  }

  export type CancellationRequestCreateOrConnectWithoutBusinessInput = {
    where: CancellationRequestWhereUniqueInput
    create: XOR<CancellationRequestCreateWithoutBusinessInput, CancellationRequestUncheckedCreateWithoutBusinessInput>
  }

  export type CancellationRequestCreateManyBusinessInputEnvelope = {
    data: CancellationRequestCreateManyBusinessInput | CancellationRequestCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionPlanCreateWithoutBusinessInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval?: $Enums.SubscriptionInterval
    intervalCount?: number
    trialPeriodDays?: number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUncheckedCreateWithoutBusinessInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval?: $Enums.SubscriptionInterval
    intervalCount?: number
    trialPeriodDays?: number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanCreateOrConnectWithoutBusinessInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutBusinessInput, SubscriptionPlanUncheckedCreateWithoutBusinessInput>
  }

  export type SubscriptionPlanCreateManyBusinessInputEnvelope = {
    data: SubscriptionPlanCreateManyBusinessInput | SubscriptionPlanCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutBusinessInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    savedPaymentMethod?: SavedPaymentMethodCreateNestedOneWithoutSubscriptionsInput
    recurringPayments?: RecurringPaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutBusinessInput = {
    id?: string
    customerId: string
    planId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    savedPaymentMethodId?: string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recurringPayments?: RecurringPaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutBusinessInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutBusinessInput, SubscriptionUncheckedCreateWithoutBusinessInput>
  }

  export type SubscriptionCreateManyBusinessInputEnvelope = {
    data: SubscriptionCreateManyBusinessInput | SubscriptionCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBusinessInput = {
    update: XOR<UserUpdateWithoutBusinessInput, UserUncheckedUpdateWithoutBusinessInput>
    create: XOR<UserCreateWithoutBusinessInput, UserUncheckedCreateWithoutBusinessInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBusinessInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBusinessInput, UserUncheckedUpdateWithoutBusinessInput>
  }

  export type UserUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    courier?: CourierUpdateOneWithoutUserNestedInput
    customer?: CustomerUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    courier?: CourierUncheckedUpdateOneWithoutUserNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ZoneUpsertWithoutBusinessesInput = {
    update: XOR<ZoneUpdateWithoutBusinessesInput, ZoneUncheckedUpdateWithoutBusinessesInput>
    create: XOR<ZoneCreateWithoutBusinessesInput, ZoneUncheckedCreateWithoutBusinessesInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutBusinessesInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutBusinessesInput, ZoneUncheckedUpdateWithoutBusinessesInput>
  }

  export type ZoneUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    averageDeliveryTime?: NullableIntFieldUpdateOperationsInput | number | null
    orderVolume?: NullableIntFieldUpdateOperationsInput | number | null
    activeBusinesses?: NullableIntFieldUpdateOperationsInput | number | null
    couriers?: CourierUpdateManyWithoutZoneNestedInput
    deliveries?: DeliveryUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    averageDeliveryTime?: NullableIntFieldUpdateOperationsInput | number | null
    orderVolume?: NullableIntFieldUpdateOperationsInput | number | null
    activeBusinesses?: NullableIntFieldUpdateOperationsInput | number | null
    couriers?: CourierUncheckedUpdateManyWithoutZoneNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type InventoryUpsertWithWhereUniqueWithoutBusinessInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutBusinessInput, InventoryUncheckedUpdateWithoutBusinessInput>
    create: XOR<InventoryCreateWithoutBusinessInput, InventoryUncheckedCreateWithoutBusinessInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutBusinessInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutBusinessInput, InventoryUncheckedUpdateWithoutBusinessInput>
  }

  export type InventoryUpdateManyWithWhereWithoutBusinessInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutBusinessInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    OR?: InventoryScalarWhereInput[]
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    id?: StringFilter<"Inventory"> | string
    businessId?: StringFilter<"Inventory"> | string
    name?: StringFilter<"Inventory"> | string
    description?: StringNullableFilter<"Inventory"> | string | null
    quantity?: IntFilter<"Inventory"> | number
    price?: FloatFilter<"Inventory"> | number
    sku?: StringNullableFilter<"Inventory"> | string | null
    imageUrl?: StringNullableFilter<"Inventory"> | string | null
    isActive?: BoolFilter<"Inventory"> | boolean
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    categoryId?: StringNullableFilter<"Inventory"> | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutBusinessInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutBusinessInput, OrderUncheckedUpdateWithoutBusinessInput>
    create: XOR<OrderCreateWithoutBusinessInput, OrderUncheckedCreateWithoutBusinessInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutBusinessInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutBusinessInput, OrderUncheckedUpdateWithoutBusinessInput>
  }

  export type OrderUpdateManyWithWhereWithoutBusinessInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutBusinessInput>
  }

  export type MenuItemUpsertWithWhereUniqueWithoutBusinessInput = {
    where: MenuItemWhereUniqueInput
    update: XOR<MenuItemUpdateWithoutBusinessInput, MenuItemUncheckedUpdateWithoutBusinessInput>
    create: XOR<MenuItemCreateWithoutBusinessInput, MenuItemUncheckedCreateWithoutBusinessInput>
  }

  export type MenuItemUpdateWithWhereUniqueWithoutBusinessInput = {
    where: MenuItemWhereUniqueInput
    data: XOR<MenuItemUpdateWithoutBusinessInput, MenuItemUncheckedUpdateWithoutBusinessInput>
  }

  export type MenuItemUpdateManyWithWhereWithoutBusinessInput = {
    where: MenuItemScalarWhereInput
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyWithoutBusinessInput>
  }

  export type MenuItemScalarWhereInput = {
    AND?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
    OR?: MenuItemScalarWhereInput[]
    NOT?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
    id?: StringFilter<"MenuItem"> | string
    businessId?: StringFilter<"MenuItem"> | string
    name?: StringFilter<"MenuItem"> | string
    description?: StringNullableFilter<"MenuItem"> | string | null
    price?: FloatFilter<"MenuItem"> | number
    imageUrl?: StringNullableFilter<"MenuItem"> | string | null
    category?: StringNullableFilter<"MenuItem"> | string | null
    tags?: StringNullableListFilter<"MenuItem">
    ingredients?: StringNullableListFilter<"MenuItem">
    calories?: IntNullableFilter<"MenuItem"> | number | null
    isActive?: BoolFilter<"MenuItem"> | boolean
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutBusinessInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutBusinessInput, ProductCategoryUncheckedUpdateWithoutBusinessInput>
    create: XOR<ProductCategoryCreateWithoutBusinessInput, ProductCategoryUncheckedCreateWithoutBusinessInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutBusinessInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutBusinessInput, ProductCategoryUncheckedUpdateWithoutBusinessInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutBusinessInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutBusinessInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    businessId?: StringFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    slug?: StringFilter<"ProductCategory"> | string
    imageUrl?: StringNullableFilter<"ProductCategory"> | string | null
    isActive?: BoolFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    parentId?: StringNullableFilter<"ProductCategory"> | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutBusinessInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBusinessInput, PaymentUncheckedUpdateWithoutBusinessInput>
    create: XOR<PaymentCreateWithoutBusinessInput, PaymentUncheckedCreateWithoutBusinessInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBusinessInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBusinessInput, PaymentUncheckedUpdateWithoutBusinessInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBusinessInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutBusinessInput>
  }

  export type RefundPolicyUpsertWithWhereUniqueWithoutBusinessInput = {
    where: RefundPolicyWhereUniqueInput
    update: XOR<RefundPolicyUpdateWithoutBusinessInput, RefundPolicyUncheckedUpdateWithoutBusinessInput>
    create: XOR<RefundPolicyCreateWithoutBusinessInput, RefundPolicyUncheckedCreateWithoutBusinessInput>
  }

  export type RefundPolicyUpdateWithWhereUniqueWithoutBusinessInput = {
    where: RefundPolicyWhereUniqueInput
    data: XOR<RefundPolicyUpdateWithoutBusinessInput, RefundPolicyUncheckedUpdateWithoutBusinessInput>
  }

  export type RefundPolicyUpdateManyWithWhereWithoutBusinessInput = {
    where: RefundPolicyScalarWhereInput
    data: XOR<RefundPolicyUpdateManyMutationInput, RefundPolicyUncheckedUpdateManyWithoutBusinessInput>
  }

  export type RefundPolicyScalarWhereInput = {
    AND?: RefundPolicyScalarWhereInput | RefundPolicyScalarWhereInput[]
    OR?: RefundPolicyScalarWhereInput[]
    NOT?: RefundPolicyScalarWhereInput | RefundPolicyScalarWhereInput[]
    id?: StringFilter<"RefundPolicy"> | string
    businessId?: StringFilter<"RefundPolicy"> | string
    name?: StringFilter<"RefundPolicy"> | string
    description?: StringNullableFilter<"RefundPolicy"> | string | null
    autoApproveTimeline?: IntNullableFilter<"RefundPolicy"> | number | null
    timeLimit?: IntNullableFilter<"RefundPolicy"> | number | null
    orderStatusRules?: JsonNullableFilter<"RefundPolicy">
    productRules?: JsonNullableFilter<"RefundPolicy">
    cancellationFees?: JsonNullableFilter<"RefundPolicy">
    isActive?: BoolFilter<"RefundPolicy"> | boolean
    createdAt?: DateTimeFilter<"RefundPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"RefundPolicy"> | Date | string
  }

  export type RefundRequestUpsertWithWhereUniqueWithoutBusinessInput = {
    where: RefundRequestWhereUniqueInput
    update: XOR<RefundRequestUpdateWithoutBusinessInput, RefundRequestUncheckedUpdateWithoutBusinessInput>
    create: XOR<RefundRequestCreateWithoutBusinessInput, RefundRequestUncheckedCreateWithoutBusinessInput>
  }

  export type RefundRequestUpdateWithWhereUniqueWithoutBusinessInput = {
    where: RefundRequestWhereUniqueInput
    data: XOR<RefundRequestUpdateWithoutBusinessInput, RefundRequestUncheckedUpdateWithoutBusinessInput>
  }

  export type RefundRequestUpdateManyWithWhereWithoutBusinessInput = {
    where: RefundRequestScalarWhereInput
    data: XOR<RefundRequestUpdateManyMutationInput, RefundRequestUncheckedUpdateManyWithoutBusinessInput>
  }

  export type CancellationRequestUpsertWithWhereUniqueWithoutBusinessInput = {
    where: CancellationRequestWhereUniqueInput
    update: XOR<CancellationRequestUpdateWithoutBusinessInput, CancellationRequestUncheckedUpdateWithoutBusinessInput>
    create: XOR<CancellationRequestCreateWithoutBusinessInput, CancellationRequestUncheckedCreateWithoutBusinessInput>
  }

  export type CancellationRequestUpdateWithWhereUniqueWithoutBusinessInput = {
    where: CancellationRequestWhereUniqueInput
    data: XOR<CancellationRequestUpdateWithoutBusinessInput, CancellationRequestUncheckedUpdateWithoutBusinessInput>
  }

  export type CancellationRequestUpdateManyWithWhereWithoutBusinessInput = {
    where: CancellationRequestScalarWhereInput
    data: XOR<CancellationRequestUpdateManyMutationInput, CancellationRequestUncheckedUpdateManyWithoutBusinessInput>
  }

  export type SubscriptionPlanUpsertWithWhereUniqueWithoutBusinessInput = {
    where: SubscriptionPlanWhereUniqueInput
    update: XOR<SubscriptionPlanUpdateWithoutBusinessInput, SubscriptionPlanUncheckedUpdateWithoutBusinessInput>
    create: XOR<SubscriptionPlanCreateWithoutBusinessInput, SubscriptionPlanUncheckedCreateWithoutBusinessInput>
  }

  export type SubscriptionPlanUpdateWithWhereUniqueWithoutBusinessInput = {
    where: SubscriptionPlanWhereUniqueInput
    data: XOR<SubscriptionPlanUpdateWithoutBusinessInput, SubscriptionPlanUncheckedUpdateWithoutBusinessInput>
  }

  export type SubscriptionPlanUpdateManyWithWhereWithoutBusinessInput = {
    where: SubscriptionPlanScalarWhereInput
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyWithoutBusinessInput>
  }

  export type SubscriptionPlanScalarWhereInput = {
    AND?: SubscriptionPlanScalarWhereInput | SubscriptionPlanScalarWhereInput[]
    OR?: SubscriptionPlanScalarWhereInput[]
    NOT?: SubscriptionPlanScalarWhereInput | SubscriptionPlanScalarWhereInput[]
    id?: StringFilter<"SubscriptionPlan"> | string
    name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    price?: FloatFilter<"SubscriptionPlan"> | number
    currency?: StringFilter<"SubscriptionPlan"> | string
    interval?: EnumSubscriptionIntervalFilter<"SubscriptionPlan"> | $Enums.SubscriptionInterval
    intervalCount?: IntFilter<"SubscriptionPlan"> | number
    trialPeriodDays?: IntNullableFilter<"SubscriptionPlan"> | number | null
    features?: JsonNullableFilter<"SubscriptionPlan">
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    businessId?: StringNullableFilter<"SubscriptionPlan"> | string | null
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutBusinessInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutBusinessInput, SubscriptionUncheckedUpdateWithoutBusinessInput>
    create: XOR<SubscriptionCreateWithoutBusinessInput, SubscriptionUncheckedCreateWithoutBusinessInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutBusinessInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutBusinessInput, SubscriptionUncheckedUpdateWithoutBusinessInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutBusinessInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutBusinessInput>
  }

  export type BusinessCreateWithoutZoneInput = {
    id?: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    user: UserCreateNestedOneWithoutBusinessInput
    inventory?: InventoryCreateNestedManyWithoutBusinessInput
    orders?: OrderCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBusinessInput
    payments?: PaymentCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutZoneInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    inventory?: InventoryUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrderUncheckedCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBusinessInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyUncheckedCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutZoneInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutZoneInput, BusinessUncheckedCreateWithoutZoneInput>
  }

  export type BusinessCreateManyZoneInputEnvelope = {
    data: BusinessCreateManyZoneInput | BusinessCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type CourierCreateWithoutZoneInput = {
    id?: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    user: UserCreateNestedOneWithoutCourierInput
    orders?: OrderCreateNestedManyWithoutCourierInput
    notifications?: NotificationCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    payments?: PaymentCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteCreateNestedManyWithoutCourierInput
  }

  export type CourierUncheckedCreateWithoutZoneInput = {
    id?: string
    userId: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedCreateNestedManyWithoutCourierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityUncheckedCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteUncheckedCreateNestedManyWithoutCourierInput
  }

  export type CourierCreateOrConnectWithoutZoneInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutZoneInput, CourierUncheckedCreateWithoutZoneInput>
  }

  export type CourierCreateManyZoneInputEnvelope = {
    data: CourierCreateManyZoneInput | CourierCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryCreateWithoutZoneInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
    courier: CourierCreateNestedOneWithoutDeliveriesInput
    customer: CustomerCreateNestedOneWithoutDeliveriesInput
    order?: OrderCreateNestedOneWithoutDeliveryInput
    route?: DeliveryRouteCreateNestedOneWithoutDeliveriesInput
  }

  export type DeliveryUncheckedCreateWithoutZoneInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    courierId: string
    customerId: string
    orderId?: string | null
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    routeId?: string | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
  }

  export type DeliveryCreateOrConnectWithoutZoneInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutZoneInput, DeliveryUncheckedCreateWithoutZoneInput>
  }

  export type DeliveryCreateManyZoneInputEnvelope = {
    data: DeliveryCreateManyZoneInput | DeliveryCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithWhereUniqueWithoutZoneInput = {
    where: BusinessWhereUniqueInput
    update: XOR<BusinessUpdateWithoutZoneInput, BusinessUncheckedUpdateWithoutZoneInput>
    create: XOR<BusinessCreateWithoutZoneInput, BusinessUncheckedCreateWithoutZoneInput>
  }

  export type BusinessUpdateWithWhereUniqueWithoutZoneInput = {
    where: BusinessWhereUniqueInput
    data: XOR<BusinessUpdateWithoutZoneInput, BusinessUncheckedUpdateWithoutZoneInput>
  }

  export type BusinessUpdateManyWithWhereWithoutZoneInput = {
    where: BusinessScalarWhereInput
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyWithoutZoneInput>
  }

  export type BusinessScalarWhereInput = {
    AND?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
    OR?: BusinessScalarWhereInput[]
    NOT?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
    id?: StringFilter<"Business"> | string
    userId?: StringFilter<"Business"> | string
    name?: StringFilter<"Business"> | string
    description?: StringNullableFilter<"Business"> | string | null
    address?: StringNullableFilter<"Business"> | string | null
    phone?: StringNullableFilter<"Business"> | string | null
    website?: StringNullableFilter<"Business"> | string | null
    email?: StringNullableFilter<"Business"> | string | null
    logoUrl?: StringNullableFilter<"Business"> | string | null
    coverUrl?: StringNullableFilter<"Business"> | string | null
    latitude?: FloatNullableFilter<"Business"> | number | null
    longitude?: FloatNullableFilter<"Business"> | number | null
    zoneId?: StringNullableFilter<"Business"> | string | null
    status?: EnumStatusFilter<"Business"> | $Enums.Status
    rating?: FloatNullableFilter<"Business"> | number | null
    tax_id?: StringNullableFilter<"Business"> | string | null
    bank_iban?: StringNullableFilter<"Business"> | string | null
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    openingTime?: StringNullableFilter<"Business"> | string | null
    closingTime?: StringNullableFilter<"Business"> | string | null
    deliveryRadius?: FloatNullableFilter<"Business"> | number | null
    deliveryFee?: FloatNullableFilter<"Business"> | number | null
    facebook?: StringNullableFilter<"Business"> | string | null
    instagram?: StringNullableFilter<"Business"> | string | null
    twitter?: StringNullableFilter<"Business"> | string | null
    type?: StringNullableFilter<"Business"> | string | null
    tags?: StringNullableListFilter<"Business">
    features?: StringNullableListFilter<"Business">
  }

  export type CourierUpsertWithWhereUniqueWithoutZoneInput = {
    where: CourierWhereUniqueInput
    update: XOR<CourierUpdateWithoutZoneInput, CourierUncheckedUpdateWithoutZoneInput>
    create: XOR<CourierCreateWithoutZoneInput, CourierUncheckedCreateWithoutZoneInput>
  }

  export type CourierUpdateWithWhereUniqueWithoutZoneInput = {
    where: CourierWhereUniqueInput
    data: XOR<CourierUpdateWithoutZoneInput, CourierUncheckedUpdateWithoutZoneInput>
  }

  export type CourierUpdateManyWithWhereWithoutZoneInput = {
    where: CourierScalarWhereInput
    data: XOR<CourierUpdateManyMutationInput, CourierUncheckedUpdateManyWithoutZoneInput>
  }

  export type CourierScalarWhereInput = {
    AND?: CourierScalarWhereInput | CourierScalarWhereInput[]
    OR?: CourierScalarWhereInput[]
    NOT?: CourierScalarWhereInput | CourierScalarWhereInput[]
    id?: StringFilter<"Courier"> | string
    userId?: StringFilter<"Courier"> | string
    status?: EnumStatusFilter<"Courier"> | $Enums.Status
    vehicleType?: StringNullableFilter<"Courier"> | string | null
    phone?: StringNullableFilter<"Courier"> | string | null
    zoneId?: StringNullableFilter<"Courier"> | string | null
    ratings?: FloatNullableFilter<"Courier"> | number | null
    currentLatitude?: FloatNullableFilter<"Courier"> | number | null
    currentLongitude?: FloatNullableFilter<"Courier"> | number | null
    lastLocationUpdate?: DateTimeNullableFilter<"Courier"> | Date | string | null
    availableFrom?: DateTimeNullableFilter<"Courier"> | Date | string | null
    availableTo?: DateTimeNullableFilter<"Courier"> | Date | string | null
    documentsVerified?: BoolFilter<"Courier"> | boolean
    backgroundChecked?: BoolFilter<"Courier"> | boolean
    maxDeliveriesPerDay?: IntFilter<"Courier"> | number
    maxDistance?: FloatNullableFilter<"Courier"> | number | null
    averageSpeed?: FloatNullableFilter<"Courier"> | number | null
    courierFee?: FloatNullableFilter<"Courier"> | number | null
    lastSeen?: DateTimeNullableFilter<"Courier"> | Date | string | null
    availabilityStatus?: EnumCourierAvailabilityStatusNullableFilter<"Courier"> | $Enums.CourierAvailabilityStatus | null
  }

  export type DeliveryUpsertWithWhereUniqueWithoutZoneInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutZoneInput, DeliveryUncheckedUpdateWithoutZoneInput>
    create: XOR<DeliveryCreateWithoutZoneInput, DeliveryUncheckedCreateWithoutZoneInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutZoneInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutZoneInput, DeliveryUncheckedUpdateWithoutZoneInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutZoneInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutZoneInput>
  }

  export type UserCreateWithoutNotificationPreferencesInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutUserInput
    business?: BusinessCreateNestedOneWithoutUserInput
    courier?: CourierCreateNestedOneWithoutUserInput
    customer?: CustomerCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationPreferencesInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    business?: BusinessUncheckedCreateNestedOneWithoutUserInput
    courier?: CourierUncheckedCreateNestedOneWithoutUserInput
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
  }

  export type CourierCreateWithoutNotificationPreferencesInput = {
    id?: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    user: UserCreateNestedOneWithoutCourierInput
    zone?: ZoneCreateNestedOneWithoutCouriersInput
    orders?: OrderCreateNestedManyWithoutCourierInput
    notifications?: NotificationCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    payments?: PaymentCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteCreateNestedManyWithoutCourierInput
  }

  export type CourierUncheckedCreateWithoutNotificationPreferencesInput = {
    id?: string
    userId: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    zoneId?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedCreateNestedManyWithoutCourierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityUncheckedCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteUncheckedCreateNestedManyWithoutCourierInput
  }

  export type CourierCreateOrConnectWithoutNotificationPreferencesInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutNotificationPreferencesInput, CourierUncheckedCreateWithoutNotificationPreferencesInput>
  }

  export type UserUpsertWithoutNotificationPreferencesInput = {
    update: XOR<UserUpdateWithoutNotificationPreferencesInput, UserUncheckedUpdateWithoutNotificationPreferencesInput>
    create: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationPreferencesInput, UserUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type UserUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    business?: BusinessUpdateOneWithoutUserNestedInput
    courier?: CourierUpdateOneWithoutUserNestedInput
    customer?: CustomerUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    business?: BusinessUncheckedUpdateOneWithoutUserNestedInput
    courier?: CourierUncheckedUpdateOneWithoutUserNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourierUpsertWithoutNotificationPreferencesInput = {
    update: XOR<CourierUpdateWithoutNotificationPreferencesInput, CourierUncheckedUpdateWithoutNotificationPreferencesInput>
    create: XOR<CourierCreateWithoutNotificationPreferencesInput, CourierUncheckedCreateWithoutNotificationPreferencesInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutNotificationPreferencesInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutNotificationPreferencesInput, CourierUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type CourierUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    zone?: ZoneUpdateOneWithoutCouriersNestedInput
    orders?: OrderUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    payments?: PaymentUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUpdateManyWithoutCourierNestedInput
  }

  export type CourierUncheckedUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUncheckedUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUncheckedUpdateManyWithoutCourierNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutUserInput
    business?: BusinessCreateNestedOneWithoutUserInput
    courier?: CourierCreateNestedOneWithoutUserInput
    customer?: CustomerCreateNestedOneWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    business?: BusinessUncheckedCreateNestedOneWithoutUserInput
    courier?: CourierUncheckedCreateNestedOneWithoutUserInput
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type CourierCreateWithoutNotificationsInput = {
    id?: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    user: UserCreateNestedOneWithoutCourierInput
    zone?: ZoneCreateNestedOneWithoutCouriersInput
    orders?: OrderCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    payments?: PaymentCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteCreateNestedManyWithoutCourierInput
  }

  export type CourierUncheckedCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    zoneId?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityUncheckedCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteUncheckedCreateNestedManyWithoutCourierInput
  }

  export type CourierCreateOrConnectWithoutNotificationsInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutNotificationsInput, CourierUncheckedCreateWithoutNotificationsInput>
  }

  export type OrderCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    priority?: $Enums.DeliveryPriority
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    business: BusinessCreateNestedOneWithoutOrdersInput
    courier?: CourierCreateNestedOneWithoutOrdersInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    requestedTimeWindow?: DeliveryTimeWindowCreateNestedOneWithoutOrdersInput
    delivery?: DeliveryCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    customerId: string
    businessId: string
    courierId?: string | null
    priority?: $Enums.DeliveryPriority
    timeWindowId?: string | null
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    delivery?: DeliveryUncheckedCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutNotificationsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutNotificationsInput, OrderUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    business?: BusinessUpdateOneWithoutUserNestedInput
    courier?: CourierUpdateOneWithoutUserNestedInput
    customer?: CustomerUpdateOneWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    business?: BusinessUncheckedUpdateOneWithoutUserNestedInput
    courier?: CourierUncheckedUpdateOneWithoutUserNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourierUpsertWithoutNotificationsInput = {
    update: XOR<CourierUpdateWithoutNotificationsInput, CourierUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CourierCreateWithoutNotificationsInput, CourierUncheckedCreateWithoutNotificationsInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutNotificationsInput, CourierUncheckedUpdateWithoutNotificationsInput>
  }

  export type CourierUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    zone?: ZoneUpdateOneWithoutCouriersNestedInput
    orders?: OrderUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    payments?: PaymentUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUpdateManyWithoutCourierNestedInput
  }

  export type CourierUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUncheckedUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUncheckedUpdateManyWithoutCourierNestedInput
  }

  export type OrderUpsertWithoutNotificationsInput = {
    update: XOR<OrderUpdateWithoutNotificationsInput, OrderUncheckedUpdateWithoutNotificationsInput>
    create: XOR<OrderCreateWithoutNotificationsInput, OrderUncheckedCreateWithoutNotificationsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutNotificationsInput, OrderUncheckedUpdateWithoutNotificationsInput>
  }

  export type OrderUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    business?: BusinessUpdateOneRequiredWithoutOrdersNestedInput
    courier?: CourierUpdateOneWithoutOrdersNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    requestedTimeWindow?: DeliveryTimeWindowUpdateOneWithoutOrdersNestedInput
    delivery?: DeliveryUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    timeWindowId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    delivery?: DeliveryUncheckedUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type CourierCreateWithoutDeliveriesInput = {
    id?: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    user: UserCreateNestedOneWithoutCourierInput
    zone?: ZoneCreateNestedOneWithoutCouriersInput
    orders?: OrderCreateNestedManyWithoutCourierInput
    notifications?: NotificationCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCourierInput
    payments?: PaymentCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteCreateNestedManyWithoutCourierInput
  }

  export type CourierUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    userId: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    zoneId?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedCreateNestedManyWithoutCourierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCourierInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityUncheckedCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteUncheckedCreateNestedManyWithoutCourierInput
  }

  export type CourierCreateOrConnectWithoutDeliveriesInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutDeliveriesInput, CourierUncheckedCreateWithoutDeliveriesInput>
  }

  export type CustomerCreateWithoutDeliveriesInput = {
    id?: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    userId: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutDeliveriesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutDeliveriesInput, CustomerUncheckedCreateWithoutDeliveriesInput>
  }

  export type ZoneCreateWithoutDeliveriesInput = {
    id?: string
    name: string
    description?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    averageDeliveryTime?: number | null
    orderVolume?: number | null
    activeBusinesses?: number | null
    businesses?: BusinessCreateNestedManyWithoutZoneInput
    couriers?: CourierCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    name: string
    description?: string | null
    coordinates: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    averageDeliveryTime?: number | null
    orderVolume?: number | null
    activeBusinesses?: number | null
    businesses?: BusinessUncheckedCreateNestedManyWithoutZoneInput
    couriers?: CourierUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutDeliveriesInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutDeliveriesInput, ZoneUncheckedCreateWithoutDeliveriesInput>
  }

  export type OrderCreateWithoutDeliveryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    priority?: $Enums.DeliveryPriority
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    business: BusinessCreateNestedOneWithoutOrdersInput
    courier?: CourierCreateNestedOneWithoutOrdersInput
    notifications?: NotificationCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    requestedTimeWindow?: DeliveryTimeWindowCreateNestedOneWithoutOrdersInput
    refundRequests?: RefundRequestCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutDeliveryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    customerId: string
    businessId: string
    courierId?: string | null
    priority?: $Enums.DeliveryPriority
    timeWindowId?: string | null
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutDeliveryInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDeliveryInput, OrderUncheckedCreateWithoutDeliveryInput>
  }

  export type DeliveryRouteCreateWithoutDeliveriesInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.Status
    totalDistance?: number | null
    totalDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
    courier: CourierCreateNestedOneWithoutDeliveryRoutesInput
  }

  export type DeliveryRouteUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    courierId: string
    name?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.Status
    totalDistance?: number | null
    totalDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DeliveryRouteCreateOrConnectWithoutDeliveriesInput = {
    where: DeliveryRouteWhereUniqueInput
    create: XOR<DeliveryRouteCreateWithoutDeliveriesInput, DeliveryRouteUncheckedCreateWithoutDeliveriesInput>
  }

  export type CourierUpsertWithoutDeliveriesInput = {
    update: XOR<CourierUpdateWithoutDeliveriesInput, CourierUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<CourierCreateWithoutDeliveriesInput, CourierUncheckedCreateWithoutDeliveriesInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutDeliveriesInput, CourierUncheckedUpdateWithoutDeliveriesInput>
  }

  export type CourierUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    zone?: ZoneUpdateOneWithoutCouriersNestedInput
    orders?: OrderUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCourierNestedInput
    payments?: PaymentUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUpdateManyWithoutCourierNestedInput
  }

  export type CourierUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCourierNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUncheckedUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUncheckedUpdateManyWithoutCourierNestedInput
  }

  export type CustomerUpsertWithoutDeliveriesInput = {
    update: XOR<CustomerUpdateWithoutDeliveriesInput, CustomerUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<CustomerCreateWithoutDeliveriesInput, CustomerUncheckedCreateWithoutDeliveriesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutDeliveriesInput, CustomerUncheckedUpdateWithoutDeliveriesInput>
  }

  export type CustomerUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ZoneUpsertWithoutDeliveriesInput = {
    update: XOR<ZoneUpdateWithoutDeliveriesInput, ZoneUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<ZoneCreateWithoutDeliveriesInput, ZoneUncheckedCreateWithoutDeliveriesInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutDeliveriesInput, ZoneUncheckedUpdateWithoutDeliveriesInput>
  }

  export type ZoneUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    averageDeliveryTime?: NullableIntFieldUpdateOperationsInput | number | null
    orderVolume?: NullableIntFieldUpdateOperationsInput | number | null
    activeBusinesses?: NullableIntFieldUpdateOperationsInput | number | null
    businesses?: BusinessUpdateManyWithoutZoneNestedInput
    couriers?: CourierUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    averageDeliveryTime?: NullableIntFieldUpdateOperationsInput | number | null
    orderVolume?: NullableIntFieldUpdateOperationsInput | number | null
    activeBusinesses?: NullableIntFieldUpdateOperationsInput | number | null
    businesses?: BusinessUncheckedUpdateManyWithoutZoneNestedInput
    couriers?: CourierUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type OrderUpsertWithoutDeliveryInput = {
    update: XOR<OrderUpdateWithoutDeliveryInput, OrderUncheckedUpdateWithoutDeliveryInput>
    create: XOR<OrderCreateWithoutDeliveryInput, OrderUncheckedCreateWithoutDeliveryInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutDeliveryInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutDeliveryInput, OrderUncheckedUpdateWithoutDeliveryInput>
  }

  export type OrderUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    business?: BusinessUpdateOneRequiredWithoutOrdersNestedInput
    courier?: CourierUpdateOneWithoutOrdersNestedInput
    notifications?: NotificationUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    requestedTimeWindow?: DeliveryTimeWindowUpdateOneWithoutOrdersNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    timeWindowId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type DeliveryRouteUpsertWithoutDeliveriesInput = {
    update: XOR<DeliveryRouteUpdateWithoutDeliveriesInput, DeliveryRouteUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<DeliveryRouteCreateWithoutDeliveriesInput, DeliveryRouteUncheckedCreateWithoutDeliveriesInput>
    where?: DeliveryRouteWhereInput
  }

  export type DeliveryRouteUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: DeliveryRouteWhereInput
    data: XOR<DeliveryRouteUpdateWithoutDeliveriesInput, DeliveryRouteUncheckedUpdateWithoutDeliveriesInput>
  }

  export type DeliveryRouteUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
    courier?: CourierUpdateOneRequiredWithoutDeliveryRoutesNestedInput
  }

  export type DeliveryRouteUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BusinessCreateWithoutInventoryInput = {
    id?: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    user: UserCreateNestedOneWithoutBusinessInput
    zone?: ZoneCreateNestedOneWithoutBusinessesInput
    orders?: OrderCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBusinessInput
    payments?: PaymentCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutInventoryInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    zoneId?: string | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    orders?: OrderUncheckedCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBusinessInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyUncheckedCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutInventoryInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutInventoryInput, BusinessUncheckedCreateWithoutInventoryInput>
  }

  export type ProductCategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutProductCategoriesInput
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    slug: string
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type ProductCategoryCreateOrConnectWithoutProductsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type BusinessUpsertWithoutInventoryInput = {
    update: XOR<BusinessUpdateWithoutInventoryInput, BusinessUncheckedUpdateWithoutInventoryInput>
    create: XOR<BusinessCreateWithoutInventoryInput, BusinessUncheckedCreateWithoutInventoryInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutInventoryInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutInventoryInput, BusinessUncheckedUpdateWithoutInventoryInput>
  }

  export type BusinessUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    zone?: ZoneUpdateOneWithoutBusinessesNestedInput
    orders?: OrderUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    orders?: OrderUncheckedUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUncheckedUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type ProductCategoryUpsertWithoutProductsInput = {
    update: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutProductCategoriesNestedInput
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CourierCreateWithoutDeliveryLogsInput = {
    id?: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    user: UserCreateNestedOneWithoutCourierInput
    zone?: ZoneCreateNestedOneWithoutCouriersInput
    orders?: OrderCreateNestedManyWithoutCourierInput
    notifications?: NotificationCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    payments?: PaymentCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteCreateNestedManyWithoutCourierInput
  }

  export type CourierUncheckedCreateWithoutDeliveryLogsInput = {
    id?: string
    userId: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    zoneId?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedCreateNestedManyWithoutCourierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityUncheckedCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteUncheckedCreateNestedManyWithoutCourierInput
  }

  export type CourierCreateOrConnectWithoutDeliveryLogsInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutDeliveryLogsInput, CourierUncheckedCreateWithoutDeliveryLogsInput>
  }

  export type CourierUpsertWithoutDeliveryLogsInput = {
    update: XOR<CourierUpdateWithoutDeliveryLogsInput, CourierUncheckedUpdateWithoutDeliveryLogsInput>
    create: XOR<CourierCreateWithoutDeliveryLogsInput, CourierUncheckedCreateWithoutDeliveryLogsInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutDeliveryLogsInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutDeliveryLogsInput, CourierUncheckedUpdateWithoutDeliveryLogsInput>
  }

  export type CourierUpdateWithoutDeliveryLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    zone?: ZoneUpdateOneWithoutCouriersNestedInput
    orders?: OrderUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    payments?: PaymentUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUpdateManyWithoutCourierNestedInput
  }

  export type CourierUncheckedUpdateWithoutDeliveryLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUncheckedUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUncheckedUpdateManyWithoutCourierNestedInput
  }

  export type UserCreateWithoutReportsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutUserInput
    business?: BusinessCreateNestedOneWithoutUserInput
    courier?: CourierCreateNestedOneWithoutUserInput
    customer?: CustomerCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    business?: BusinessUncheckedCreateNestedOneWithoutUserInput
    courier?: CourierUncheckedCreateNestedOneWithoutUserInput
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
  }

  export type UserUpsertWithoutReportsInput = {
    update: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    business?: BusinessUpdateOneWithoutUserNestedInput
    courier?: CourierUpdateOneWithoutUserNestedInput
    customer?: CustomerUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    business?: BusinessUncheckedUpdateOneWithoutUserNestedInput
    courier?: CourierUncheckedUpdateOneWithoutUserNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ScheduledReportCreateWithoutScheduleInput = {
    id?: string
    reportName: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    recipients?: ScheduledReportCreaterecipientsInput | string[]
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutScheduledReportsInput
  }

  export type ScheduledReportUncheckedCreateWithoutScheduleInput = {
    id?: string
    userId: string
    reportName: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    recipients?: ScheduledReportCreaterecipientsInput | string[]
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportCreateOrConnectWithoutScheduleInput = {
    where: ScheduledReportWhereUniqueInput
    create: XOR<ScheduledReportCreateWithoutScheduleInput, ScheduledReportUncheckedCreateWithoutScheduleInput>
  }

  export type ScheduledReportCreateManyScheduleInputEnvelope = {
    data: ScheduledReportCreateManyScheduleInput | ScheduledReportCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledReportUpsertWithWhereUniqueWithoutScheduleInput = {
    where: ScheduledReportWhereUniqueInput
    update: XOR<ScheduledReportUpdateWithoutScheduleInput, ScheduledReportUncheckedUpdateWithoutScheduleInput>
    create: XOR<ScheduledReportCreateWithoutScheduleInput, ScheduledReportUncheckedCreateWithoutScheduleInput>
  }

  export type ScheduledReportUpdateWithWhereUniqueWithoutScheduleInput = {
    where: ScheduledReportWhereUniqueInput
    data: XOR<ScheduledReportUpdateWithoutScheduleInput, ScheduledReportUncheckedUpdateWithoutScheduleInput>
  }

  export type ScheduledReportUpdateManyWithWhereWithoutScheduleInput = {
    where: ScheduledReportScalarWhereInput
    data: XOR<ScheduledReportUpdateManyMutationInput, ScheduledReportUncheckedUpdateManyWithoutScheduleInput>
  }

  export type UserCreateWithoutScheduledReportsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutUserInput
    business?: BusinessCreateNestedOneWithoutUserInput
    courier?: CourierCreateNestedOneWithoutUserInput
    customer?: CustomerCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutScheduledReportsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    business?: BusinessUncheckedCreateNestedOneWithoutUserInput
    courier?: CourierUncheckedCreateNestedOneWithoutUserInput
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutScheduledReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScheduledReportsInput, UserUncheckedCreateWithoutScheduledReportsInput>
  }

  export type ScheduleCreateWithoutReportsInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUncheckedCreateWithoutReportsInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutReportsInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutReportsInput, ScheduleUncheckedCreateWithoutReportsInput>
  }

  export type UserUpsertWithoutScheduledReportsInput = {
    update: XOR<UserUpdateWithoutScheduledReportsInput, UserUncheckedUpdateWithoutScheduledReportsInput>
    create: XOR<UserCreateWithoutScheduledReportsInput, UserUncheckedCreateWithoutScheduledReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScheduledReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScheduledReportsInput, UserUncheckedUpdateWithoutScheduledReportsInput>
  }

  export type UserUpdateWithoutScheduledReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    business?: BusinessUpdateOneWithoutUserNestedInput
    courier?: CourierUpdateOneWithoutUserNestedInput
    customer?: CustomerUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutScheduledReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    business?: BusinessUncheckedUpdateOneWithoutUserNestedInput
    courier?: CourierUncheckedUpdateOneWithoutUserNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ScheduleUpsertWithoutReportsInput = {
    update: XOR<ScheduleUpdateWithoutReportsInput, ScheduleUncheckedUpdateWithoutReportsInput>
    create: XOR<ScheduleCreateWithoutReportsInput, ScheduleUncheckedCreateWithoutReportsInput>
    where?: ScheduleWhereInput
  }

  export type ScheduleUpdateToOneWithWhereWithoutReportsInput = {
    where?: ScheduleWhereInput
    data: XOR<ScheduleUpdateWithoutReportsInput, ScheduleUncheckedUpdateWithoutReportsInput>
  }

  export type ScheduleUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSettingsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutUserInput
    business?: BusinessCreateNestedOneWithoutUserInput
    courier?: CourierCreateNestedOneWithoutUserInput
    customer?: CustomerCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSettingsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    business?: BusinessUncheckedCreateNestedOneWithoutUserInput
    courier?: CourierUncheckedCreateNestedOneWithoutUserInput
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
  }

  export type UserUpsertWithoutSettingsInput = {
    update: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    business?: BusinessUpdateOneWithoutUserNestedInput
    courier?: CourierUpdateOneWithoutUserNestedInput
    customer?: CustomerUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    business?: BusinessUncheckedUpdateOneWithoutUserNestedInput
    courier?: CourierUncheckedUpdateOneWithoutUserNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BusinessCreateWithoutMenuItemsInput = {
    id?: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    user: UserCreateNestedOneWithoutBusinessInput
    zone?: ZoneCreateNestedOneWithoutBusinessesInput
    inventory?: InventoryCreateNestedManyWithoutBusinessInput
    orders?: OrderCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBusinessInput
    payments?: PaymentCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutMenuItemsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    zoneId?: string | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    inventory?: InventoryUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrderUncheckedCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBusinessInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyUncheckedCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutMenuItemsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutMenuItemsInput, BusinessUncheckedCreateWithoutMenuItemsInput>
  }

  export type BusinessUpsertWithoutMenuItemsInput = {
    update: XOR<BusinessUpdateWithoutMenuItemsInput, BusinessUncheckedUpdateWithoutMenuItemsInput>
    create: XOR<BusinessCreateWithoutMenuItemsInput, BusinessUncheckedCreateWithoutMenuItemsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutMenuItemsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutMenuItemsInput, BusinessUncheckedUpdateWithoutMenuItemsInput>
  }

  export type BusinessUpdateWithoutMenuItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    zone?: ZoneUpdateOneWithoutBusinessesNestedInput
    inventory?: InventoryUpdateManyWithoutBusinessNestedInput
    orders?: OrderUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutMenuItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    inventory?: InventoryUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUncheckedUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type CourierCreateWithoutAvailabilityInput = {
    id?: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    user: UserCreateNestedOneWithoutCourierInput
    zone?: ZoneCreateNestedOneWithoutCouriersInput
    orders?: OrderCreateNestedManyWithoutCourierInput
    notifications?: NotificationCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    payments?: PaymentCreateNestedManyWithoutRecipientInput
    deliveryRoutes?: DeliveryRouteCreateNestedManyWithoutCourierInput
  }

  export type CourierUncheckedCreateWithoutAvailabilityInput = {
    id?: string
    userId: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    zoneId?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedCreateNestedManyWithoutCourierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRecipientInput
    deliveryRoutes?: DeliveryRouteUncheckedCreateNestedManyWithoutCourierInput
  }

  export type CourierCreateOrConnectWithoutAvailabilityInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutAvailabilityInput, CourierUncheckedCreateWithoutAvailabilityInput>
  }

  export type CourierUpsertWithoutAvailabilityInput = {
    update: XOR<CourierUpdateWithoutAvailabilityInput, CourierUncheckedUpdateWithoutAvailabilityInput>
    create: XOR<CourierCreateWithoutAvailabilityInput, CourierUncheckedCreateWithoutAvailabilityInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutAvailabilityInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutAvailabilityInput, CourierUncheckedUpdateWithoutAvailabilityInput>
  }

  export type CourierUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    zone?: ZoneUpdateOneWithoutCouriersNestedInput
    orders?: OrderUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    payments?: PaymentUpdateManyWithoutRecipientNestedInput
    deliveryRoutes?: DeliveryRouteUpdateManyWithoutCourierNestedInput
  }

  export type CourierUncheckedUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryRoutes?: DeliveryRouteUncheckedUpdateManyWithoutCourierNestedInput
  }

  export type OrderCreateWithoutRequestedTimeWindowInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    priority?: $Enums.DeliveryPriority
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    business: BusinessCreateNestedOneWithoutOrdersInput
    courier?: CourierCreateNestedOneWithoutOrdersInput
    notifications?: NotificationCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    delivery?: DeliveryCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutRequestedTimeWindowInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    customerId: string
    businessId: string
    courierId?: string | null
    priority?: $Enums.DeliveryPriority
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    delivery?: DeliveryUncheckedCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutRequestedTimeWindowInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutRequestedTimeWindowInput, OrderUncheckedCreateWithoutRequestedTimeWindowInput>
  }

  export type OrderCreateManyRequestedTimeWindowInputEnvelope = {
    data: OrderCreateManyRequestedTimeWindowInput | OrderCreateManyRequestedTimeWindowInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutRequestedTimeWindowInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutRequestedTimeWindowInput, OrderUncheckedUpdateWithoutRequestedTimeWindowInput>
    create: XOR<OrderCreateWithoutRequestedTimeWindowInput, OrderUncheckedCreateWithoutRequestedTimeWindowInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutRequestedTimeWindowInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutRequestedTimeWindowInput, OrderUncheckedUpdateWithoutRequestedTimeWindowInput>
  }

  export type OrderUpdateManyWithWhereWithoutRequestedTimeWindowInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutRequestedTimeWindowInput>
  }

  export type CourierCreateWithoutDeliveryRoutesInput = {
    id?: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    user: UserCreateNestedOneWithoutCourierInput
    zone?: ZoneCreateNestedOneWithoutCouriersInput
    orders?: OrderCreateNestedManyWithoutCourierInput
    notifications?: NotificationCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    payments?: PaymentCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityCreateNestedManyWithoutCourierInput
  }

  export type CourierUncheckedCreateWithoutDeliveryRoutesInput = {
    id?: string
    userId: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    zoneId?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedCreateNestedManyWithoutCourierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    payments?: PaymentUncheckedCreateNestedManyWithoutRecipientInput
    availability?: CourierAvailabilityUncheckedCreateNestedManyWithoutCourierInput
  }

  export type CourierCreateOrConnectWithoutDeliveryRoutesInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutDeliveryRoutesInput, CourierUncheckedCreateWithoutDeliveryRoutesInput>
  }

  export type DeliveryCreateWithoutRouteInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
    courier: CourierCreateNestedOneWithoutDeliveriesInput
    customer: CustomerCreateNestedOneWithoutDeliveriesInput
    zone: ZoneCreateNestedOneWithoutDeliveriesInput
    order?: OrderCreateNestedOneWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutRouteInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    courierId: string
    customerId: string
    zoneId: string
    orderId?: string | null
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
  }

  export type DeliveryCreateOrConnectWithoutRouteInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutRouteInput, DeliveryUncheckedCreateWithoutRouteInput>
  }

  export type DeliveryCreateManyRouteInputEnvelope = {
    data: DeliveryCreateManyRouteInput | DeliveryCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type CourierUpsertWithoutDeliveryRoutesInput = {
    update: XOR<CourierUpdateWithoutDeliveryRoutesInput, CourierUncheckedUpdateWithoutDeliveryRoutesInput>
    create: XOR<CourierCreateWithoutDeliveryRoutesInput, CourierUncheckedCreateWithoutDeliveryRoutesInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutDeliveryRoutesInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutDeliveryRoutesInput, CourierUncheckedUpdateWithoutDeliveryRoutesInput>
  }

  export type CourierUpdateWithoutDeliveryRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    zone?: ZoneUpdateOneWithoutCouriersNestedInput
    orders?: OrderUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    payments?: PaymentUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUpdateManyWithoutCourierNestedInput
  }

  export type CourierUncheckedUpdateWithoutDeliveryRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUncheckedUpdateManyWithoutCourierNestedInput
  }

  export type DeliveryUpsertWithWhereUniqueWithoutRouteInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutRouteInput, DeliveryUncheckedUpdateWithoutRouteInput>
    create: XOR<DeliveryCreateWithoutRouteInput, DeliveryUncheckedCreateWithoutRouteInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutRouteInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutRouteInput, DeliveryUncheckedUpdateWithoutRouteInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutRouteInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutRouteInput>
  }

  export type OrderCreateWithoutPaymentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    priority?: $Enums.DeliveryPriority
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    business: BusinessCreateNestedOneWithoutOrdersInput
    courier?: CourierCreateNestedOneWithoutOrdersInput
    notifications?: NotificationCreateNestedManyWithoutOrderInput
    requestedTimeWindow?: DeliveryTimeWindowCreateNestedOneWithoutOrdersInput
    delivery?: DeliveryCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    customerId: string
    businessId: string
    courierId?: string | null
    priority?: $Enums.DeliveryPriority
    timeWindowId?: string | null
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrderInput
    delivery?: DeliveryUncheckedCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutOrderInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
  }

  export type CourierCreateWithoutPaymentsInput = {
    id?: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    user: UserCreateNestedOneWithoutCourierInput
    zone?: ZoneCreateNestedOneWithoutCouriersInput
    orders?: OrderCreateNestedManyWithoutCourierInput
    notifications?: NotificationCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    availability?: CourierAvailabilityCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteCreateNestedManyWithoutCourierInput
  }

  export type CourierUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    zoneId?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedCreateNestedManyWithoutCourierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCourierInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutCourierInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCourierInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    availability?: CourierAvailabilityUncheckedCreateNestedManyWithoutCourierInput
    deliveryRoutes?: DeliveryRouteUncheckedCreateNestedManyWithoutCourierInput
  }

  export type CourierCreateOrConnectWithoutPaymentsInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutPaymentsInput, CourierUncheckedCreateWithoutPaymentsInput>
  }

  export type BusinessCreateWithoutPaymentsInput = {
    id?: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    user: UserCreateNestedOneWithoutBusinessInput
    zone?: ZoneCreateNestedOneWithoutBusinessesInput
    inventory?: InventoryCreateNestedManyWithoutBusinessInput
    orders?: OrderCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    zoneId?: string | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    inventory?: InventoryUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrderUncheckedCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyUncheckedCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutPaymentsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutPaymentsInput, BusinessUncheckedCreateWithoutPaymentsInput>
  }

  export type OrderUpsertWithoutPaymentsInput = {
    update: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    business?: BusinessUpdateOneRequiredWithoutOrdersNestedInput
    courier?: CourierUpdateOneWithoutOrdersNestedInput
    notifications?: NotificationUpdateManyWithoutOrderNestedInput
    requestedTimeWindow?: DeliveryTimeWindowUpdateOneWithoutOrdersNestedInput
    delivery?: DeliveryUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    timeWindowId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutOrderNestedInput
    delivery?: DeliveryUncheckedUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type CourierUpsertWithoutPaymentsInput = {
    update: XOR<CourierUpdateWithoutPaymentsInput, CourierUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CourierCreateWithoutPaymentsInput, CourierUncheckedCreateWithoutPaymentsInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutPaymentsInput, CourierUncheckedUpdateWithoutPaymentsInput>
  }

  export type CourierUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    zone?: ZoneUpdateOneWithoutCouriersNestedInput
    orders?: OrderUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    availability?: CourierAvailabilityUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUpdateManyWithoutCourierNestedInput
  }

  export type CourierUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    availability?: CourierAvailabilityUncheckedUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUncheckedUpdateManyWithoutCourierNestedInput
  }

  export type BusinessUpsertWithoutPaymentsInput = {
    update: XOR<BusinessUpdateWithoutPaymentsInput, BusinessUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BusinessCreateWithoutPaymentsInput, BusinessUncheckedCreateWithoutPaymentsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutPaymentsInput, BusinessUncheckedUpdateWithoutPaymentsInput>
  }

  export type BusinessUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    zone?: ZoneUpdateOneWithoutBusinessesNestedInput
    inventory?: InventoryUpdateManyWithoutBusinessNestedInput
    orders?: OrderUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    inventory?: InventoryUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUncheckedUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateWithoutProductCategoriesInput = {
    id?: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    user: UserCreateNestedOneWithoutBusinessInput
    zone?: ZoneCreateNestedOneWithoutBusinessesInput
    inventory?: InventoryCreateNestedManyWithoutBusinessInput
    orders?: OrderCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemCreateNestedManyWithoutBusinessInput
    payments?: PaymentCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutProductCategoriesInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    zoneId?: string | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    inventory?: InventoryUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrderUncheckedCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutBusinessInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyUncheckedCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutProductCategoriesInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutProductCategoriesInput, BusinessUncheckedCreateWithoutProductCategoriesInput>
  }

  export type ProductCategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutProductCategoriesInput
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    products?: InventoryCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    slug: string
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    products?: InventoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutChildrenInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
  }

  export type ProductCategoryCreateWithoutParentInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutProductCategoriesInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    products?: InventoryCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutParentInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    slug: string
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
    products?: InventoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutParentInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput>
  }

  export type ProductCategoryCreateManyParentInputEnvelope = {
    data: ProductCategoryCreateManyParentInput | ProductCategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    price: number
    sku?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    quantity: number
    price: number
    sku?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateOrConnectWithoutCategoryInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutCategoryInput, InventoryUncheckedCreateWithoutCategoryInput>
  }

  export type InventoryCreateManyCategoryInputEnvelope = {
    data: InventoryCreateManyCategoryInput | InventoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithoutProductCategoriesInput = {
    update: XOR<BusinessUpdateWithoutProductCategoriesInput, BusinessUncheckedUpdateWithoutProductCategoriesInput>
    create: XOR<BusinessCreateWithoutProductCategoriesInput, BusinessUncheckedCreateWithoutProductCategoriesInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutProductCategoriesInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutProductCategoriesInput, BusinessUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type BusinessUpdateWithoutProductCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    zone?: ZoneUpdateOneWithoutBusinessesNestedInput
    inventory?: InventoryUpdateManyWithoutBusinessNestedInput
    orders?: OrderUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutProductCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    inventory?: InventoryUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUncheckedUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type ProductCategoryUpsertWithoutChildrenInput = {
    update: XOR<ProductCategoryUpdateWithoutChildrenInput, ProductCategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutChildrenInput, ProductCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type ProductCategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutProductCategoriesNestedInput
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    products?: InventoryUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: InventoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutParentInput, ProductCategoryUncheckedUpdateWithoutParentInput>
    create: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutParentInput, ProductCategoryUncheckedUpdateWithoutParentInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutParentInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type InventoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutCategoryInput, InventoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<InventoryCreateWithoutCategoryInput, InventoryUncheckedCreateWithoutCategoryInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutCategoryInput, InventoryUncheckedUpdateWithoutCategoryInput>
  }

  export type InventoryUpdateManyWithWhereWithoutCategoryInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type UserCreateWithoutActivityLogsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutUserInput
    business?: BusinessCreateNestedOneWithoutUserInput
    courier?: CourierCreateNestedOneWithoutUserInput
    customer?: CustomerCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    business?: BusinessUncheckedCreateNestedOneWithoutUserInput
    courier?: CourierUncheckedCreateNestedOneWithoutUserInput
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type AdminCreateWithoutActivityLogsInput = {
    id?: string
    department?: string | null
    level?: number
    permissions?: AdminCreatepermissionsInput | string[]
    title?: string | null
    phone?: string | null
    profileImage?: string | null
    lastLogin?: Date | string | null
    loginAttempts?: number
    isSuperAdmin?: boolean
    ipRestrictions?: AdminCreateipRestrictionsInput | string[]
    user: UserCreateNestedOneWithoutAdminInput
    systemActions?: SystemActionCreateNestedManyWithoutAdminInput
    dashboardWidgets?: AdminDashboardWidgetCreateNestedManyWithoutAdminInput
    roleMappings?: AdminRoleMappingCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    userId: string
    department?: string | null
    level?: number
    permissions?: AdminCreatepermissionsInput | string[]
    title?: string | null
    phone?: string | null
    profileImage?: string | null
    lastLogin?: Date | string | null
    loginAttempts?: number
    isSuperAdmin?: boolean
    ipRestrictions?: AdminCreateipRestrictionsInput | string[]
    systemActions?: SystemActionUncheckedCreateNestedManyWithoutAdminInput
    dashboardWidgets?: AdminDashboardWidgetUncheckedCreateNestedManyWithoutAdminInput
    roleMappings?: AdminRoleMappingUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutActivityLogsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutActivityLogsInput, AdminUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    business?: BusinessUpdateOneWithoutUserNestedInput
    courier?: CourierUpdateOneWithoutUserNestedInput
    customer?: CustomerUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    business?: BusinessUncheckedUpdateOneWithoutUserNestedInput
    courier?: CourierUncheckedUpdateOneWithoutUserNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AdminUpsertWithoutActivityLogsInput = {
    update: XOR<AdminUpdateWithoutActivityLogsInput, AdminUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<AdminCreateWithoutActivityLogsInput, AdminUncheckedCreateWithoutActivityLogsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutActivityLogsInput, AdminUncheckedUpdateWithoutActivityLogsInput>
  }

  export type AdminUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    permissions?: AdminUpdatepermissionsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    ipRestrictions?: AdminUpdateipRestrictionsInput | string[]
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    systemActions?: SystemActionUpdateManyWithoutAdminNestedInput
    dashboardWidgets?: AdminDashboardWidgetUpdateManyWithoutAdminNestedInput
    roleMappings?: AdminRoleMappingUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    permissions?: AdminUpdatepermissionsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    ipRestrictions?: AdminUpdateipRestrictionsInput | string[]
    systemActions?: SystemActionUncheckedUpdateManyWithoutAdminNestedInput
    dashboardWidgets?: AdminDashboardWidgetUncheckedUpdateManyWithoutAdminNestedInput
    roleMappings?: AdminRoleMappingUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateWithoutSystemActionsInput = {
    id?: string
    department?: string | null
    level?: number
    permissions?: AdminCreatepermissionsInput | string[]
    title?: string | null
    phone?: string | null
    profileImage?: string | null
    lastLogin?: Date | string | null
    loginAttempts?: number
    isSuperAdmin?: boolean
    ipRestrictions?: AdminCreateipRestrictionsInput | string[]
    user: UserCreateNestedOneWithoutAdminInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    dashboardWidgets?: AdminDashboardWidgetCreateNestedManyWithoutAdminInput
    roleMappings?: AdminRoleMappingCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutSystemActionsInput = {
    id?: string
    userId: string
    department?: string | null
    level?: number
    permissions?: AdminCreatepermissionsInput | string[]
    title?: string | null
    phone?: string | null
    profileImage?: string | null
    lastLogin?: Date | string | null
    loginAttempts?: number
    isSuperAdmin?: boolean
    ipRestrictions?: AdminCreateipRestrictionsInput | string[]
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    dashboardWidgets?: AdminDashboardWidgetUncheckedCreateNestedManyWithoutAdminInput
    roleMappings?: AdminRoleMappingUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutSystemActionsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutSystemActionsInput, AdminUncheckedCreateWithoutSystemActionsInput>
  }

  export type AdminUpsertWithoutSystemActionsInput = {
    update: XOR<AdminUpdateWithoutSystemActionsInput, AdminUncheckedUpdateWithoutSystemActionsInput>
    create: XOR<AdminCreateWithoutSystemActionsInput, AdminUncheckedCreateWithoutSystemActionsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutSystemActionsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutSystemActionsInput, AdminUncheckedUpdateWithoutSystemActionsInput>
  }

  export type AdminUpdateWithoutSystemActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    permissions?: AdminUpdatepermissionsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    ipRestrictions?: AdminUpdateipRestrictionsInput | string[]
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    dashboardWidgets?: AdminDashboardWidgetUpdateManyWithoutAdminNestedInput
    roleMappings?: AdminRoleMappingUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutSystemActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    permissions?: AdminUpdatepermissionsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    ipRestrictions?: AdminUpdateipRestrictionsInput | string[]
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    dashboardWidgets?: AdminDashboardWidgetUncheckedUpdateManyWithoutAdminNestedInput
    roleMappings?: AdminRoleMappingUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateWithoutDashboardWidgetsInput = {
    id?: string
    department?: string | null
    level?: number
    permissions?: AdminCreatepermissionsInput | string[]
    title?: string | null
    phone?: string | null
    profileImage?: string | null
    lastLogin?: Date | string | null
    loginAttempts?: number
    isSuperAdmin?: boolean
    ipRestrictions?: AdminCreateipRestrictionsInput | string[]
    user: UserCreateNestedOneWithoutAdminInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    systemActions?: SystemActionCreateNestedManyWithoutAdminInput
    roleMappings?: AdminRoleMappingCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutDashboardWidgetsInput = {
    id?: string
    userId: string
    department?: string | null
    level?: number
    permissions?: AdminCreatepermissionsInput | string[]
    title?: string | null
    phone?: string | null
    profileImage?: string | null
    lastLogin?: Date | string | null
    loginAttempts?: number
    isSuperAdmin?: boolean
    ipRestrictions?: AdminCreateipRestrictionsInput | string[]
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    systemActions?: SystemActionUncheckedCreateNestedManyWithoutAdminInput
    roleMappings?: AdminRoleMappingUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutDashboardWidgetsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutDashboardWidgetsInput, AdminUncheckedCreateWithoutDashboardWidgetsInput>
  }

  export type AdminUpsertWithoutDashboardWidgetsInput = {
    update: XOR<AdminUpdateWithoutDashboardWidgetsInput, AdminUncheckedUpdateWithoutDashboardWidgetsInput>
    create: XOR<AdminCreateWithoutDashboardWidgetsInput, AdminUncheckedCreateWithoutDashboardWidgetsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutDashboardWidgetsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutDashboardWidgetsInput, AdminUncheckedUpdateWithoutDashboardWidgetsInput>
  }

  export type AdminUpdateWithoutDashboardWidgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    permissions?: AdminUpdatepermissionsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    ipRestrictions?: AdminUpdateipRestrictionsInput | string[]
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    systemActions?: SystemActionUpdateManyWithoutAdminNestedInput
    roleMappings?: AdminRoleMappingUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutDashboardWidgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    permissions?: AdminUpdatepermissionsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    ipRestrictions?: AdminUpdateipRestrictionsInput | string[]
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    systemActions?: SystemActionUncheckedUpdateManyWithoutAdminNestedInput
    roleMappings?: AdminRoleMappingUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminRoleCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: AdminRoleMappingCreateNestedManyWithoutRoleInput
  }

  export type AdminRoleUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: AdminRoleMappingUncheckedCreateNestedManyWithoutRoleInput
  }

  export type AdminRoleCreateOrConnectWithoutPermissionsInput = {
    where: AdminRoleWhereUniqueInput
    create: XOR<AdminRoleCreateWithoutPermissionsInput, AdminRoleUncheckedCreateWithoutPermissionsInput>
  }

  export type AdminRoleUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: AdminRoleWhereUniqueInput
    update: XOR<AdminRoleUpdateWithoutPermissionsInput, AdminRoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<AdminRoleCreateWithoutPermissionsInput, AdminRoleUncheckedCreateWithoutPermissionsInput>
  }

  export type AdminRoleUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: AdminRoleWhereUniqueInput
    data: XOR<AdminRoleUpdateWithoutPermissionsInput, AdminRoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type AdminRoleUpdateManyWithWhereWithoutPermissionsInput = {
    where: AdminRoleScalarWhereInput
    data: XOR<AdminRoleUpdateManyMutationInput, AdminRoleUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type AdminRoleScalarWhereInput = {
    AND?: AdminRoleScalarWhereInput | AdminRoleScalarWhereInput[]
    OR?: AdminRoleScalarWhereInput[]
    NOT?: AdminRoleScalarWhereInput | AdminRoleScalarWhereInput[]
    id?: StringFilter<"AdminRole"> | string
    name?: StringFilter<"AdminRole"> | string
    description?: StringFilter<"AdminRole"> | string
    createdAt?: DateTimeFilter<"AdminRole"> | Date | string
    updatedAt?: DateTimeFilter<"AdminRole"> | Date | string
  }

  export type AdminPermissionCreateWithoutAdminRolesInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminPermissionUncheckedCreateWithoutAdminRolesInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminPermissionCreateOrConnectWithoutAdminRolesInput = {
    where: AdminPermissionWhereUniqueInput
    create: XOR<AdminPermissionCreateWithoutAdminRolesInput, AdminPermissionUncheckedCreateWithoutAdminRolesInput>
  }

  export type AdminRoleMappingCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutRoleMappingsInput
  }

  export type AdminRoleMappingUncheckedCreateWithoutRoleInput = {
    id?: string
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminRoleMappingCreateOrConnectWithoutRoleInput = {
    where: AdminRoleMappingWhereUniqueInput
    create: XOR<AdminRoleMappingCreateWithoutRoleInput, AdminRoleMappingUncheckedCreateWithoutRoleInput>
  }

  export type AdminRoleMappingCreateManyRoleInputEnvelope = {
    data: AdminRoleMappingCreateManyRoleInput | AdminRoleMappingCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type AdminPermissionUpsertWithWhereUniqueWithoutAdminRolesInput = {
    where: AdminPermissionWhereUniqueInput
    update: XOR<AdminPermissionUpdateWithoutAdminRolesInput, AdminPermissionUncheckedUpdateWithoutAdminRolesInput>
    create: XOR<AdminPermissionCreateWithoutAdminRolesInput, AdminPermissionUncheckedCreateWithoutAdminRolesInput>
  }

  export type AdminPermissionUpdateWithWhereUniqueWithoutAdminRolesInput = {
    where: AdminPermissionWhereUniqueInput
    data: XOR<AdminPermissionUpdateWithoutAdminRolesInput, AdminPermissionUncheckedUpdateWithoutAdminRolesInput>
  }

  export type AdminPermissionUpdateManyWithWhereWithoutAdminRolesInput = {
    where: AdminPermissionScalarWhereInput
    data: XOR<AdminPermissionUpdateManyMutationInput, AdminPermissionUncheckedUpdateManyWithoutAdminRolesInput>
  }

  export type AdminPermissionScalarWhereInput = {
    AND?: AdminPermissionScalarWhereInput | AdminPermissionScalarWhereInput[]
    OR?: AdminPermissionScalarWhereInput[]
    NOT?: AdminPermissionScalarWhereInput | AdminPermissionScalarWhereInput[]
    id?: StringFilter<"AdminPermission"> | string
    name?: StringFilter<"AdminPermission"> | string
    description?: StringFilter<"AdminPermission"> | string
    createdAt?: DateTimeFilter<"AdminPermission"> | Date | string
    updatedAt?: DateTimeFilter<"AdminPermission"> | Date | string
  }

  export type AdminRoleMappingUpsertWithWhereUniqueWithoutRoleInput = {
    where: AdminRoleMappingWhereUniqueInput
    update: XOR<AdminRoleMappingUpdateWithoutRoleInput, AdminRoleMappingUncheckedUpdateWithoutRoleInput>
    create: XOR<AdminRoleMappingCreateWithoutRoleInput, AdminRoleMappingUncheckedCreateWithoutRoleInput>
  }

  export type AdminRoleMappingUpdateWithWhereUniqueWithoutRoleInput = {
    where: AdminRoleMappingWhereUniqueInput
    data: XOR<AdminRoleMappingUpdateWithoutRoleInput, AdminRoleMappingUncheckedUpdateWithoutRoleInput>
  }

  export type AdminRoleMappingUpdateManyWithWhereWithoutRoleInput = {
    where: AdminRoleMappingScalarWhereInput
    data: XOR<AdminRoleMappingUpdateManyMutationInput, AdminRoleMappingUncheckedUpdateManyWithoutRoleInput>
  }

  export type AdminCreateWithoutRoleMappingsInput = {
    id?: string
    department?: string | null
    level?: number
    permissions?: AdminCreatepermissionsInput | string[]
    title?: string | null
    phone?: string | null
    profileImage?: string | null
    lastLogin?: Date | string | null
    loginAttempts?: number
    isSuperAdmin?: boolean
    ipRestrictions?: AdminCreateipRestrictionsInput | string[]
    user: UserCreateNestedOneWithoutAdminInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    systemActions?: SystemActionCreateNestedManyWithoutAdminInput
    dashboardWidgets?: AdminDashboardWidgetCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutRoleMappingsInput = {
    id?: string
    userId: string
    department?: string | null
    level?: number
    permissions?: AdminCreatepermissionsInput | string[]
    title?: string | null
    phone?: string | null
    profileImage?: string | null
    lastLogin?: Date | string | null
    loginAttempts?: number
    isSuperAdmin?: boolean
    ipRestrictions?: AdminCreateipRestrictionsInput | string[]
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    systemActions?: SystemActionUncheckedCreateNestedManyWithoutAdminInput
    dashboardWidgets?: AdminDashboardWidgetUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutRoleMappingsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutRoleMappingsInput, AdminUncheckedCreateWithoutRoleMappingsInput>
  }

  export type AdminRoleCreateWithoutAdminsInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: AdminPermissionCreateNestedManyWithoutAdminRolesInput
  }

  export type AdminRoleUncheckedCreateWithoutAdminsInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: AdminPermissionUncheckedCreateNestedManyWithoutAdminRolesInput
  }

  export type AdminRoleCreateOrConnectWithoutAdminsInput = {
    where: AdminRoleWhereUniqueInput
    create: XOR<AdminRoleCreateWithoutAdminsInput, AdminRoleUncheckedCreateWithoutAdminsInput>
  }

  export type AdminUpsertWithoutRoleMappingsInput = {
    update: XOR<AdminUpdateWithoutRoleMappingsInput, AdminUncheckedUpdateWithoutRoleMappingsInput>
    create: XOR<AdminCreateWithoutRoleMappingsInput, AdminUncheckedCreateWithoutRoleMappingsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutRoleMappingsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutRoleMappingsInput, AdminUncheckedUpdateWithoutRoleMappingsInput>
  }

  export type AdminUpdateWithoutRoleMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    permissions?: AdminUpdatepermissionsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    ipRestrictions?: AdminUpdateipRestrictionsInput | string[]
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    systemActions?: SystemActionUpdateManyWithoutAdminNestedInput
    dashboardWidgets?: AdminDashboardWidgetUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutRoleMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    permissions?: AdminUpdatepermissionsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    ipRestrictions?: AdminUpdateipRestrictionsInput | string[]
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    systemActions?: SystemActionUncheckedUpdateManyWithoutAdminNestedInput
    dashboardWidgets?: AdminDashboardWidgetUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminRoleUpsertWithoutAdminsInput = {
    update: XOR<AdminRoleUpdateWithoutAdminsInput, AdminRoleUncheckedUpdateWithoutAdminsInput>
    create: XOR<AdminRoleCreateWithoutAdminsInput, AdminRoleUncheckedCreateWithoutAdminsInput>
    where?: AdminRoleWhereInput
  }

  export type AdminRoleUpdateToOneWithWhereWithoutAdminsInput = {
    where?: AdminRoleWhereInput
    data: XOR<AdminRoleUpdateWithoutAdminsInput, AdminRoleUncheckedUpdateWithoutAdminsInput>
  }

  export type AdminRoleUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: AdminPermissionUpdateManyWithoutAdminRolesNestedInput
  }

  export type AdminRoleUncheckedUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: AdminPermissionUncheckedUpdateManyWithoutAdminRolesNestedInput
  }

  export type SentEmailCreateWithoutTemplateInput = {
    id?: string
    recipient: string
    subject: string
    variables: string
    messageId?: string | null
    sentBy: string
    sentAt?: Date | string
    status?: string
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SentEmailUncheckedCreateWithoutTemplateInput = {
    id?: string
    recipient: string
    subject: string
    variables: string
    messageId?: string | null
    sentBy: string
    sentAt?: Date | string
    status?: string
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SentEmailCreateOrConnectWithoutTemplateInput = {
    where: SentEmailWhereUniqueInput
    create: XOR<SentEmailCreateWithoutTemplateInput, SentEmailUncheckedCreateWithoutTemplateInput>
  }

  export type SentEmailCreateManyTemplateInputEnvelope = {
    data: SentEmailCreateManyTemplateInput | SentEmailCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type SentEmailUpsertWithWhereUniqueWithoutTemplateInput = {
    where: SentEmailWhereUniqueInput
    update: XOR<SentEmailUpdateWithoutTemplateInput, SentEmailUncheckedUpdateWithoutTemplateInput>
    create: XOR<SentEmailCreateWithoutTemplateInput, SentEmailUncheckedCreateWithoutTemplateInput>
  }

  export type SentEmailUpdateWithWhereUniqueWithoutTemplateInput = {
    where: SentEmailWhereUniqueInput
    data: XOR<SentEmailUpdateWithoutTemplateInput, SentEmailUncheckedUpdateWithoutTemplateInput>
  }

  export type SentEmailUpdateManyWithWhereWithoutTemplateInput = {
    where: SentEmailScalarWhereInput
    data: XOR<SentEmailUpdateManyMutationInput, SentEmailUncheckedUpdateManyWithoutTemplateInput>
  }

  export type SentEmailScalarWhereInput = {
    AND?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
    OR?: SentEmailScalarWhereInput[]
    NOT?: SentEmailScalarWhereInput | SentEmailScalarWhereInput[]
    id?: StringFilter<"SentEmail"> | string
    templateId?: StringFilter<"SentEmail"> | string
    recipient?: StringFilter<"SentEmail"> | string
    subject?: StringFilter<"SentEmail"> | string
    variables?: StringFilter<"SentEmail"> | string
    messageId?: StringNullableFilter<"SentEmail"> | string | null
    sentBy?: StringFilter<"SentEmail"> | string
    sentAt?: DateTimeFilter<"SentEmail"> | Date | string
    status?: StringFilter<"SentEmail"> | string
    category?: StringFilter<"SentEmail"> | string
    createdAt?: DateTimeFilter<"SentEmail"> | Date | string
    updatedAt?: DateTimeFilter<"SentEmail"> | Date | string
  }

  export type EmailTemplateCreateWithoutSentEmailsInput = {
    id?: string
    name: string
    subject: string
    body: string
    category: string
    description?: string | null
    isActive?: boolean
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type EmailTemplateUncheckedCreateWithoutSentEmailsInput = {
    id?: string
    name: string
    subject: string
    body: string
    category: string
    description?: string | null
    isActive?: boolean
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
  }

  export type EmailTemplateCreateOrConnectWithoutSentEmailsInput = {
    where: EmailTemplateWhereUniqueInput
    create: XOR<EmailTemplateCreateWithoutSentEmailsInput, EmailTemplateUncheckedCreateWithoutSentEmailsInput>
  }

  export type EmailTemplateUpsertWithoutSentEmailsInput = {
    update: XOR<EmailTemplateUpdateWithoutSentEmailsInput, EmailTemplateUncheckedUpdateWithoutSentEmailsInput>
    create: XOR<EmailTemplateCreateWithoutSentEmailsInput, EmailTemplateUncheckedCreateWithoutSentEmailsInput>
    where?: EmailTemplateWhereInput
  }

  export type EmailTemplateUpdateToOneWithWhereWithoutSentEmailsInput = {
    where?: EmailTemplateWhereInput
    data: XOR<EmailTemplateUpdateWithoutSentEmailsInput, EmailTemplateUncheckedUpdateWithoutSentEmailsInput>
  }

  export type EmailTemplateUpdateWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailTemplateUncheckedUpdateWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerCreateWithoutAddressesInput = {
    id?: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    deliveries?: DeliveryCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAddressesInput = {
    id?: string
    userId: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAddressesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
  }

  export type CustomerUpsertWithoutAddressesInput = {
    update: XOR<CustomerUpdateWithoutAddressesInput, CustomerUncheckedUpdateWithoutAddressesInput>
    create: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutAddressesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutAddressesInput, CustomerUncheckedUpdateWithoutAddressesInput>
  }

  export type CustomerUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    deliveries?: DeliveryUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrderCreateWithoutRefundRequestsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    priority?: $Enums.DeliveryPriority
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    business: BusinessCreateNestedOneWithoutOrdersInput
    courier?: CourierCreateNestedOneWithoutOrdersInput
    notifications?: NotificationCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    requestedTimeWindow?: DeliveryTimeWindowCreateNestedOneWithoutOrdersInput
    delivery?: DeliveryCreateNestedOneWithoutOrderInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutRefundRequestsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    customerId: string
    businessId: string
    courierId?: string | null
    priority?: $Enums.DeliveryPriority
    timeWindowId?: string | null
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    delivery?: DeliveryUncheckedCreateNestedOneWithoutOrderInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutRefundRequestsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutRefundRequestsInput, OrderUncheckedCreateWithoutRefundRequestsInput>
  }

  export type CustomerCreateWithoutRefundRequestsInput = {
    id?: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    deliveries?: DeliveryCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutRefundRequestsInput = {
    id?: string
    userId: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutRefundRequestsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutRefundRequestsInput, CustomerUncheckedCreateWithoutRefundRequestsInput>
  }

  export type BusinessCreateWithoutRefundRequestsInput = {
    id?: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    user: UserCreateNestedOneWithoutBusinessInput
    zone?: ZoneCreateNestedOneWithoutBusinessesInput
    inventory?: InventoryCreateNestedManyWithoutBusinessInput
    orders?: OrderCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBusinessInput
    payments?: PaymentCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutRefundRequestsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    zoneId?: string | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    inventory?: InventoryUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrderUncheckedCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBusinessInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyUncheckedCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutRefundRequestsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutRefundRequestsInput, BusinessUncheckedCreateWithoutRefundRequestsInput>
  }

  export type OrderUpsertWithoutRefundRequestsInput = {
    update: XOR<OrderUpdateWithoutRefundRequestsInput, OrderUncheckedUpdateWithoutRefundRequestsInput>
    create: XOR<OrderCreateWithoutRefundRequestsInput, OrderUncheckedCreateWithoutRefundRequestsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutRefundRequestsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutRefundRequestsInput, OrderUncheckedUpdateWithoutRefundRequestsInput>
  }

  export type OrderUpdateWithoutRefundRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    business?: BusinessUpdateOneRequiredWithoutOrdersNestedInput
    courier?: CourierUpdateOneWithoutOrdersNestedInput
    notifications?: NotificationUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    requestedTimeWindow?: DeliveryTimeWindowUpdateOneWithoutOrdersNestedInput
    delivery?: DeliveryUpdateOneWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutRefundRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    timeWindowId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    delivery?: DeliveryUncheckedUpdateOneWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type CustomerUpsertWithoutRefundRequestsInput = {
    update: XOR<CustomerUpdateWithoutRefundRequestsInput, CustomerUncheckedUpdateWithoutRefundRequestsInput>
    create: XOR<CustomerCreateWithoutRefundRequestsInput, CustomerUncheckedCreateWithoutRefundRequestsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutRefundRequestsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutRefundRequestsInput, CustomerUncheckedUpdateWithoutRefundRequestsInput>
  }

  export type CustomerUpdateWithoutRefundRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    deliveries?: DeliveryUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutRefundRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type BusinessUpsertWithoutRefundRequestsInput = {
    update: XOR<BusinessUpdateWithoutRefundRequestsInput, BusinessUncheckedUpdateWithoutRefundRequestsInput>
    create: XOR<BusinessCreateWithoutRefundRequestsInput, BusinessUncheckedCreateWithoutRefundRequestsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutRefundRequestsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutRefundRequestsInput, BusinessUncheckedUpdateWithoutRefundRequestsInput>
  }

  export type BusinessUpdateWithoutRefundRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    zone?: ZoneUpdateOneWithoutBusinessesNestedInput
    inventory?: InventoryUpdateManyWithoutBusinessNestedInput
    orders?: OrderUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutRefundRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    inventory?: InventoryUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUncheckedUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type OrderCreateWithoutCancellationRequestsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    priority?: $Enums.DeliveryPriority
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    business: BusinessCreateNestedOneWithoutOrdersInput
    courier?: CourierCreateNestedOneWithoutOrdersInput
    notifications?: NotificationCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    requestedTimeWindow?: DeliveryTimeWindowCreateNestedOneWithoutOrdersInput
    delivery?: DeliveryCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCancellationRequestsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    customerId: string
    businessId: string
    courierId?: string | null
    priority?: $Enums.DeliveryPriority
    timeWindowId?: string | null
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    delivery?: DeliveryUncheckedCreateNestedOneWithoutOrderInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCancellationRequestsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCancellationRequestsInput, OrderUncheckedCreateWithoutCancellationRequestsInput>
  }

  export type CustomerCreateWithoutCancellationRequestsInput = {
    id?: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    deliveries?: DeliveryCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCancellationRequestsInput = {
    id?: string
    userId: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCancellationRequestsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCancellationRequestsInput, CustomerUncheckedCreateWithoutCancellationRequestsInput>
  }

  export type BusinessCreateWithoutCancellationRequestsInput = {
    id?: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    user: UserCreateNestedOneWithoutBusinessInput
    zone?: ZoneCreateNestedOneWithoutBusinessesInput
    inventory?: InventoryCreateNestedManyWithoutBusinessInput
    orders?: OrderCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBusinessInput
    payments?: PaymentCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutCancellationRequestsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    zoneId?: string | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    inventory?: InventoryUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrderUncheckedCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBusinessInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyUncheckedCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutCancellationRequestsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutCancellationRequestsInput, BusinessUncheckedCreateWithoutCancellationRequestsInput>
  }

  export type OrderUpsertWithoutCancellationRequestsInput = {
    update: XOR<OrderUpdateWithoutCancellationRequestsInput, OrderUncheckedUpdateWithoutCancellationRequestsInput>
    create: XOR<OrderCreateWithoutCancellationRequestsInput, OrderUncheckedCreateWithoutCancellationRequestsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutCancellationRequestsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutCancellationRequestsInput, OrderUncheckedUpdateWithoutCancellationRequestsInput>
  }

  export type OrderUpdateWithoutCancellationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    business?: BusinessUpdateOneRequiredWithoutOrdersNestedInput
    courier?: CourierUpdateOneWithoutOrdersNestedInput
    notifications?: NotificationUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    requestedTimeWindow?: DeliveryTimeWindowUpdateOneWithoutOrdersNestedInput
    delivery?: DeliveryUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCancellationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    timeWindowId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    delivery?: DeliveryUncheckedUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type CustomerUpsertWithoutCancellationRequestsInput = {
    update: XOR<CustomerUpdateWithoutCancellationRequestsInput, CustomerUncheckedUpdateWithoutCancellationRequestsInput>
    create: XOR<CustomerCreateWithoutCancellationRequestsInput, CustomerUncheckedCreateWithoutCancellationRequestsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCancellationRequestsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCancellationRequestsInput, CustomerUncheckedUpdateWithoutCancellationRequestsInput>
  }

  export type CustomerUpdateWithoutCancellationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    deliveries?: DeliveryUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCancellationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type BusinessUpsertWithoutCancellationRequestsInput = {
    update: XOR<BusinessUpdateWithoutCancellationRequestsInput, BusinessUncheckedUpdateWithoutCancellationRequestsInput>
    create: XOR<BusinessCreateWithoutCancellationRequestsInput, BusinessUncheckedCreateWithoutCancellationRequestsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutCancellationRequestsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutCancellationRequestsInput, BusinessUncheckedUpdateWithoutCancellationRequestsInput>
  }

  export type BusinessUpdateWithoutCancellationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    zone?: ZoneUpdateOneWithoutBusinessesNestedInput
    inventory?: InventoryUpdateManyWithoutBusinessNestedInput
    orders?: OrderUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutCancellationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    inventory?: InventoryUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUncheckedUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateWithoutRefundPoliciesInput = {
    id?: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    user: UserCreateNestedOneWithoutBusinessInput
    zone?: ZoneCreateNestedOneWithoutBusinessesInput
    inventory?: InventoryCreateNestedManyWithoutBusinessInput
    orders?: OrderCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBusinessInput
    payments?: PaymentCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutRefundPoliciesInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    zoneId?: string | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    inventory?: InventoryUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrderUncheckedCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBusinessInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutRefundPoliciesInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutRefundPoliciesInput, BusinessUncheckedCreateWithoutRefundPoliciesInput>
  }

  export type BusinessUpsertWithoutRefundPoliciesInput = {
    update: XOR<BusinessUpdateWithoutRefundPoliciesInput, BusinessUncheckedUpdateWithoutRefundPoliciesInput>
    create: XOR<BusinessCreateWithoutRefundPoliciesInput, BusinessUncheckedCreateWithoutRefundPoliciesInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutRefundPoliciesInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutRefundPoliciesInput, BusinessUncheckedUpdateWithoutRefundPoliciesInput>
  }

  export type BusinessUpdateWithoutRefundPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    zone?: ZoneUpdateOneWithoutBusinessesNestedInput
    inventory?: InventoryUpdateManyWithoutBusinessNestedInput
    orders?: OrderUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutRefundPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    inventory?: InventoryUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type CustomerCreateWithoutSavedPaymentMethodsInput = {
    id?: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    deliveries?: DeliveryCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSavedPaymentMethodsInput = {
    id?: string
    userId: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSavedPaymentMethodsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSavedPaymentMethodsInput, CustomerUncheckedCreateWithoutSavedPaymentMethodsInput>
  }

  export type SubscriptionCreateWithoutSavedPaymentMethodInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    recurringPayments?: RecurringPaymentCreateNestedManyWithoutSubscriptionInput
    business?: BusinessCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutSavedPaymentMethodInput = {
    id?: string
    customerId: string
    planId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessId?: string | null
    recurringPayments?: RecurringPaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutSavedPaymentMethodInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutSavedPaymentMethodInput, SubscriptionUncheckedCreateWithoutSavedPaymentMethodInput>
  }

  export type SubscriptionCreateManySavedPaymentMethodInputEnvelope = {
    data: SubscriptionCreateManySavedPaymentMethodInput | SubscriptionCreateManySavedPaymentMethodInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutSavedPaymentMethodsInput = {
    update: XOR<CustomerUpdateWithoutSavedPaymentMethodsInput, CustomerUncheckedUpdateWithoutSavedPaymentMethodsInput>
    create: XOR<CustomerCreateWithoutSavedPaymentMethodsInput, CustomerUncheckedCreateWithoutSavedPaymentMethodsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSavedPaymentMethodsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSavedPaymentMethodsInput, CustomerUncheckedUpdateWithoutSavedPaymentMethodsInput>
  }

  export type CustomerUpdateWithoutSavedPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    deliveries?: DeliveryUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSavedPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutSavedPaymentMethodInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutSavedPaymentMethodInput, SubscriptionUncheckedUpdateWithoutSavedPaymentMethodInput>
    create: XOR<SubscriptionCreateWithoutSavedPaymentMethodInput, SubscriptionUncheckedCreateWithoutSavedPaymentMethodInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutSavedPaymentMethodInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutSavedPaymentMethodInput, SubscriptionUncheckedUpdateWithoutSavedPaymentMethodInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutSavedPaymentMethodInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutSavedPaymentMethodInput>
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionsInput
    savedPaymentMethod?: SavedPaymentMethodCreateNestedOneWithoutSubscriptionsInput
    recurringPayments?: RecurringPaymentCreateNestedManyWithoutSubscriptionInput
    business?: BusinessCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    customerId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    savedPaymentMethodId?: string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessId?: string | null
    recurringPayments?: RecurringPaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type BusinessCreateWithoutSubscriptionPlansInput = {
    id?: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    user: UserCreateNestedOneWithoutBusinessInput
    zone?: ZoneCreateNestedOneWithoutBusinessesInput
    inventory?: InventoryCreateNestedManyWithoutBusinessInput
    orders?: OrderCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBusinessInput
    payments?: PaymentCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutSubscriptionPlansInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    zoneId?: string | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    inventory?: InventoryUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrderUncheckedCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBusinessInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyUncheckedCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutBusinessInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutSubscriptionPlansInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutSubscriptionPlansInput, BusinessUncheckedCreateWithoutSubscriptionPlansInput>
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type BusinessUpsertWithoutSubscriptionPlansInput = {
    update: XOR<BusinessUpdateWithoutSubscriptionPlansInput, BusinessUncheckedUpdateWithoutSubscriptionPlansInput>
    create: XOR<BusinessCreateWithoutSubscriptionPlansInput, BusinessUncheckedCreateWithoutSubscriptionPlansInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutSubscriptionPlansInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutSubscriptionPlansInput, BusinessUncheckedUpdateWithoutSubscriptionPlansInput>
  }

  export type BusinessUpdateWithoutSubscriptionPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    zone?: ZoneUpdateOneWithoutBusinessesNestedInput
    inventory?: InventoryUpdateManyWithoutBusinessNestedInput
    orders?: OrderUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutSubscriptionPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    inventory?: InventoryUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUncheckedUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type CustomerCreateWithoutSubscriptionsInput = {
    id?: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    deliveries?: DeliveryCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    userId: string
    phone?: string | null
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCustomerInput
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutCustomerInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutCustomerInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSubscriptionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval?: $Enums.SubscriptionInterval
    intervalCount?: number
    trialPeriodDays?: number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    business?: BusinessCreateNestedOneWithoutSubscriptionPlansInput
  }

  export type SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval?: $Enums.SubscriptionInterval
    intervalCount?: number
    trialPeriodDays?: number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    businessId?: string | null
  }

  export type SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type SavedPaymentMethodCreateWithoutSubscriptionsInput = {
    id?: string
    type: $Enums.PaymentMethod
    provider: $Enums.PaymentProvider
    isDefault?: boolean
    nickName?: string | null
    cardBrand?: $Enums.CardBrand | null
    cardLast4?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    cardHolderName?: string | null
    bankName?: string | null
    bankAccountLast4?: string | null
    externalId?: string | null
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSavedPaymentMethodsInput
  }

  export type SavedPaymentMethodUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    customerId: string
    type: $Enums.PaymentMethod
    provider: $Enums.PaymentProvider
    isDefault?: boolean
    nickName?: string | null
    cardBrand?: $Enums.CardBrand | null
    cardLast4?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    cardHolderName?: string | null
    bankName?: string | null
    bankAccountLast4?: string | null
    externalId?: string | null
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedPaymentMethodCreateOrConnectWithoutSubscriptionsInput = {
    where: SavedPaymentMethodWhereUniqueInput
    create: XOR<SavedPaymentMethodCreateWithoutSubscriptionsInput, SavedPaymentMethodUncheckedCreateWithoutSubscriptionsInput>
  }

  export type RecurringPaymentCreateWithoutSubscriptionInput = {
    id?: string
    amount: number
    status: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date | string
    dueDate: Date | string
    description?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringPaymentUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    amount: number
    status: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date | string
    dueDate: Date | string
    description?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringPaymentCreateOrConnectWithoutSubscriptionInput = {
    where: RecurringPaymentWhereUniqueInput
    create: XOR<RecurringPaymentCreateWithoutSubscriptionInput, RecurringPaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type RecurringPaymentCreateManySubscriptionInputEnvelope = {
    data: RecurringPaymentCreateManySubscriptionInput | RecurringPaymentCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type BusinessCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    user: UserCreateNestedOneWithoutBusinessInput
    zone?: ZoneCreateNestedOneWithoutBusinessesInput
    inventory?: InventoryCreateNestedManyWithoutBusinessInput
    orders?: OrderCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBusinessInput
    payments?: PaymentCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    zoneId?: string | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
    inventory?: InventoryUncheckedCreateNestedManyWithoutBusinessInput
    orders?: OrderUncheckedCreateNestedManyWithoutBusinessInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutBusinessInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBusinessInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBusinessInput
    refundPolicies?: RefundPolicyUncheckedCreateNestedManyWithoutBusinessInput
    refundRequests?: RefundRequestUncheckedCreateNestedManyWithoutBusinessInput
    cancellationRequests?: CancellationRequestUncheckedCreateNestedManyWithoutBusinessInput
    subscriptionPlans?: SubscriptionPlanUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutSubscriptionsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutSubscriptionsInput, BusinessUncheckedCreateWithoutSubscriptionsInput>
  }

  export type CustomerUpsertWithoutSubscriptionsInput = {
    update: XOR<CustomerUpdateWithoutSubscriptionsInput, CustomerUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSubscriptionsInput, CustomerUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type CustomerUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    deliveries?: DeliveryUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCustomerNestedInput
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutCustomerNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutCustomerNestedInput
    savedPaymentMethods?: SavedPaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SubscriptionPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneWithoutSubscriptionPlansNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SavedPaymentMethodUpsertWithoutSubscriptionsInput = {
    update: XOR<SavedPaymentMethodUpdateWithoutSubscriptionsInput, SavedPaymentMethodUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<SavedPaymentMethodCreateWithoutSubscriptionsInput, SavedPaymentMethodUncheckedCreateWithoutSubscriptionsInput>
    where?: SavedPaymentMethodWhereInput
  }

  export type SavedPaymentMethodUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: SavedPaymentMethodWhereInput
    data: XOR<SavedPaymentMethodUpdateWithoutSubscriptionsInput, SavedPaymentMethodUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SavedPaymentMethodUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableEnumCardBrandFieldUpdateOperationsInput | $Enums.CardBrand | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    cardHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSavedPaymentMethodsNestedInput
  }

  export type SavedPaymentMethodUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableEnumCardBrandFieldUpdateOperationsInput | $Enums.CardBrand | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    cardHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringPaymentUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: RecurringPaymentWhereUniqueInput
    update: XOR<RecurringPaymentUpdateWithoutSubscriptionInput, RecurringPaymentUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<RecurringPaymentCreateWithoutSubscriptionInput, RecurringPaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type RecurringPaymentUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: RecurringPaymentWhereUniqueInput
    data: XOR<RecurringPaymentUpdateWithoutSubscriptionInput, RecurringPaymentUncheckedUpdateWithoutSubscriptionInput>
  }

  export type RecurringPaymentUpdateManyWithWhereWithoutSubscriptionInput = {
    where: RecurringPaymentScalarWhereInput
    data: XOR<RecurringPaymentUpdateManyMutationInput, RecurringPaymentUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type RecurringPaymentScalarWhereInput = {
    AND?: RecurringPaymentScalarWhereInput | RecurringPaymentScalarWhereInput[]
    OR?: RecurringPaymentScalarWhereInput[]
    NOT?: RecurringPaymentScalarWhereInput | RecurringPaymentScalarWhereInput[]
    id?: StringFilter<"RecurringPayment"> | string
    subscriptionId?: StringFilter<"RecurringPayment"> | string
    amount?: FloatFilter<"RecurringPayment"> | number
    status?: EnumPaymentStatusFilter<"RecurringPayment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"RecurringPayment"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"RecurringPayment"> | Date | string
    dueDate?: DateTimeFilter<"RecurringPayment"> | Date | string
    description?: StringNullableFilter<"RecurringPayment"> | string | null
    externalId?: StringNullableFilter<"RecurringPayment"> | string | null
    createdAt?: DateTimeFilter<"RecurringPayment"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringPayment"> | Date | string
  }

  export type BusinessUpsertWithoutSubscriptionsInput = {
    update: XOR<BusinessUpdateWithoutSubscriptionsInput, BusinessUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<BusinessCreateWithoutSubscriptionsInput, BusinessUncheckedCreateWithoutSubscriptionsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutSubscriptionsInput, BusinessUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type BusinessUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    zone?: ZoneUpdateOneWithoutBusinessesNestedInput
    inventory?: InventoryUpdateManyWithoutBusinessNestedInput
    orders?: OrderUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    inventory?: InventoryUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUncheckedUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type SubscriptionCreateWithoutRecurringPaymentsInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    savedPaymentMethod?: SavedPaymentMethodCreateNestedOneWithoutSubscriptionsInput
    business?: BusinessCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutRecurringPaymentsInput = {
    id?: string
    customerId: string
    planId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    savedPaymentMethodId?: string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessId?: string | null
  }

  export type SubscriptionCreateOrConnectWithoutRecurringPaymentsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutRecurringPaymentsInput, SubscriptionUncheckedCreateWithoutRecurringPaymentsInput>
  }

  export type SubscriptionUpsertWithoutRecurringPaymentsInput = {
    update: XOR<SubscriptionUpdateWithoutRecurringPaymentsInput, SubscriptionUncheckedUpdateWithoutRecurringPaymentsInput>
    create: XOR<SubscriptionCreateWithoutRecurringPaymentsInput, SubscriptionUncheckedCreateWithoutRecurringPaymentsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutRecurringPaymentsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutRecurringPaymentsInput, SubscriptionUncheckedUpdateWithoutRecurringPaymentsInput>
  }

  export type SubscriptionUpdateWithoutRecurringPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    savedPaymentMethod?: SavedPaymentMethodUpdateOneWithoutSubscriptionsNestedInput
    business?: BusinessUpdateOneWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutRecurringPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    courierId?: string | null
    orderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationPreferenceCreateManyUserInput = {
    id?: string
    courierId?: string | null
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
    frequency?: $Enums.NotificationFrequency
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateManyUserInput = {
    id?: string
    name: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    expiresAt?: Date | string | null
  }

  export type ScheduledReportCreateManyUserInput = {
    id?: string
    scheduleId: string
    reportName: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    recipients?: ScheduledReportCreaterecipientsInput | string[]
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityLogCreateManyUserInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    targetId?: string | null
    targetType?: string | null
    ip?: string | null
    userAgent?: string | null
    adminId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: string | null
    category?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    courier?: CourierUpdateOneWithoutNotificationsNestedInput
    order?: OrderUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    frequency?: EnumNotificationFrequencyFieldUpdateOperationsInput | $Enums.NotificationFrequency
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courier?: CourierUpdateOneWithoutNotificationPreferencesNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    frequency?: EnumNotificationFrequencyFieldUpdateOperationsInput | $Enums.NotificationFrequency
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    frequency?: EnumNotificationFrequencyFieldUpdateOperationsInput | $Enums.NotificationFrequency
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduledReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    recipients?: ScheduledReportUpdaterecipientsInput | string[]
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ScheduledReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    recipients?: ScheduledReportUpdaterecipientsInput | string[]
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    recipients?: ScheduledReportUpdaterecipientsInput | string[]
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: AdminUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogCreateManyAdminInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    userId?: string | null
    targetId?: string | null
    targetType?: string | null
    ip?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: string | null
    category?: string | null
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type SystemActionCreateManyAdminInput = {
    id?: string
    action: string
    description: string
    createdAt?: Date | string
    status?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    executionTime?: number | null
  }

  export type AdminDashboardWidgetCreateManyAdminInput = {
    id?: string
    name: string
    type: string
    position?: number
    size?: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminRoleMappingCreateManyAdminInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemActionUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SystemActionUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SystemActionUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdminDashboardWidgetUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminDashboardWidgetUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminDashboardWidgetUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleMappingUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: AdminRoleUpdateOneRequiredWithoutAdminsNestedInput
  }

  export type AdminRoleMappingUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleMappingUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyCourierInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    customerId: string
    businessId: string
    priority?: $Enums.DeliveryPriority
    timeWindowId?: string | null
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
  }

  export type NotificationCreateManyCourierInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    userId: string
    orderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationPreferenceCreateManyCourierInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    channel: $Enums.NotificationChannel
    frequency?: $Enums.NotificationFrequency
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryLogCreateManyCourierInput = {
    id?: string
    action: string
    timestamp?: Date | string
    latitude?: number | null
    longitude?: number | null
    note?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DeliveryCreateManyCourierInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    customerId: string
    zoneId: string
    orderId?: string | null
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    routeId?: string | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
  }

  export type PaymentCreateManyRecipientInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    orderId?: string | null
    businessId?: string | null
  }

  export type CourierAvailabilityCreateManyCourierInput = {
    id?: string
    status: $Enums.CourierAvailabilityStatus
    startTime: Date | string
    endTime?: Date | string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type DeliveryRouteCreateManyCourierInput = {
    id?: string
    name?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.Status
    totalDistance?: number | null
    totalDuration?: number | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OrderUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    business?: BusinessUpdateOneRequiredWithoutOrdersNestedInput
    notifications?: NotificationUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    requestedTimeWindow?: DeliveryTimeWindowUpdateOneWithoutOrdersNestedInput
    delivery?: DeliveryUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    timeWindowId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    delivery?: DeliveryUncheckedUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    timeWindowId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    order?: OrderUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateManyWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationPreferenceUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    frequency?: EnumNotificationFrequencyFieldUpdateOperationsInput | $Enums.NotificationFrequency
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    frequency?: EnumNotificationFrequencyFieldUpdateOperationsInput | $Enums.NotificationFrequency
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    frequency?: EnumNotificationFrequencyFieldUpdateOperationsInput | $Enums.NotificationFrequency
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryLogUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DeliveryLogUncheckedUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DeliveryLogUncheckedUpdateManyWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DeliveryUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    customer?: CustomerUpdateOneRequiredWithoutDeliveriesNestedInput
    zone?: ZoneUpdateOneRequiredWithoutDeliveriesNestedInput
    order?: OrderUpdateOneWithoutDeliveryNestedInput
    route?: DeliveryRouteUpdateOneWithoutDeliveriesNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
  }

  export type DeliveryUncheckedUpdateManyWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
  }

  export type PaymentUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneWithoutPaymentsNestedInput
    business?: BusinessUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourierAvailabilityUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourierAvailabilityUncheckedUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourierAvailabilityUncheckedUpdateManyWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryRouteUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
    deliveries?: DeliveryUpdateManyWithoutRouteNestedInput
  }

  export type DeliveryRouteUncheckedUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
    deliveries?: DeliveryUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type DeliveryRouteUncheckedUpdateManyWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routePath?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateManyOrderInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    userId: string
    courierId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentCreateManyOrderInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    recipientId?: string | null
    businessId?: string | null
  }

  export type RefundRequestCreateManyOrderInput = {
    id?: string
    customerId: string
    businessId: string
    status?: $Enums.RefundRequestStatus
    reason: $Enums.RefundReason
    otherReason?: string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: number | null
    approvedAmount?: number | null
    evidenceUrls?: RefundRequestCreateevidenceUrlsInput | string[]
    adminNotes?: string | null
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    refundedAt?: Date | string | null
  }

  export type CancellationRequestCreateManyOrderInput = {
    id?: string
    customerId: string
    businessId: string
    status?: $Enums.CancellationRequestStatus
    reason: $Enums.CancellationReason
    otherReason?: string | null
    cancellationFee?: number | null
    autoProcessed?: boolean
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    cancelledAt?: Date | string | null
  }

  export type NotificationUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    courier?: CourierUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipient?: CourierUpdateOneWithoutPaymentsNestedInput
    business?: BusinessUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefundRequestUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundRequestStatusFieldUpdateOperationsInput | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFieldUpdateOperationsInput | $Enums.RefundReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evidenceUrls?: RefundRequestUpdateevidenceUrlsInput | string[]
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutRefundRequestsNestedInput
    business?: BusinessUpdateOneRequiredWithoutRefundRequestsNestedInput
  }

  export type RefundRequestUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundRequestStatusFieldUpdateOperationsInput | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFieldUpdateOperationsInput | $Enums.RefundReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evidenceUrls?: RefundRequestUpdateevidenceUrlsInput | string[]
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundRequestUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundRequestStatusFieldUpdateOperationsInput | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFieldUpdateOperationsInput | $Enums.RefundReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evidenceUrls?: RefundRequestUpdateevidenceUrlsInput | string[]
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CancellationRequestUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCancellationRequestStatusFieldUpdateOperationsInput | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFieldUpdateOperationsInput | $Enums.CancellationReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    autoProcessed?: BoolFieldUpdateOperationsInput | boolean
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutCancellationRequestsNestedInput
    business?: BusinessUpdateOneRequiredWithoutCancellationRequestsNestedInput
  }

  export type CancellationRequestUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    status?: EnumCancellationRequestStatusFieldUpdateOperationsInput | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFieldUpdateOperationsInput | $Enums.CancellationReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    autoProcessed?: BoolFieldUpdateOperationsInput | boolean
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CancellationRequestUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    status?: EnumCancellationRequestStatusFieldUpdateOperationsInput | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFieldUpdateOperationsInput | $Enums.CancellationReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    autoProcessed?: BoolFieldUpdateOperationsInput | boolean
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    businessId: string
    courierId?: string | null
    priority?: $Enums.DeliveryPriority
    timeWindowId?: string | null
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
  }

  export type DeliveryCreateManyCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    courierId: string
    zoneId: string
    orderId?: string | null
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    routeId?: string | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
  }

  export type CustomerAddressCreateManyCustomerInput = {
    id?: string
    title: string
    firstName: string
    lastName: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    postalCode: string
    country?: string
    phone?: string | null
    notes?: string | null
    latitude?: number | null
    longitude?: number | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundRequestCreateManyCustomerInput = {
    id?: string
    orderId: string
    businessId: string
    status?: $Enums.RefundRequestStatus
    reason: $Enums.RefundReason
    otherReason?: string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: number | null
    approvedAmount?: number | null
    evidenceUrls?: RefundRequestCreateevidenceUrlsInput | string[]
    adminNotes?: string | null
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    refundedAt?: Date | string | null
  }

  export type CancellationRequestCreateManyCustomerInput = {
    id?: string
    orderId: string
    businessId: string
    status?: $Enums.CancellationRequestStatus
    reason: $Enums.CancellationReason
    otherReason?: string | null
    cancellationFee?: number | null
    autoProcessed?: boolean
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    cancelledAt?: Date | string | null
  }

  export type SavedPaymentMethodCreateManyCustomerInput = {
    id?: string
    type: $Enums.PaymentMethod
    provider: $Enums.PaymentProvider
    isDefault?: boolean
    nickName?: string | null
    cardBrand?: $Enums.CardBrand | null
    cardLast4?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    cardHolderName?: string | null
    bankName?: string | null
    bankAccountLast4?: string | null
    externalId?: string | null
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyCustomerInput = {
    id?: string
    planId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    savedPaymentMethodId?: string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessId?: string | null
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    business?: BusinessUpdateOneRequiredWithoutOrdersNestedInput
    courier?: CourierUpdateOneWithoutOrdersNestedInput
    notifications?: NotificationUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    requestedTimeWindow?: DeliveryTimeWindowUpdateOneWithoutOrdersNestedInput
    delivery?: DeliveryUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    businessId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    timeWindowId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    delivery?: DeliveryUncheckedUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    businessId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    timeWindowId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    courier?: CourierUpdateOneRequiredWithoutDeliveriesNestedInput
    zone?: ZoneUpdateOneRequiredWithoutDeliveriesNestedInput
    order?: OrderUpdateOneWithoutDeliveryNestedInput
    route?: DeliveryRouteUpdateOneWithoutDeliveriesNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
  }

  export type DeliveryUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
  }

  export type CustomerAddressUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundRequestUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundRequestStatusFieldUpdateOperationsInput | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFieldUpdateOperationsInput | $Enums.RefundReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evidenceUrls?: RefundRequestUpdateevidenceUrlsInput | string[]
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutRefundRequestsNestedInput
    business?: BusinessUpdateOneRequiredWithoutRefundRequestsNestedInput
  }

  export type RefundRequestUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundRequestStatusFieldUpdateOperationsInput | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFieldUpdateOperationsInput | $Enums.RefundReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evidenceUrls?: RefundRequestUpdateevidenceUrlsInput | string[]
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundRequestUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundRequestStatusFieldUpdateOperationsInput | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFieldUpdateOperationsInput | $Enums.RefundReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evidenceUrls?: RefundRequestUpdateevidenceUrlsInput | string[]
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CancellationRequestUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCancellationRequestStatusFieldUpdateOperationsInput | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFieldUpdateOperationsInput | $Enums.CancellationReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    autoProcessed?: BoolFieldUpdateOperationsInput | boolean
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutCancellationRequestsNestedInput
    business?: BusinessUpdateOneRequiredWithoutCancellationRequestsNestedInput
  }

  export type CancellationRequestUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    status?: EnumCancellationRequestStatusFieldUpdateOperationsInput | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFieldUpdateOperationsInput | $Enums.CancellationReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    autoProcessed?: BoolFieldUpdateOperationsInput | boolean
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CancellationRequestUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    status?: EnumCancellationRequestStatusFieldUpdateOperationsInput | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFieldUpdateOperationsInput | $Enums.CancellationReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    autoProcessed?: BoolFieldUpdateOperationsInput | boolean
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SavedPaymentMethodUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableEnumCardBrandFieldUpdateOperationsInput | $Enums.CardBrand | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    cardHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutSavedPaymentMethodNestedInput
  }

  export type SavedPaymentMethodUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableEnumCardBrandFieldUpdateOperationsInput | $Enums.CardBrand | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    cardHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutSavedPaymentMethodNestedInput
  }

  export type SavedPaymentMethodUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableEnumCardBrandFieldUpdateOperationsInput | $Enums.CardBrand | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    cardHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    savedPaymentMethod?: SavedPaymentMethodUpdateOneWithoutSubscriptionsNestedInput
    recurringPayments?: RecurringPaymentUpdateManyWithoutSubscriptionNestedInput
    business?: BusinessUpdateOneWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    recurringPayments?: RecurringPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryCreateManyBusinessInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    price: number
    sku?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
  }

  export type OrderCreateManyBusinessInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    customerId: string
    courierId?: string | null
    priority?: $Enums.DeliveryPriority
    timeWindowId?: string | null
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
  }

  export type MenuItemCreateManyBusinessInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    imageUrl?: string | null
    category?: string | null
    tags?: MenuItemCreatetagsInput | string[]
    ingredients?: MenuItemCreateingredientsInput | string[]
    calories?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryCreateManyBusinessInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
  }

  export type PaymentCreateManyBusinessInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    reference?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    orderId?: string | null
    recipientId?: string | null
  }

  export type RefundPolicyCreateManyBusinessInput = {
    id?: string
    name: string
    description?: string | null
    autoApproveTimeline?: number | null
    timeLimit?: number | null
    orderStatusRules?: NullableJsonNullValueInput | InputJsonValue
    productRules?: NullableJsonNullValueInput | InputJsonValue
    cancellationFees?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundRequestCreateManyBusinessInput = {
    id?: string
    orderId: string
    customerId: string
    status?: $Enums.RefundRequestStatus
    reason: $Enums.RefundReason
    otherReason?: string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: number | null
    approvedAmount?: number | null
    evidenceUrls?: RefundRequestCreateevidenceUrlsInput | string[]
    adminNotes?: string | null
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    refundedAt?: Date | string | null
  }

  export type CancellationRequestCreateManyBusinessInput = {
    id?: string
    orderId: string
    customerId: string
    status?: $Enums.CancellationRequestStatus
    reason: $Enums.CancellationReason
    otherReason?: string | null
    cancellationFee?: number | null
    autoProcessed?: boolean
    customerNotes?: string | null
    businessNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    cancelledAt?: Date | string | null
  }

  export type SubscriptionPlanCreateManyBusinessInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval?: $Enums.SubscriptionInterval
    intervalCount?: number
    trialPeriodDays?: number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyBusinessInput = {
    id?: string
    customerId: string
    planId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    savedPaymentMethodId?: string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
  }

  export type InventoryUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    courier?: CourierUpdateOneWithoutOrdersNestedInput
    notifications?: NotificationUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    requestedTimeWindow?: DeliveryTimeWindowUpdateOneWithoutOrdersNestedInput
    delivery?: DeliveryUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    timeWindowId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    delivery?: DeliveryUncheckedUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    timeWindowId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MenuItemUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MenuItemUpdatetagsInput | string[]
    ingredients?: MenuItemUpdateingredientsInput | string[]
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MenuItemUpdatetagsInput | string[]
    ingredients?: MenuItemUpdateingredientsInput | string[]
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MenuItemUpdatetagsInput | string[]
    ingredients?: MenuItemUpdateingredientsInput | string[]
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    products?: InventoryUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: InventoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneWithoutPaymentsNestedInput
    recipient?: CourierUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefundPolicyUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    autoApproveTimeline?: NullableIntFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    orderStatusRules?: NullableJsonNullValueInput | InputJsonValue
    productRules?: NullableJsonNullValueInput | InputJsonValue
    cancellationFees?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundPolicyUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    autoApproveTimeline?: NullableIntFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    orderStatusRules?: NullableJsonNullValueInput | InputJsonValue
    productRules?: NullableJsonNullValueInput | InputJsonValue
    cancellationFees?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundPolicyUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    autoApproveTimeline?: NullableIntFieldUpdateOperationsInput | number | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    orderStatusRules?: NullableJsonNullValueInput | InputJsonValue
    productRules?: NullableJsonNullValueInput | InputJsonValue
    cancellationFees?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundRequestUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundRequestStatusFieldUpdateOperationsInput | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFieldUpdateOperationsInput | $Enums.RefundReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evidenceUrls?: RefundRequestUpdateevidenceUrlsInput | string[]
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutRefundRequestsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutRefundRequestsNestedInput
  }

  export type RefundRequestUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundRequestStatusFieldUpdateOperationsInput | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFieldUpdateOperationsInput | $Enums.RefundReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evidenceUrls?: RefundRequestUpdateevidenceUrlsInput | string[]
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundRequestUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundRequestStatusFieldUpdateOperationsInput | $Enums.RefundRequestStatus
    reason?: EnumRefundReasonFieldUpdateOperationsInput | $Enums.RefundReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedItems?: NullableJsonNullValueInput | InputJsonValue
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    approvedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    evidenceUrls?: RefundRequestUpdateevidenceUrlsInput | string[]
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CancellationRequestUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCancellationRequestStatusFieldUpdateOperationsInput | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFieldUpdateOperationsInput | $Enums.CancellationReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    autoProcessed?: BoolFieldUpdateOperationsInput | boolean
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutCancellationRequestsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutCancellationRequestsNestedInput
  }

  export type CancellationRequestUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCancellationRequestStatusFieldUpdateOperationsInput | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFieldUpdateOperationsInput | $Enums.CancellationReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    autoProcessed?: BoolFieldUpdateOperationsInput | boolean
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CancellationRequestUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumCancellationRequestStatusFieldUpdateOperationsInput | $Enums.CancellationRequestStatus
    reason?: EnumCancellationReasonFieldUpdateOperationsInput | $Enums.CancellationReason
    otherReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationFee?: NullableFloatFieldUpdateOperationsInput | number | null
    autoProcessed?: BoolFieldUpdateOperationsInput | boolean
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    businessNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionPlanUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | $Enums.SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialPeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    savedPaymentMethod?: SavedPaymentMethodUpdateOneWithoutSubscriptionsNestedInput
    recurringPayments?: RecurringPaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recurringPayments?: RecurringPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessCreateManyZoneInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    address?: string | null
    phone?: string | null
    website?: string | null
    email?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    status?: $Enums.Status
    rating?: number | null
    tax_id?: string | null
    bank_iban?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openingTime?: string | null
    closingTime?: string | null
    deliveryRadius?: number | null
    deliveryFee?: number | null
    facebook?: string | null
    instagram?: string | null
    twitter?: string | null
    type?: string | null
    tags?: BusinessCreatetagsInput | string[]
    features?: BusinessCreatefeaturesInput | string[]
  }

  export type CourierCreateManyZoneInput = {
    id?: string
    userId: string
    status?: $Enums.Status
    vehicleType?: string | null
    phone?: string | null
    ratings?: number | null
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    availableFrom?: Date | string | null
    availableTo?: Date | string | null
    documentsVerified?: boolean
    backgroundChecked?: boolean
    maxDeliveriesPerDay?: number
    maxDistance?: number | null
    averageSpeed?: number | null
    courierFee?: number | null
    lastSeen?: Date | string | null
    availabilityStatus?: $Enums.CourierAvailabilityStatus | null
  }

  export type DeliveryCreateManyZoneInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    courierId: string
    customerId: string
    orderId?: string | null
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    routeId?: string | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
  }

  export type BusinessUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    user?: UserUpdateOneRequiredWithoutBusinessNestedInput
    inventory?: InventoryUpdateManyWithoutBusinessNestedInput
    orders?: OrderUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
    inventory?: InventoryUncheckedUpdateManyWithoutBusinessNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBusinessNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutBusinessNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBusinessNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBusinessNestedInput
    refundPolicies?: RefundPolicyUncheckedUpdateManyWithoutBusinessNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutBusinessNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptionPlans?: SubscriptionPlanUncheckedUpdateManyWithoutBusinessNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_iban?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openingTime?: NullableStringFieldUpdateOperationsInput | string | null
    closingTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BusinessUpdatetagsInput | string[]
    features?: BusinessUpdatefeaturesInput | string[]
  }

  export type CourierUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    orders?: OrderUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    payments?: PaymentUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUpdateManyWithoutCourierNestedInput
  }

  export type CourierUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
    orders?: OrderUncheckedUpdateManyWithoutCourierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCourierNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateManyWithoutCourierNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCourierNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutRecipientNestedInput
    availability?: CourierAvailabilityUncheckedUpdateManyWithoutCourierNestedInput
    deliveryRoutes?: DeliveryRouteUncheckedUpdateManyWithoutCourierNestedInput
  }

  export type CourierUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    backgroundChecked?: BoolFieldUpdateOperationsInput | boolean
    maxDeliveriesPerDay?: IntFieldUpdateOperationsInput | number
    maxDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    averageSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    courierFee?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availabilityStatus?: NullableEnumCourierAvailabilityStatusFieldUpdateOperationsInput | $Enums.CourierAvailabilityStatus | null
  }

  export type DeliveryUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    courier?: CourierUpdateOneRequiredWithoutDeliveriesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutDeliveriesNestedInput
    order?: OrderUpdateOneWithoutDeliveryNestedInput
    route?: DeliveryRouteUpdateOneWithoutDeliveriesNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
  }

  export type DeliveryUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
  }

  export type ScheduledReportCreateManyScheduleInput = {
    id?: string
    userId: string
    reportName: string
    type: $Enums.ReportType
    format: $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    recipients?: ScheduledReportCreaterecipientsInput | string[]
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    recipients?: ScheduledReportUpdaterecipientsInput | string[]
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutScheduledReportsNestedInput
  }

  export type ScheduledReportUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    recipients?: ScheduledReportUpdaterecipientsInput | string[]
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportUncheckedUpdateManyWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    format?: EnumReportFormatFieldUpdateOperationsInput | $Enums.ReportFormat
    parameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    recipients?: ScheduledReportUpdaterecipientsInput | string[]
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyRequestedTimeWindowInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    totalPrice: number
    items: JsonNullValueInput | InputJsonValue
    address: string
    notes?: string | null
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    customerId: string
    businessId: string
    courierId?: string | null
    priority?: $Enums.DeliveryPriority
    estimatedDuration?: number | null
    estimatedDistance?: number | null
    sequenceNumber?: number | null
    refundStatus?: string | null
    cancellationStatus?: string | null
  }

  export type OrderUpdateWithoutRequestedTimeWindowInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    business?: BusinessUpdateOneRequiredWithoutOrdersNestedInput
    courier?: CourierUpdateOneWithoutOrdersNestedInput
    notifications?: NotificationUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    delivery?: DeliveryUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutRequestedTimeWindowInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    delivery?: DeliveryUncheckedUpdateOneWithoutOrderNestedInput
    refundRequests?: RefundRequestUncheckedUpdateManyWithoutOrderNestedInput
    cancellationRequests?: CancellationRequestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutRequestedTimeWindowInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    totalPrice?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryCreateManyRouteInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    courierId: string
    customerId: string
    zoneId: string
    orderId?: string | null
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    estimatedPickupTime?: Date | string | null
    estimatedDeliveryTime?: Date | string | null
    duration?: number | null
    actualDuration?: number | null
    distance?: number | null
    actualDistance?: number | null
    pickupLatitude?: number | null
    pickupLongitude?: number | null
    dropoffLatitude?: number | null
    dropoffLongitude?: number | null
    sequenceNumber?: number | null
    priority?: $Enums.DeliveryPriority
  }

  export type DeliveryUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
    courier?: CourierUpdateOneRequiredWithoutDeliveriesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutDeliveriesNestedInput
    zone?: ZoneUpdateOneRequiredWithoutDeliveriesNestedInput
    order?: OrderUpdateOneWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
  }

  export type DeliveryUncheckedUpdateManyWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDeliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    actualDistance?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    pickupLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    dropoffLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sequenceNumber?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: EnumDeliveryPriorityFieldUpdateOperationsInput | $Enums.DeliveryPriority
  }

  export type ProductCategoryCreateManyParentInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    slug: string
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateManyCategoryInput = {
    id?: string
    businessId: string
    name: string
    description?: string | null
    quantity: number
    price: number
    sku?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutProductCategoriesNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    products?: InventoryUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: InventoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: AdminRoleMappingUpdateManyWithoutRoleNestedInput
  }

  export type AdminRoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: AdminRoleMappingUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type AdminRoleUncheckedUpdateManyWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleMappingCreateManyRoleInput = {
    id?: string
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminPermissionUpdateWithoutAdminRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPermissionUncheckedUpdateWithoutAdminRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPermissionUncheckedUpdateManyWithoutAdminRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleMappingUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutRoleMappingsNestedInput
  }

  export type AdminRoleMappingUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleMappingUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SentEmailCreateManyTemplateInput = {
    id?: string
    recipient: string
    subject: string
    variables: string
    messageId?: string | null
    sentBy: string
    sentAt?: Date | string
    status?: string
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SentEmailUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    sentBy?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SentEmailUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    sentBy?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SentEmailUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    variables?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    sentBy?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManySavedPaymentMethodInput = {
    id?: string
    customerId: string
    planId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessId?: string | null
  }

  export type SubscriptionUpdateWithoutSavedPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    recurringPayments?: RecurringPaymentUpdateManyWithoutSubscriptionNestedInput
    business?: BusinessUpdateOneWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutSavedPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    recurringPayments?: RecurringPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutSavedPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: string
    customerId: string
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    canceledAt?: Date | string | null
    pausedAt?: Date | string | null
    resumeAt?: Date | string | null
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate?: Date | string | null
    savedPaymentMethodId?: string | null
    quantity?: number
    autoRenew?: boolean
    cancelAtPeriodEnd?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessId?: string | null
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput
    savedPaymentMethod?: SavedPaymentMethodUpdateOneWithoutSubscriptionsNestedInput
    recurringPayments?: RecurringPaymentUpdateManyWithoutSubscriptionNestedInput
    business?: BusinessUpdateOneWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    recurringPayments?: RecurringPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resumeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedPaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecurringPaymentCreateManySubscriptionInput = {
    id?: string
    amount: number
    status: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date | string
    dueDate: Date | string
    description?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringPaymentUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringPaymentUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringPaymentUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}